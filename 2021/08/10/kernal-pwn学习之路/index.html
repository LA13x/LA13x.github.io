<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="kernel-pwn基础知识学习"><meta name="keywords" content="pwn,kernel"><meta name="author" content="Alex"><meta name="copyright" content="Alex"><title>kernel-pwn基础知识学习 | Alex's blog~</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Alex's blog~" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#02-kernel%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">02. kernel简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFkernel"><span class="toc-number">1.1.</span> <span class="toc-text">什么是kernel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ring-Model"><span class="toc-number">1.2.</span> <span class="toc-text">Ring Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#model-change"><span class="toc-number">1.3.</span> <span class="toc-text">model change</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#user-space-to-kernel-space"><span class="toc-number">1.3.1.</span> <span class="toc-text">user space to kernel space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kernel-space-to-user-space"><span class="toc-number">1.3.2.</span> <span class="toc-text">kernel space to user space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Esyscall"><span class="toc-number">1.3.3.</span> <span class="toc-text">关于syscall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ioctl"><span class="toc-number">1.3.4.</span> <span class="toc-text">ioctl</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">内核态函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-cred-%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.5.</span> <span class="toc-text">struct cred - 进程权限结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.</span> <span class="toc-text">内核保护机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-LKMs%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">03. LKMs介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFLKMs"><span class="toc-number">2.1.</span> <span class="toc-text">什么是LKMs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">内核中的模块相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-operations-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.3.</span> <span class="toc-text">file_operations 结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">04. 环境配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-Kernel-Stack-Overflow"><span class="toc-number">4.</span> <span class="toc-text">05. Kernel Stack Overflow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A0%88%E5%B8%A7-Kernel-Stack-Layout"><span class="toc-number">4.1.</span> <span class="toc-text">内核栈帧(Kernel Stack Layout)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kernel%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB"><span class="toc-number">4.2.</span> <span class="toc-text">kernel栈溢出攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF"><span class="toc-number">4.3.</span> <span class="toc-text">Linux提权思路</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://pic4.zhimg.com/80/v2-5cb1e2bdc0644f9828029a94181f4542_1440w.jpg"></div><div class="author-info__name text-center">Alex</div><div class="author-info__description text-center">pwn</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">35</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://n0vice.top/">N0vice</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://snowywar.top/">魔法少女雪殇</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://l0ne1y.xyz/">L0ne1y</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://eeeeeeeeeeeeeeeea.cn/">eeeeeeeeeeeeeeeea</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Alex's blog~</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">kernel-pwn基础知识学习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-10</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>原文：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/201043">https://www.anquanke.com/post/id/201043</a></p>
<p>照着原文手打了一遍，印象加深get</p>
<h2 id="02-kernel简介"><a href="#02-kernel简介" class="headerlink" title="02. kernel简介"></a>02. kernel简介</h2><h3 id="什么是kernel"><a href="#什么是kernel" class="headerlink" title="什么是kernel"></a>什么是kernel</h3><p>kernel也是一个程序，用来管理软件发出的数据的IO要求，将这些要求转义为指令，交给CPU和计算机的其他组件处理，kernel是现代操作系统最基本的部分。</p>
<p><img src="https://img.lhyerror404.cn/error404/2020-03-13-Kernel_Layout.svg" alt=""></p>
<p>kernel最主要的功能有两点：</p>
<ol>
<li>控制并与硬件进行交互</li>
<li>提供application能运行的环境</li>
</ol>
<p>包括IO，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。</p>
<p>需要注意的是，kernel的crash通常会引起重启。</p>
<h3 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h3><p>intel CPU将CPU的特权级别分为4个级别：Ring 0，Ring 1，Ring 2，Ring 3.</p>
<p>Ring 0只给OS使用，Ring 3所有程序都可以使用，内层Ring 可以随便使用外层Ring的资源。</p>
<p>使用Ring Model是为了提升系统安全性，例如某个间谍软件作为一个在Ring 3运行的用户程序，在不通知用户的时候打开摄像头会被组成，因为访问硬件需要使用being驱动程序保留的Ring 1的方法。</p>
<p>大多数的现代操作系统只使用了Ring 0和Ring 3.</p>
<h3 id="model-change"><a href="#model-change" class="headerlink" title="model change"></a>model change</h3><h4 id="user-space-to-kernel-space"><a href="#user-space-to-kernel-space" class="headerlink" title="user space to kernel space"></a>user space to kernel space</h4><p>当发生系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换时，具体过程为：</p>
<ol>
<li><p>通过<code>swapgs</code>切换GS段寄存器，将GS寄存器的值和一个特定位置的值进行交换，目的是保存GS值，同时将该位置的值作为内核执行时的GS值使用。</p>
</li>
<li><p>将当前栈顶（用户空间栈顶）记录在CPU独占变量区域里，将CPU独占区域里记录的内核放入RSP/ESP</p>
</li>
<li><p>通过push保存各寄存器值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 *&#x2F;</span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line">&#x2F;* 保存栈值，并设置内核栈 *&#x2F;</span><br><span class="line">movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">&#x2F;* 通过push保存寄存器值，形成一个pt_regs结构 *&#x2F;</span><br><span class="line">&#x2F;* Construct struct pt_regs on stack *&#x2F;</span><br><span class="line">pushq  $__USER_DS                &#x2F;* pt_regs-&gt;ss *&#x2F;</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  &#x2F;* pt_regs-&gt;sp *&#x2F;</span><br><span class="line">pushq  %r11                      &#x2F;* pt_regs-&gt;flags *&#x2F;</span><br><span class="line">pushq  $__USER_CS                &#x2F;* pt_regs-&gt;cs *&#x2F;</span><br><span class="line">pushq  %rcx                      &#x2F;* pt_regs-&gt;ip *&#x2F;</span><br><span class="line">pushq  %rax                      &#x2F;* pt_regs-&gt;orig_ax *&#x2F;</span><br><span class="line">pushq  %rdi                      &#x2F;* pt_regs-&gt;di *&#x2F;</span><br><span class="line">pushq  %rsi                      &#x2F;* pt_regs-&gt;si *&#x2F;</span><br><span class="line">pushq  %rdx                      &#x2F;* pt_regs-&gt;dx *&#x2F;</span><br><span class="line">pushq  %rcx tuichu               &#x2F;* pt_regs-&gt;cx *&#x2F;</span><br><span class="line">pushq  $-ENOSYS                  &#x2F;* pt_regs-&gt;ax *&#x2F;</span><br><span class="line">pushq  %r8                       &#x2F;* pt_regs-&gt;r8 *&#x2F;</span><br><span class="line">pushq  %r9                       &#x2F;* pt_regs-&gt;r9 *&#x2F;</span><br><span class="line">pushq  %r10                      &#x2F;* pt_regs-&gt;r10 *&#x2F;</span><br><span class="line">pushq  %r11                      &#x2F;* pt_regs-&gt;r11 *&#x2F;</span><br><span class="line">sub $(6*8), %rsp                 &#x2F;* pt_regs-&gt;bp, bx, r12-15 not saved *&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过汇编指令判断是否为 <code>x32_abi</code>。</p>
</li>
<li><p>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</p>
</li>
</ol>
<h4 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h4><p>退出时，流程如下：</p>
<ol>
<li>通过swapgs恢复GS值</li>
<li>通过sysretq或者iretq恢复到用户控件继续执行。如果使用iretq还需要给出用户空间的一些信息（cs，eflags/rflags，esp/rsp等）</li>
</ol>
<h4 id="关于syscall"><a href="#关于syscall" class="headerlink" title="关于syscall"></a>关于syscall</h4><p>系统调用，指的是用户控件的程序向操作系统内核请求需要更高权限的服务，比如IO操作或者进程间通信。系统调用提供用户程序与操作系统之间的接口，部分库函数（如scanf，puts等IO相关的函数实际上是对系统调用的封装（read和write））</p>
<blockquote>
<p>在 <em>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</em> 和 <em>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</em> 分别可以查看 64 位和 32 位的系统调用号。</p>
</blockquote>
<h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><p>在man手册中，关于这个函数的说明如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ioctl - control device</span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> request, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       <span class="function">The <span class="title">ioctl</span><span class="params">()</span> system call manipulates the underlying device parameters of special</span></span><br><span class="line">       files.  In particular, many  operating  characteristics  of  character  special</span><br><span class="line">       files  (e.g., terminals) <span class="function">may be controlled with <span class="title">ioctl</span><span class="params">()</span> requests.  The argument</span></span><br><span class="line"><span class="function">       fd must be an open file descriptor.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">       The second argument is a device-dependent request code.  The third argument  is</span><br><span class="line">       an  untyped  pointer  to  memory.  It<span class="number">&#x27;</span><span class="function">s traditionally <span class="keyword">char</span> *<span class="title">argp</span> <span class="params">(from the days</span></span></span><br><span class="line">       before void * was valid C), and will be so named for this discussion.</span><br><span class="line"></span><br><span class="line">       <span class="function">An <span class="title">ioctl</span><span class="params">()</span> request has encoded in it whether the argument is an in parameter <span class="keyword">or</span></span></span><br><span class="line">       out  parameter, and the size of the argument argp in bytes.  Macros and defines</span><br><span class="line">       used in specifying an ioctl() request are located in the file &lt;sys/ioctl.h&gt;.</span><br></pre></td></tr></table></figure>
<p>可以看出ioctl也是一个系统调用，用于与设备通信。</p>
<p>第一个参数为打开设备返回的文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。</p>
<blockquote>
<p>使用 ioctl 进行通信的原因：</p>
<p>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址, 但是当访问非标准硬件设备这些系统调用显得不合适, 有时候用户模式可能需要直接访问设备。</p>
<p>比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。</p>
<p>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 Ioctl 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 Ioctl 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</p>
</blockquote>
<p>（妙啊）</p>
<h3 id="内核态函数调用"><a href="#内核态函数调用" class="headerlink" title="内核态函数调用"></a>内核态函数调用</h3><p>相比用户态函数，内核态的函数有了一些变化：</p>
<ol>
<li>printf变更为printk，值得注意的是printk不一定会把内容显示到终端上，<strong>但是一定在内核缓冲区里</strong>，可以通过<code>dmesg</code>查看效果</li>
<li>memcpy变更为copy_from_user/copy_to_user<ol>
<li>Copy_from_user实现了将用户空间的数据传送到内核空间</li>
<li>Copy_to_user实现了将内核空间的数据传送到用户空间</li>
</ol>
</li>
<li>malloc变更为kmalloc，内核态的内存分配函数，和malloc相似，但使用的是slab/slub分配器</li>
<li>free变更为kfree，同kmalloc</li>
</ol>
<p>同时，kernel负责管理进程，因此kernel也记录了进程的权限。kernel中有两个可以方便的改变权限的函数：</p>
<ol>
<li><code>int commit_creds(struct cred *new)</code></li>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code></li>
</ol>
<p>从函数名也可以看出，执行commit_creds(prepare_kernel_cred(0))即获得root权限，0表示以0号进程作为参考准备新的credentials</p>
<p>执行commit_creds(prepare_kernel_cred(0))也是最常用的提权手段，两个函数的地址都可以在/proc/kallsyms中查看（较老的内核版本中是/proc/ksyms）</p>
<p><img src="/Users/lemon/Library/Application Support/typora-user-images/image-20210811161724893.png" alt="image-20210811161724893" style="zoom:50%;" /></p>
<p>一般情况下，/proc/kallsyms的内容需要root权限才能查看，若以非root权限查看将显示为0地址（emm）</p>
<h3 id="struct-cred-进程权限结构体"><a href="#struct-cred-进程权限结构体" class="headerlink" title="struct cred - 进程权限结构体"></a>struct cred - 进程权限结构体</h3><p>内核使用cred结构体记录进程的权限，每个进程中都有一个cred结构，这个结构保存了该进程的权限等信息（uid，gid等），如果能修改某个进程的cred，那么也就修改了这个进程的权限。结构体源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    subscribers;           <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="keyword">void</span>        *put_addr;</span><br><span class="line">    <span class="keyword">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">kuid_t</span>      uid;                   <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      gid;                   <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      suid;                  <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      sgid;                  <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      euid;                  <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      egid;                  <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      fsuid;                 <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      fsgid;                 <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="keyword">unsigned</span>    securebits;            <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_inheritable;   <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_permitted;     <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_effective;     <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_bset;          <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_ambient;       <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   jit_keyring;       <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">    /* keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span>      <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span>       <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span>     <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>        *security;             <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>          <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span>    <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>     <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>               <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<h3 id="内核保护机制"><a href="#内核保护机制" class="headerlink" title="内核保护机制"></a>内核保护机制</h3><ol>
<li>smep: Supervisor Mode Execute Protection，当处理器处于ring 0模式，执行用户空间的代码会触发页错误（在arm中该保护称为PXN）。</li>
<li>smap: Supervisor Mode Access Protection，类似于smep，当处理器处于ring 0模式，访问用户空间的数据会发生页错误。</li>
<li>MMAP_MIN_ADDR: 控制着mmap能够映射的最低内存地址，防止用户非法分配并访问低地址数据。</li>
<li>KASLR: Kernel Address Space Layout Randomization，内核地址空间布局随机化，开启后，允许kernel image加载到VMALLOC区域的任何位置。</li>
</ol>
<p>Canary，DEP，PIE，RELRO等保护与用户态原理和作用相同。</p>
<h2 id="03-LKMs介绍"><a href="#03-LKMs介绍" class="headerlink" title="03. LKMs介绍"></a>03. LKMs介绍</h2><h3 id="什么是LKMs"><a href="#什么是LKMs" class="headerlink" title="什么是LKMs"></a>什么是LKMs</h3><p>LKMs (Loadable Kernel Modules)称为可加载核心模块(内核模块)， 其可以看作是运行在内核空间的可执行程序，包括：</p>
<ul>
<li>驱动程序 Device drivers<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>……</li>
</ul>
</li>
<li>内核扩展模块 modules</li>
</ul>
<p>LKMs的文件格式和用户态的可执行程序相同，Linux下为ELF，Windows下为exe/dll，mac下为MACH-O，因此可以使用IDA等工具来分析内核模块。</p>
<p>模块可以被单独编译，但是不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程不同。</p>
<p>模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。</p>
<blockquote>
<p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p>
</blockquote>
<p><strong>通常情况下，Kernel漏洞的发生也常见于加载的LKMs出现问题。</strong></p>
<h3 id="内核中的模块相关命令"><a href="#内核中的模块相关命令" class="headerlink" title="内核中的模块相关命令"></a>内核中的模块相关命令</h3><ol>
<li>insmod：将指定模块加载到内核中。</li>
<li>rmmod：从内核中卸载指定模块。</li>
<li>lsmod：列出已经加载的模块。</li>
<li>modprobe：添加或删除模块，modprobe在加载模块时会查找依赖关系。</li>
</ol>
<h3 id="file-operations-结构体"><a href="#file-operations-结构体" class="headerlink" title="file_operations 结构体"></a>file_operations 结构体</h3><p>用户进程在对设备文件进行诸如read/write操作的时候，<strong>系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是linux的设备驱动程序工作的基本原理。</strong></p>
<p>内核模块程序的结构中包括一些call back回调表，对应的函数存储在一个file_operations(fop)结构体中，这也是相当重要的结构体，结构体中实现了的回调函数就会静态初始化函数地址，而未实现的函数，值为NULL。</p>
<p>例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Events</th>
<th style="text-align:center">User functions</th>
<th style="text-align:center">Kernel functions</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Load</td>
<td style="text-align:center">insmod</td>
<td style="text-align:center">module_init()</td>
</tr>
<tr>
<td style="text-align:center">Open</td>
<td style="text-align:center">fopen</td>
<td style="text-align:center">file_operations: open</td>
</tr>
<tr>
<td style="text-align:center">Close</td>
<td style="text-align:center">fread</td>
<td style="text-align:center">file_operations: read</td>
</tr>
<tr>
<td style="text-align:center">Write</td>
<td style="text-align:center">fwrite</td>
<td style="text-align:center">file_operations: write</td>
</tr>
<tr>
<td style="text-align:center">Close</td>
<td style="text-align:center">fclose</td>
<td style="text-align:center">file_operations: release</td>
</tr>
<tr>
<td style="text-align:center">Remove</td>
<td style="text-align:center">rmmod</td>
<td style="text-align:center">module_exit()</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Hello world!n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Bye, cruel worldn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">module_fops</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    read: module_read,</span><br><span class="line">    write: module_write,</span><br><span class="line">    open: module_open,</span><br><span class="line">    release: module_release</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，module_init/module_exit是在载入/卸载这个驱动时自动运行；而fop结构体实现了如上四个callback，冒号右侧的函数名是由开发者自己起的，在驱动程序载入内核后，其他用户程序就可以借助文件方式像进行系统调用一样调用这些函数实现所需功能。</p>
<h2 id="04-环境配置"><a href="#04-环境配置" class="headerlink" title="04. 环境配置"></a>04. 环境配置</h2><p>对于kernel pwn来说，题目通常会给定以下文件：</p>
<blockquote>
<p>boot.sh：一个用于启动kernel的shell脚本，多用qemu，保护措施与qemu不同的启动参数有关</p>
<p>bzImage：kernel binary</p>
<p>rootfs.cpio：文件系统映像</p>
</blockquote>
<p>qemu的启动参数：</p>
<ul>
<li>-initrd rootfs.cpio，使用rootfs.cpio作为内核启动的文件系统</li>
<li>-kernel bzImage，使用bzImage作为kernel映像</li>
<li>-cpu kvm64,+smep，设置CPU的安全选项，这里开启了smep</li>
<li>-m 64M，设置虚拟RAM为64M，默认为128M</li>
</ul>
<h2 id="05-Kernel-Stack-Overflow"><a href="#05-Kernel-Stack-Overflow" class="headerlink" title="05. Kernel Stack Overflow"></a>05. Kernel Stack Overflow</h2><h3 id="内核栈帧-Kernel-Stack-Layout"><a href="#内核栈帧-Kernel-Stack-Layout" class="headerlink" title="内核栈帧(Kernel Stack Layout)"></a>内核栈帧(Kernel Stack Layout)</h3><p>x86上的Linux内核堆栈的大小为4096或8192字节，取决于发行版。</p>
<p>内核堆栈与thread_info结构共享4k/8k的总大小，该结构包含有关当前线程的一些元数据，如include/linux/sched.h中所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">thread_union</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread_info结构体在x86下有如下定义（arch/x86/include/asm/thread_info.h）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span> *<span class="title">exec_domain</span>;</span></span><br><span class="line">    __u32      flags;</span><br><span class="line">    __u32      status;</span><br><span class="line">    __u32      cpu;</span><br><span class="line">    <span class="keyword">int</span>          preempt_count;</span><br><span class="line">    <span class="keyword">mm_segment_t</span>  addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user     *sysenter_return;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  previous_esp;</span><br><span class="line">    __u8      supervisor_stack[<span class="number">0</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span>          uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内核堆栈在内存中呈现下所示的结构</p>
<p><img src="https://img.lhyerror404.cn/error404/2020-03-15-061423.png" alt=""></p>
<p>当内核函数需要超过4k/8k的堆栈空间或者使用了长调用链以至于超出可用堆栈空间的时候，会导致堆栈溢出的发生，并且如果thread_info结构或超出更低地址处的关键内存损坏，则会导致内核崩溃。但是，如果内存对齐并且存在实际可以控制写入堆栈及其以外的数据的情况，则可能存在可利用的条件。</p>
<h3 id="kernel栈溢出攻击"><a href="#kernel栈溢出攻击" class="headerlink" title="kernel栈溢出攻击"></a>kernel栈溢出攻击</h3><p>我们看一看栈溢出和thread_info结构的破坏是如何导致提权的发生的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">blah</span><span class="params">(<span class="keyword">int</span> __user *vals, <span class="keyword">int</span> __user count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> big_array[count];</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; ++count) &#123;</span><br><span class="line">    big_array[i] = vals[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码使用了可变长度的数组，其大小基于攻击者的count。c99允许使用可变长的数组，并且GCC支持可变长的数组。GCC将在运行的时候简单地计算必要的大小，并适当减少堆栈指针，以在堆栈上为数组分配空间。</p>
<p>我们如果提供一个极大的count，则堆栈可能向下扩展到thread_info的边界之外，从而允许攻击者随后将任意值写入该结构。</p>
<p>我们可以利用的target为thread_info结构中的一个成员：restart_block。该成员是每个线程的结构，用于跟踪信息和参数以供重新启动系统调用。如果在sigaction(2)中指定了SA_RESTART，则被信号中断的系统调用可以中止并返回EINTR，也可以自动自行重启。在include/linux/thread_info.h中，restart_block的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> (*fn)(struct restart_block *);</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/* For futex_wait and futex_wait_requeue_pi */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; futex;</span><br><span class="line">        <span class="comment">/* For nanosleep */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; nanosleep;</span><br><span class="line">        <span class="comment">/* For poll */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; poll;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有一个fn的函数指针，在kernel/signal.c中有如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE0(restart_syscall)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> *<span class="title">restart</span> =</span> &amp;current_thread_info()-&gt;restart_block;</span><br><span class="line">    <span class="keyword">return</span> restart-&gt;fn(restart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而restart_syscall在arch/x86/kernel/syscall_table_32.S中被定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">long</span> sys_restart_syscall <span class="comment">/* 0 - old &quot;setup()&quot; system call, used for restarting */</span></span><br></pre></td></tr></table></figure>
<p>实际上它的系统调用号为0，我们可以通过以下方式从用户态中调用其功能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">syscall(SYS_restart_syscall);</span><br></pre></td></tr></table></figure>
<p>这将使内核调用在restart_block结构中的函数指针。</p>
<p>如果我们可以破坏thread_info中的restart_block成员中的函数指针，则可以将其指向我们控制下的用户空间中的函数，通过调用sys_restart_syscall触发其执行，并提权。</p>
<h3 id="Linux提权思路"><a href="#Linux提权思路" class="headerlink" title="Linux提权思路"></a>Linux提权思路</h3><p>之前说过，执行commit_creds(prepare_kernel_cred(0))，可以使进程的权限提升为root，然后我们返回到用户模式，执行iret指令。</p>
<p>关于iret指令：</p>
<ul>
<li><p>当使用iret指令返回到相同保护级别的任务时，iret会从堆栈弹出代码段选择子及指令指针分别到CS与IP寄存器，并弹出标志寄存器内容到EFLAGS寄存器。</p>
</li>
<li><p>当使用iret指令返回到一个不同保护级别时，iret不仅会从堆栈弹出以上内容，还会弹出堆栈段选择子及堆栈指针分别到SS与SP寄存器。</p>
</li>
<li><p>栈上保存了trap frame，返回到用户模式的时候，恢复信息从以下的结构读取：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* eip;                <span class="comment">// instruction pointer +0</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cs;              <span class="comment">// code segment    +4</span></span><br><span class="line">    <span class="keyword">uint32_t</span> eflags;          <span class="comment">// CPU flags       +8</span></span><br><span class="line">    <span class="keyword">void</span>* esp;                <span class="comment">// stack pointer       +12</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ss;              <span class="comment">// stack segment   +16</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/08/10/kernal-pwn学习之路/">http://example.com/2021/08/10/kernal-pwn学习之路/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">Alex's blog~</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/kernel/">kernel</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/08/22/HIT-OSlab3/"><i class="fa fa-chevron-left">  </i><span>HIT-OSlab3</span></a></div><div class="next-post pull-right"><a href="/2021/08/05/BUUCTF%E7%AC%AC%E4%B8%89%E5%91%A8/"><span>BUUCTF第三周</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021.03.05 - 2021 By Alex</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>