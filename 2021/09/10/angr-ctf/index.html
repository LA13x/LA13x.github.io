<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="通过angr-ctf学习angr符号执行"><meta name="keywords" content="reverse,angr"><meta name="author" content="Alex"><meta name="copyright" content="Alex"><title>通过angr-ctf学习angr符号执行 | Alex's blog~</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Alex's blog~" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#00-angr-find"><span class="toc-number">1.</span> <span class="toc-text">00_angr_find</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01-angr-avoid"><span class="toc-number">2.</span> <span class="toc-text">01_angr_avoid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-angr-find-condition"><span class="toc-number">3.</span> <span class="toc-text">02_angr_find_condition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-angr-symbolic-registers"><span class="toc-number">4.</span> <span class="toc-text">03_angr_symbolic_registers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-angr-symbolic-stack"><span class="toc-number">5.</span> <span class="toc-text">04_angr_symbolic_stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-angr-symbolic-memory"><span class="toc-number">6.</span> <span class="toc-text">05_angr_symbolic_memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-angr-symbolic-dynamic-memory"><span class="toc-number">7.</span> <span class="toc-text">06_angr_symbolic_dynamic_memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-angr-symbolic-file"><span class="toc-number">8.</span> <span class="toc-text">07_angr_symbolic_file</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-angr-constraints"><span class="toc-number">9.</span> <span class="toc-text">08_angr_constraints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-angr-hooks"><span class="toc-number">10.</span> <span class="toc-text">09_angr_hooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-angr-simprocedures"><span class="toc-number">11.</span> <span class="toc-text">10_angr_simprocedures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-angr-sim-scanf"><span class="toc-number">12.</span> <span class="toc-text">11_angr_sim_scanf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-angr-veritesting"><span class="toc-number">13.</span> <span class="toc-text">12_angr_veritesting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-angr-static-binary"><span class="toc-number">14.</span> <span class="toc-text">13_angr_static_binary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-angr-shared-library"><span class="toc-number">15.</span> <span class="toc-text">14_angr_shared_library</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-angr-arbitrary-read"><span class="toc-number">16.</span> <span class="toc-text">15_angr_arbitrary_read</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://pic4.zhimg.com/80/v2-5cb1e2bdc0644f9828029a94181f4542_1440w.jpg"></div><div class="author-info__name text-center">Alex</div><div class="author-info__description text-center">pwn</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">47</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">42</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://n0vice.top/">N0vice</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://snowywar.top/">魔法少女雪殇</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://l0ne1y.xyz/">L0ne1y</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://eeeeeeeeeeeeeeeea.cn/">eeeeeeeeeeeeeeeea</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://giles-one.github.io/">cat03</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://ulrica66666.github.io/">ulrica66666</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Alex's blog~</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">通过angr-ctf学习angr符号执行</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-10</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>angr_ctf: <a target="_blank" rel="noopener" href="https://github.com/jakespringer/angr_ctf">https://github.com/jakespringer/angr_ctf</a><br>angr: <a target="_blank" rel="noopener" href="https://angr.io/">https://angr.io/</a></p>
<h2 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h2><p>Step</p>
<pre><code>1. Create an angr project.
 2. Create an entry to start execution.
 3. Create a simulation manager initialized with the starting state.
 4. Explore the binary.
 5. Find the input.
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  <span class="comment"># Create an Angr project.</span></span><br><span class="line">  <span class="comment"># If you want to be able to point to the binary from the command line, you can</span></span><br><span class="line">  <span class="comment"># use argv[1] as the parameter. Then, you can run the script from the command</span></span><br><span class="line">  <span class="comment"># line as follows:</span></span><br><span class="line">  <span class="comment"># python ./scaffold00.py [binary]</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]  <span class="comment"># m:string</span></span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Tell Angr where to start executing (should it start from the main()</span></span><br><span class="line">  <span class="comment"># function or somewhere else?) For now, use the entry_state function</span></span><br><span class="line">  <span class="comment"># to instruct Angr to start from the main() function.</span></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a simulation manager initialized with the starting state. It provides</span></span><br><span class="line">  <span class="comment"># a number of useful tools to search and execute the binary.</span></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Explore the binary to attempt to find the address that prints &quot;Good Job.&quot;</span></span><br><span class="line">  <span class="comment"># You will have to find the address you want to find and insert it here. </span></span><br><span class="line">  <span class="comment"># This function will keep executing until it either finds a solution or it </span></span><br><span class="line">  <span class="comment"># has explored every possible path through the executable.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  print_good_address = ???  # :integer (probably in hexadecimal)</span><br><span class="line">  simulation.explore(find=print_good_address)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Check that we have found a solution. The simulation.explore() method will</span></span><br><span class="line">  <span class="comment"># set simulation.found to a list of the states that it could find that reach</span></span><br><span class="line">  <span class="comment"># the instruction we asked it to search for. Remember, in Python, if a list</span></span><br><span class="line">  <span class="comment"># is empty, it will be evaluated as false, otherwise true.</span></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="comment"># The explore method stops after it finds a single state that arrives at the</span></span><br><span class="line">    <span class="comment"># target address.</span></span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print the string that Angr wrote to stdin to follow solution_state. This </span></span><br><span class="line">    <span class="comment"># is our solution.</span></span><br><span class="line">    <span class="built_in">print</span> solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># If Angr could not find a path that reaches print_good_address, throw an</span></span><br><span class="line">    <span class="comment"># error. Perhaps you mistyped the print_good_address?</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>The problem solving script:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line"></span><br><span class="line">  bin_path = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(bin_path)</span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  target_addr = <span class="number">0x08048678</span></span><br><span class="line">  simulation.explore(find=target_addr)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    print(simulation.found[<span class="number">0</span>].posix.dumps(sys.stdin.fileno()).decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Cound&#x27;t find it!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>
<h2 id="01-angr-avoid"><a href="#01-angr-avoid" class="headerlink" title="01_angr_avoid"></a>01_angr_avoid</h2><blockquote>
<p>Tick stash “stash” forward (up to “n” times or until “num_find” states are found), looking for condition “find”, avoiding condition “avoid”. Stores found states into “find_stash’ and avoided states into “avoid_stash”.</p>
<p>The “find” and “avoid” parameters may be any of:</p>
<ul>
<li>An address to find</li>
<li>A set or list of addresses to find</li>
<li>A function that takes a state and returns whether or not it matches.</li>
</ul>
<p>If an angr CFG is passed in as the “cfg” parameter and “find” is either a number or a list or a set, then any states which cannot possibly reach a success state without going through a failure state will be preemptively avoided.</p>
</blockquote>
<p>The “avoid” argument will not store the found state. This will help us save the time.</p>
<p>When I fixed the problem, IDA suggested that the function was too large.</p>
<p>When I solved this challenge and used ida to decompile, IDA showed that the function was too big.</p>
<p>Solution: change the config file.</p>
<p>MacOS: IDA_HOME/idabin/cfg/hexrays.cfg</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MAX_FUNCSIZE            = <span class="number">64</span>        <span class="comment">// Functions over 64K are not decompiled</span></span><br></pre></td></tr></table></figure>
<p>Change that to the following:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MAX_FUNCSIZE            = <span class="number">1024</span>        <span class="comment">// Functions over 1024K are not decompiled</span></span><br></pre></td></tr></table></figure>
<p>Although we fixed the configuration file, this function is too big and we will spend too much time decompiling it. So we can read the assembly code directly. </p>
<p><img src="https://i.loli.net/2021/09/10/eMunHzcQvViNpyt.png" alt="01-1.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  <span class="comment"># Explore the binary, but this time, instead of only looking for a state that</span></span><br><span class="line">  <span class="comment"># reaches the print_good_address, also find a state that does not reach </span></span><br><span class="line">  <span class="comment"># will_not_succeed_address. The binary is pretty large, to save you some time,</span></span><br><span class="line">  <span class="comment"># everything you will need to look at is near the beginning of the address </span></span><br><span class="line">  <span class="comment"># space.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  binary_path = argv[<span class="number">1</span>]</span><br><span class="line">  proj = angr.Project(binary_path, auto_load_libs=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">  initial_state = proj.factory.entry_state()</span><br><span class="line">  simulation = proj.factory.simulation_manager(initial_state)</span><br><span class="line"></span><br><span class="line">  target_address = <span class="number">0x80485E0</span></span><br><span class="line">  avoid_address = [<span class="number">0x080485A8</span>, <span class="number">0x080485F2</span>]</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=target_address, avoid=avoid_address)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    print(simulation.found[<span class="number">0</span>].posix.dumps(sys.stdin.fileno()).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Don&#x27;t find the target.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="02-angr-find-condition"><a href="#02-angr-find-condition" class="headerlink" title="02_angr_find_condition"></a>02_angr_find_condition</h2><blockquote>
<p>It is very useful to be able to search <em>for</em> a state that reaches a certain</p>
<p>instruction. However, <em>in</em> some cases, you may not know the address of the</p>
<p>specific instruction you want to reach (<em>or</em> perhaps there <em>is</em> no single</p>
<p>instruction goal.) In this challenge, you don’t know which instruction</p>
<p>grants you success. Instead, you just know that you want to find a state where</p>
<p>the binary prints “Good Job.”</p>
<p>Angr is powerful in that it allows you to search <em>for</em> a states that meets an</p>
<p>arbitrary condition that you specify <em>in</em> Python, using a predicate you define</p>
<p><em>as</em> a function that takes a state and returns True <em>if</em> you have found what you</p>
<p>are looking <em>for</em>, and False otherwise.</p>
</blockquote>
<p>Although we can find the address of the target instruction, in order to train the writing of angr, we use the recommended method of the script, which is to find the conditions we hope to achieve by writing functions.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  bin_path = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(bin_path)</span><br><span class="line">  </span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line">  simulation = project.factory.simulation_manager(initial_state)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="string">&quot;Good Job.&quot;</span> <span class="keyword">in</span> state.posix.dumps(sys.stdout.fileno()).decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="string">&quot;Try again.&quot;</span> <span class="keyword">in</span> state.posix.dumps(sys.stdout.fileno()).decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    print(simulation.found[<span class="number">0</span>].posix.dumps(sys.stdin.fileno()).decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Can&#x27;t find it.&quot;</span>)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>
<h2 id="03-angr-symbolic-registers"><a href="#03-angr-symbolic-registers" class="headerlink" title="03_angr_symbolic_registers"></a>03_angr_symbolic_registers</h2><p>Through this challenge we can learn how to control registers and manually set entries through angr.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Angr doesn&#x27;t currently support reading multiple things with scanf (Ex: </span></span><br><span class="line"><span class="comment"># scanf(&quot;%u %u).) You will have to tell the simulation engine to begin the</span></span><br><span class="line"><span class="comment"># program after scanf is called and manually inject the symbols into registers.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sometimes, you want to specify where the program should start. The variable</span></span><br><span class="line">  <span class="comment"># start_address will specify where the symbolic execution engine should begin.</span></span><br><span class="line">  <span class="comment"># Note that we are using blank_state, not entry_state.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  start_address = <span class="number">0x8048980</span>  <span class="comment"># :integer (probably hexadecimal)</span></span><br><span class="line">  initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a symbolic bitvector (the datatype Angr uses to inject symbolic</span></span><br><span class="line">  <span class="comment"># values into the binary.) The first parameter is just a name Angr uses</span></span><br><span class="line">  <span class="comment"># to reference it. </span></span><br><span class="line">  <span class="comment"># You will have to construct multiple bitvectors. Copy the two lines below</span></span><br><span class="line">  <span class="comment"># and change the variable names. To figure out how many (and of what size)</span></span><br><span class="line">  <span class="comment"># you need, dissassemble the binary and determine the format parameter passed</span></span><br><span class="line">  <span class="comment"># to scanf.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  password_size_in_bits = <span class="number">20</span> * <span class="number">8</span>  <span class="comment"># :integer</span></span><br><span class="line">  password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, password_size_in_bits)</span><br><span class="line">  password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, password_size_in_bits)</span><br><span class="line">  password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, password_size_in_bits)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Set a register to a symbolic value. This is one way to inject symbols into</span></span><br><span class="line">  <span class="comment"># the program.</span></span><br><span class="line">  <span class="comment"># initial_state.regs stores a number of convenient attributes that reference</span></span><br><span class="line">  <span class="comment"># registers by name. For example, to set eax to password0, use:</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># initial_state.regs.eax = password0</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># You will have to set multiple registers to distinct bitvectors. Copy and</span></span><br><span class="line">  <span class="comment"># paste the line below and change the register. To determine which registers</span></span><br><span class="line">  <span class="comment"># to inject which symbol, dissassemble the binary and look at the instructions</span></span><br><span class="line">  <span class="comment"># immediately following the call to scanf.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  initial_state.regs.eax = password0</span><br><span class="line">  initial_state.regs.ebx = password1</span><br><span class="line">  initial_state.regs.edx = password2</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="string">&quot;Good Job.&quot;</span> <span class="keyword">in</span> stdout_output.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="string">&quot;Good Job.&quot;</span> <span class="keyword">in</span> stdout_output.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Solve for the symbolic values. If there are multiple solutions, we only</span></span><br><span class="line">    <span class="comment"># care about one, so we can use eval, which returns any (but only one)</span></span><br><span class="line">    <span class="comment"># solution. Pass eval the bitvector you want to solve for.</span></span><br><span class="line">    <span class="comment"># (!)</span></span><br><span class="line">    solution0 = solution_state.solver.<span class="built_in">eval</span>(password0)</span><br><span class="line">    solution1 = solution_state.solver.<span class="built_in">eval</span>(password1)</span><br><span class="line">    solution2 = solution_state.solver.<span class="built_in">eval</span>(password2)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Aggregate and format the solutions you computed above, and then print</span></span><br><span class="line">    <span class="comment"># the full string. Pay attention to the order of the integers, and the</span></span><br><span class="line">    <span class="comment"># expected base (decimal, octal, hexadecimal, etc).</span></span><br><span class="line">    <span class="comment"># solution = solution0 + &quot; &quot; + solution1 + &quot; &quot; + solution2  # :string</span></span><br><span class="line">    print(<span class="string">&quot;&#123;:x&#125; &#123;:x&#125; &#123;:x&#125;&quot;</span>.<span class="built_in">format</span>(solution0, solution1, solution2))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>
<p>Keywords: simulation.found[0].solver.eval(), initial_state.regs.register</p>
<h2 id="04-angr-symbolic-stack"><a href="#04-angr-symbolic-stack" class="headerlink" title="04_angr_symbolic_stack"></a>04_angr_symbolic_stack</h2><p>This challenge exercises our ability to construct stacks using angr.</p>
<p>Tips:</p>
<blockquote>
<p> Since we are starting after scanf, we are skipping this stack construction step. To make up for this, we need to construct the stack ourselves. Let us start by initializing ebp in the exact same way the program does.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This challenge will be more challenging than the previous challenges that you</span></span><br><span class="line"><span class="comment"># have encountered thus far. Since the goal of this CTF is to teach symbolic</span></span><br><span class="line"><span class="comment"># execution and not how to construct stack frames, these comments will work you</span></span><br><span class="line"><span class="comment"># through understanding what is on the stack.</span></span><br><span class="line"><span class="comment">#   ! ! !</span></span><br><span class="line"><span class="comment"># IMPORTANT: Any addresses in this script aren&#x27;t necessarily right! Dissassemble</span></span><br><span class="line"><span class="comment">#            the binary yourself to determine the correct addresses!</span></span><br><span class="line"><span class="comment">#   ! ! !</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  start_address = <span class="number">0x08048697</span></span><br><span class="line">  initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  initial_state.regs.ebp = initial_state.regs.esp</span><br><span class="line">  print(initial_state.regs.ebp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">160</span>)</span><br><span class="line">  password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">160</span>)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  padding_length_in_bytes = <span class="number">8</span>   <span class="comment"># :integer</span></span><br><span class="line">  initial_state.regs.esp -= padding_length_in_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  initial_state.stack_push(password0)  <span class="comment"># :bitvector (claripy.BVS, claripy.BVV, claripy.BV)</span></span><br><span class="line">  initial_state.stack_push(password1)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&quot;Good&quot;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&quot;Try&quot;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution0 = solution_state.solver.<span class="built_in">eval</span>(password0)</span><br><span class="line">    solution1 = solution_state.solver.<span class="built_in">eval</span>(password1)</span><br><span class="line">    ...</span><br><span class="line">    print(solution0, solution1)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>padding_length_in_bytes = 8</code></p>
<p>Note that the value of padding in the above script is calculated by stack.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:08048679                 push    ebp</span><br><span class="line">.text:0804867A                 mov     ebp, esp</span><br><span class="line">.text:0804867C                 sub     esp, 18h</span><br></pre></td></tr></table></figure>
<p>In ida, the stack memory for this function is 0x18 bytes.</p>
<p>“v1” is located at the position of “ebp - 0x10” and the “v2” is located at the position of “ebp - 0xc”.  So when the address is indexed by ESP, the offset is 0x18-0x10, which is exactly the position of the first parameter.</p>
<p>keywords: initial_state.stack_push()</p>
<h2 id="05-angr-symbolic-memory"><a href="#05-angr-symbolic-memory" class="headerlink" title="05_angr_symbolic_memory"></a>05_angr_symbolic_memory</h2><blockquote>
<p>  Determine the address of the global variable to which scanf writes the user input. The function ‘initial_state.memory.store(address, value)’ will write ‘value’ (a bitvector) to ‘address’ (a memory location, <em>as</em> an integer.) The ‘address’ parameter can also be a bitvector (<em>and</em> can be symbolic!).</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  start_address = <span class="number">0x08048601</span></span><br><span class="line">  initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># The binary is calling scanf(&quot;%8s %8s %8s %8s&quot;).</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">160</span>)</span><br><span class="line">  password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">160</span>)</span><br><span class="line">  password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">160</span>)</span><br><span class="line">  password3 = claripy.BVS(<span class="string">&#x27;password3&#x27;</span>, <span class="number">160</span>)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  password0_address = <span class="number">0xA1BA1C0</span></span><br><span class="line">  password1_address = <span class="number">0xA1BA1C8</span></span><br><span class="line">  password2_address = <span class="number">0xA1BA1D0</span></span><br><span class="line">  password3_address = <span class="number">0xA1BA1D8</span></span><br><span class="line"></span><br><span class="line">  initial_state.memory.store(password0_address, password0)</span><br><span class="line">  initial_state.memory.store(password1_address, password1)</span><br><span class="line">  initial_state.memory.store(password2_address, password2)</span><br><span class="line">  initial_state.memory.store(password3_address, password3)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution0 = solution_state.solver.<span class="built_in">eval</span>(password0, cast_to=<span class="built_in">bytes</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    solution1 = solution_state.solver.<span class="built_in">eval</span>(password1, cast_to=<span class="built_in">bytes</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    solution2 = solution_state.solver.<span class="built_in">eval</span>(password2, cast_to=<span class="built_in">bytes</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    solution3 = solution_state.solver.<span class="built_in">eval</span>(password3, cast_to=<span class="built_in">bytes</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    print(solution0, solution1, solution2, solution3)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Keyword: initial_state.memory.store(address, value)</p>
<h2 id="06-angr-symbolic-dynamic-memory"><a href="#06-angr-symbolic-dynamic-memory" class="headerlink" title="06_angr_symbolic_dynamic_memory"></a>06_angr_symbolic_dynamic_memory</h2><blockquote>
<p>  Instead of telling the binary to write to the address of the memory  allocated with malloc, we can simply fake an address to any unused block of memory and overwrite the pointer to the data. This will point the pointer with the address of pointer_to_malloc_memory_address0 to fake_heap_address.<br>  Be aware, there is more than one pointer! Analyze the binary to determine global location of each pointer.<br>  Note: by default, Angr stores integers in memory with big-endianness. To specify to use the endianness of your architecture, use the parameter endness=project.arch.memory_endness. On x86, this is little-endian.</p>
</blockquote>
<p>The key to this challenge is that we skipped malloc at the address at the beginning, so we have to manually allocate a fake heap address for it.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  start_address = <span class="number">0x08048699</span></span><br><span class="line">  initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">  password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">  password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  fake_heap_address0 = <span class="number">0xABCC800</span></span><br><span class="line">  pointer_to_malloc_memory_address0 = <span class="number">0xABCC8A4</span></span><br><span class="line">  initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">  fake_heap_address1 = <span class="number">0xABCC7e0</span></span><br><span class="line">  pointer_to_malloc_memory_address1 = <span class="number">0xABCC8AC</span></span><br><span class="line">  initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Store our symbolic values at our fake_heap_address. Look at the binary to</span></span><br><span class="line">  <span class="comment"># determine the offsets from the fake_heap_address where scanf writes.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  initial_state.memory.store(fake_heap_address0, password0)</span><br><span class="line">  initial_state.memory.store(fake_heap_address1, password1)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution0 = solution_state.solver.<span class="built_in">eval</span>(password0,cast_to=<span class="built_in">bytes</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    solution1 = solution_state.solver.<span class="built_in">eval</span>(password1,cast_to=<span class="built_in">bytes</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    print(solution0, solution1)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Keyword: state.memory.store(address, value, endness=project.arch.memory_endness)</p>
<h2 id="07-angr-symbolic-file"><a href="#07-angr-symbolic-file" class="headerlink" title="07_angr_symbolic_file"></a>07_angr_symbolic_file</h2><blockquote>
<p>This challenge could, in theory, be solved in multiple ways. However, <em>for</em> the</p>
<p>sake of learning how to simulate an alternate filesystem, please solve this</p>
<p>challenge according to structure provided below. As a challenge, once you have</p>
<p>an initial solution, <em>try</em> solving this <em>in</em> an alternate way.</p>
<p>Problem description and general solution strategy:</p>
<p>The binary loads the password <em>from</em> a file using the fread function. If the</p>
<p>password is correct, it prints “Good Job.” In order to keep consistency <em>with</em></p>
<p>the other challenges, the input <em>from</em> the console is written to a file in the </p>
<p>ignore_me function. As the name suggests, ignore it, <em>as</em> it only exists to</p>
<p>maintain consistency <em>with</em> other challenges.</p>
<p>We want to:</p>
<p>\1. Determine the file <em>from</em> which fread reads.</p>
<p>\2. Use Angr to simulate a filesystem where that file is replaced <em>with</em> our own</p>
<p>   simulated file.</p>
<p>\3. Initialize the file <em>with</em> a symbolic value, which will be read <em>with</em> fread</p>
<p>   and propogated through the program.</p>
<p>\4. Solve <em>for</em> the symbolic input to determine the password.</p>
<p>Construct a bitvector <em>for</em> the password and then store it <em>in</em> the file’s</p>
<p>  backing memory. The store method works exactly the same <em>as</em> the store method</p>
<p>  you have already used. In fact, it’s the exact same method! That means that</p>
<p>  memory.store(address, bitvector) will write bitvector to the address we</p>
<p>  specify. In this memory, unlike our program’s memory, we want to write to</p>
<p>  the beginning, <em>as</em> the Linux file will stream data <em>from</em> the beginning of the</p>
<p>  file. For example, imagine a simple file, ‘hello.txt’:</p>
<p>  Hello world, my name is John.</p>
<p>  ^                       ^</p>
<p>  ^ address 0             ^ address 24 (count the number of characters)</p>
<p>  In order to represent this in memory, we would want to write the string to</p>
<p>  the beginning of the file:</p>
<p>  hello_txt_contents = claripy.BVV(‘Hello world, my name is John.’, 30*8)</p>
<p>  hello_txt_backing_memory.store(0, hello_txt_contents)</p>
<p>  Perhaps, then, we would want to replace John <em>with</em> a</p>
<p>  symbolic variable. We would call:</p>
<p>  name_bitvector = claripy.BVS(‘symbolic_name’, 4*8)</p>
<p>  hello_txt_backing_memory.store(24, name_bitvector)</p>
<p>  Then, after the program calls fopen(‘hello.txt’, ‘r’) and then</p>
<p>  fread(buffer, sizeof(char), 30, hello_txt_file), the buffer would contain</p>
<p>  the string <em>from</em> the file, <em>except</em> four symbolic bytes where the name would be</p>
<p>  stored.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  bin_path = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(bin_path)</span><br><span class="line"></span><br><span class="line">  initial_address = <span class="number">0x080488D6</span></span><br><span class="line">  initial_state = project.factory.blank_state(addr=initial_address)</span><br><span class="line"></span><br><span class="line">  password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">64</span> * <span class="number">8</span>)</span><br><span class="line">  </span><br><span class="line">  filename = <span class="string">&#x27;OJKSQYDP.txt&#x27;</span></span><br><span class="line">  simfile = angr.storage.SimFile(name=filename, content=password, size=<span class="number">64</span>)</span><br><span class="line">  initial_state.fs.insert(filename, simfile)</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simulation_manager(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">good</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bad</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> state.posix.dumps(sys.stdout.fileno())</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=good, avoid=bad)</span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    print(simulation.found[<span class="number">0</span>].solver.<span class="built_in">eval</span>(password, cast_to=<span class="built_in">bytes</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>
<p>Keyword: angr.storage.SimFile(name=filename, content=symbolic_vector, size=file_size), initial_state.fs.insert(filename, simfile)</p>
<h2 id="08-angr-constraints"><a href="#08-angr-constraints" class="headerlink" title="08_angr_constraints"></a>08_angr_constraints</h2><blockquote>
<p>The binary asks <em>for</em> a 16 character password to which is applies a complex function and then compares <em>with</em> a reference string <em>with</em> the function check<em>equals</em>[reference string]. (Decompile the binary and take a look at it!)</p>
<p>The source code <em>for</em> this function is provided here. However, the reference string <em>in</em> your version will be different than AABBCCDDEEFFGGHH.</p>
<p>The function checks if *to_check == “AABBCCDDEEFFGGHH”. Verify this yourself. While you, as a human, can easily determine that this function is equivalent to simply comparing the strings, the computer cannot. Instead the computer  would need to branch every time the if statement in the loop was called (16  times), resulting in 2^16 = 65,536 branches, which will take too long of a  time to evaluate for our needs.</p>
<p>We do not know how the complex_function works, but we want to find an input that, when modified by complex_function, will produce the string: AABBCCDDEEFFGGHH.</p>
<p>In this puzzle, your goal will be to stop the program before this function is called and manually constrain the to_check variable to be equal to the password you identify by decompiling the binary. Since, you, as a human, know that if the strings are equal, the program will print “Good Job.”, you can be assured that if the program can solve for an input that makes them equal, the input will be the correct password.</p>
</blockquote>
<p>Source code:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REFERENCE_PASSWORD = <span class="meta-string">&quot;AABBCCDDEEFFGGHH&quot;</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_equals_AABBCCDDEEFFGGHH</span><span class="params">(<span class="keyword">char</span>* to_check, <span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> num_correct = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to_check[i] == REFERENCE_PASSWORD[i]) &#123;</span><br><span class="line">      num_correct += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num_correct == length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* input = user_input();</span><br><span class="line"><span class="keyword">char</span>* encrypted_input = complex_function(input);</span><br><span class="line"><span class="keyword">if</span> (check_equals_AABBCCDDEEFFGGHH(encrypted_input, <span class="number">16</span>)) &#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This challenge is quite practical. I have seen many ctf challenges using this writing method: compare the input string with the target string character by character. This is easy for us humans, but not for computers. When we use symbols to execute, this challenge has 16 characters, so we have to compare 2 to the 16th power, which is obviously unbearable. In order to solve this problem, we need to manually specify constraints. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  bin_path = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(bin_path)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line">  simulation_manager = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  target_address = <span class="number">0x0804866E</span></span><br><span class="line">  simulation_manager.explore(find=target_address)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation_manager.found:</span><br><span class="line">    solution_state = simulation_manager.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  constrained_parameter_address = <span class="number">0x0804A050</span></span><br><span class="line">  constrained_parameter_size = <span class="number">16</span></span><br><span class="line">  constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_address, constrained_parameter_size)</span><br><span class="line"></span><br><span class="line">  solution_state.add_constraints(constrained_parameter_bitvector == <span class="string">&#x27;AUPDNNPROEZRJWKB&#x27;</span>)</span><br><span class="line">  print(solution_state.posix.dumps(sys.stdin.fileno()).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>
<p>Keyword: solution_state.memory.load(target_address, size), solution_state.add_constraints(input == target)</p>
<h2 id="09-angr-hooks"><a href="#09-angr-hooks" class="headerlink" title="09_angr_hooks"></a>09_angr_hooks</h2><blockquote>
<p> This level performs the following computations:</p>
<ol>
<li>Get 16 bytes of user input and encrypt it.</li>
<li>Save the result of check_equals_AABBCCDDEEFFGGHH (or similar)</li>
<li>Get another 16 bytes from the user and encrypt it.</li>
<li><p>Check that it’s equal to a predefined password.</p>
<p>The ONLY part of this program that we have to worry about is #2.We will be replacing the call to check<em>equals</em> with our own version, using a hook, since check<em>equals</em> will run too slowly otherwise.</p>
</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  bin_path = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(bin_path)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line">  </span><br><span class="line">  instrction_step_address = <span class="number">0x80486B3</span></span><br><span class="line">  jump_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @project.hook(<span class="params">instrction_step_address, length=jump_size</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">skip_check_equals</span>(<span class="params">state</span>):</span></span><br><span class="line">    user_input_string = state.memory.load(<span class="number">0x0804A054</span>, <span class="number">16</span>)</span><br><span class="line">    state.regs.eax = claripy.If(</span><br><span class="line">      user_input_string == <span class="string">&#x27;XYMKBKUHNIQYNQXE&#x27;</span>,</span><br><span class="line">      claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),</span><br><span class="line">      claripy.BVV(<span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simulation_manager(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">good</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bad</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> state.posix.dumps(sys.stdout.fileno())</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=good, avoid=bad)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    print(simulation.found[<span class="number">0</span>].posix.dumps(sys.stdin.fileno()).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;cannot find it!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Detailed explanation of hook: <a target="_blank" rel="noopener" href="https://docs.angr.io/extending-angr/simprocedures#user-hooks">https://docs.angr.io/extending-angr/simprocedures#user-hooks</a></p>
<p>Keyword: @project.hook(address, length) func(state): …</p>
<h2 id="10-angr-simprocedures"><a href="#10-angr-simprocedures" class="headerlink" title="10_angr_simprocedures"></a>10_angr_simprocedures</h2><blockquote>
<p>You may be thinking:<br>  Why can’t I just use hooks? The function is called many times, but if I hook the address of the function itself (rather than the addresses where it is  called), I can replace its behavior everywhere. Furthermore, I can get the  parameters by reading them off the stack (with memory.load(regs.esp + xx)), and return a value by simply setting eax! Since I know the length of the function in bytes, I can return from the hook just before the ‘ret’  instruction is called, which will allow the program to jump back to where it  was before it called my hook.<br>If you thought that, then congratulations! You have just invented the idea of SimProcedures! Instead of doing all of that by hand, you can let the already-implemented SimProcedures do the boring work for you so that you can focus on writing a replacement function in a Pythonic way.<br>As a bonus, SimProcedures allow you to specify custom calling conventions, but unfortunately it is not covered in this CTF.</p>
<pre><code>A SimProcedure replaces a function in the binary with a simulated one   written in Python. Other than it being written in Python, the function    acts largely the same as any function written in C. Any parameter after  &#39;self&#39; will be treated as a parameter to the function you are replacing.
The parameters will be bitvectors. Additionally, the Python can return in    the ususal Pythonic way. Angr will treat this in the same way it would    treat a native function in the binary returning. An example:

int add_if_positive(int a, int b) &#123;
  if (a &gt;= 0 &amp;&amp; b &gt;= 0) return a + b;
  else return 0;
&#125;

could be simulated with...

class ReplacementAddIfPositive(angr.SimProcedure):
  def run(self, a, b):
    if a &gt;= 0 and b &gt;=0:
      return a + b
    else:
      return 0

Finish the parameters to the check_equals_ function. Reminder:   int check_equals_AABBCCDDEEFFGGHH(char* to_check, int length) &#123; ...
(!)
</code></pre></blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementCheckEquals</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, to_check, length</span>):</span></span><br><span class="line">      <span class="comment"># We can almost copy and paste the solution from the previous challenge.</span></span><br><span class="line">      <span class="comment"># Hint: Don&#x27;t look up the address! It&#x27;s passed as a parameter.</span></span><br><span class="line">      <span class="comment"># (!)</span></span><br><span class="line">      user_input_buffer_address = to_check</span><br><span class="line">      user_input_buffer_length = length</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Note the use of self.state to find the state of the system in a SimProcedure.</span></span><br><span class="line">      user_input_string = self.state.memory.load(</span><br><span class="line">        user_input_buffer_address,</span><br><span class="line">        user_input_buffer_length</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      check_against_string = <span class="string">&quot;ORSDDWXHZURJRBDH&quot;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># Finally, instead of setting eax, we can use a Pythonic return statement</span></span><br><span class="line">      <span class="comment"># to return the output of this function. </span></span><br><span class="line">      <span class="comment"># Hint: Look at the previous solution.</span></span><br><span class="line">      <span class="keyword">return</span> claripy.If(user_input_string ==  check_against_string, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Hook the check_equals symbol. Angr automatically looks up the address </span></span><br><span class="line">  <span class="comment"># associated with the symbol. Alternatively, you can use &#x27;hook&#x27; instead</span></span><br><span class="line">  <span class="comment"># of &#x27;hook_symbol&#x27; and specify the address of the function. To find the </span></span><br><span class="line">  <span class="comment"># correct symbol, disassemble the binary.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  check_equals_symbol = <span class="string">&quot;check_equals_ORSDDWXHZURJRBDH&quot;</span> <span class="comment"># :string</span></span><br><span class="line">  project.hook_symbol(check_equals_symbol, ReplacementCheckEquals())</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="11-angr-sim-scanf"><a href="#11-angr-sim-scanf" class="headerlink" title="11_angr_sim_scanf"></a>11_angr_sim_scanf</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This time, the solution involves simply replacing scanf with our own version,</span></span><br><span class="line"><span class="comment"># since Angr does not support requesting multiple parameters with scanf.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">    <span class="comment"># Finish the parameters to the scanf function. Hint: &#x27;scanf(&quot;%u %u&quot;, ...)&#x27;.</span></span><br><span class="line">    <span class="comment"># (!)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, scanf0_address, scanf1_address</span>):</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment"># The scanf function writes user input to the buffers to which the parameters point.</span></span><br><span class="line">      self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(scanf1_address, scanf1, endness=project.arch.memory_endness)</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Now, we want to &#x27;set aside&#x27; references to our symbolic values in the</span></span><br><span class="line">      <span class="comment"># globals plugin included by default with a state. You will need to</span></span><br><span class="line">      <span class="comment"># store multiple bitvectors. You can either use a list, tuple, or multiple</span></span><br><span class="line">      <span class="comment"># keys to reference the different bitvectors.</span></span><br><span class="line">      <span class="comment"># (!)</span></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0</span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&quot;__isoc99_scanf&quot;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&quot;Good&quot;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&quot;Try&quot;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Grab whatever you set aside in the globals dict.</span></span><br><span class="line">    stored_solutions0 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>]</span><br><span class="line">    stored_solutions1 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    print(solution_state.solver.<span class="built_in">eval</span>(stored_solutions0), solution_state.solver.<span class="built_in">eval</span>(stored_solutions1))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>
<h2 id="12-angr-veritesting"><a href="#12-angr-veritesting" class="headerlink" title="12_angr_veritesting"></a>12_angr_veritesting</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># When you construct a simulation manager, you will want to enable Veritesting:</span></span><br><span class="line"><span class="comment"># project.factory.simgr(initial_state, veritesting=True)</span></span><br><span class="line"><span class="comment"># Hint: use one of the first few levels&#x27; solutions as a reference.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    bin_path = argv[<span class="number">1</span>]</span><br><span class="line">    project = angr.Project(bin_path)</span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state, veritesting=<span class="literal">True</span>)</span><br><span class="line">    simulation.explore(find=<span class="number">0x804867C</span>)</span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        print(simulation.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>
<h2 id="13-angr-static-binary"><a href="#13-angr-static-binary" class="headerlink" title="13_angr_static_binary"></a>13_angr_static_binary</h2><blockquote>
<p>Additionally, note that, when the binary is executed, the main function is not</p>
<p>the first piece of code called. In the _start function, __libc_start_main is </p>
<p>called to start your program. The initialization that occurs in this function</p>
<p>can take a long time <em>with</em> Angr, so you should replace it <em>with</em> a SimProcedure.</p>
<p>angr.SIM_PROCEDURES[‘glibc’][‘__libc_start_main’]</p>
<p>Note ‘glibc’ instead of ‘libc’.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This challenge is the exact same as the first challenge, except that it was</span></span><br><span class="line"><span class="comment"># compiled as a static binary. Normally, Angr automatically replaces standard</span></span><br><span class="line"><span class="comment"># library functions with SimProcedures that work much more quickly.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Here are a few SimProcedures Angr has already written for you. They implement</span></span><br><span class="line"><span class="comment"># standard library functions. You will not need all of them:</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;malloc&#x27;]</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;fopen&#x27;]</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;fclose&#x27;]</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;fwrite&#x27;]</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;getchar&#x27;]</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;strncmp&#x27;]</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;strcmp&#x27;]</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;scanf&#x27;]</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;printf&#x27;]</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;puts&#x27;]</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;exit&#x27;]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># As a reminder, you can hook functions with something similar to: </span></span><br><span class="line"><span class="comment"># project.hook(malloc_address, angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;malloc&#x27;])</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># There are many more, see:</span></span><br><span class="line"><span class="comment"># https://github.com/angr/angr/tree/master/angr/procedures/libc</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Additionally, note that, when the binary is executed, the main function is not</span></span><br><span class="line"><span class="comment"># the first piece of code called. In the _start function, __libc_start_main is </span></span><br><span class="line"><span class="comment"># called to start your program. The initialization that occurs in this function</span></span><br><span class="line"><span class="comment"># can take a long time with Angr, so you should replace it with a SimProcedure.</span></span><br><span class="line"><span class="comment"># angr.SIM_PROCEDURES[&#x27;glibc&#x27;][&#x27;__libc_start_main&#x27;]</span></span><br><span class="line"><span class="comment"># Note &#x27;glibc&#x27; instead of &#x27;libc&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    bin_path = argv[<span class="number">1</span>]</span><br><span class="line">    project = angr.Project(bin_path)</span><br><span class="line"></span><br><span class="line">    project.hook(<span class="number">0x8048D10</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line">    project.hook(<span class="number">0x804ED40</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]())</span><br><span class="line">    project.hook(<span class="number">0x0804ED80</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">    project.hook(<span class="number">0x805B450</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strcmp&#x27;</span>]())</span><br><span class="line">    project.hook(<span class="number">0x804F350</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">good</span>(<span class="params">state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    simulation.explore(find=good)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        print(simulation.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="14-angr-shared-library"><a href="#14-angr-shared-library" class="headerlink" title="14_angr_shared_library"></a>14_angr_shared_library</h2><blockquote>
<p>The shared library has the function validate, which takes a string and returns either true (1) or false (0). The binary calls this function. If it returns true, the program prints “Good Job.” otherwise, it prints “Try again.”</p>
<p>Note: When you run this script, make sure you run it on lib14_angr_shared_library.so, not the executable. This level is intended to teach how to analyse binary formats that are not typical executables.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The shared library has the function validate, which takes a string and returns</span></span><br><span class="line"><span class="comment"># either true (1) or false (0). The binary calls this function. If it returns</span></span><br><span class="line"><span class="comment"># true, the program prints &quot;Good Job.&quot; otherwise, it prints &quot;Try again.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note: When you run this script, make sure you run it on </span></span><br><span class="line"><span class="comment"># lib14_angr_shared_library.so, not the executable. This level is intended to </span></span><br><span class="line"><span class="comment"># teach how to analyse binary formats that are not typical executables.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># The shared library is compiled with position-independent code. You will need</span></span><br><span class="line">  <span class="comment"># to specify the base address. All addresses in the shared library will be</span></span><br><span class="line">  <span class="comment"># base + offset, where offset is their address in the file.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  base = <span class="number">0x4000000</span></span><br><span class="line">  project = angr.Project(path_to_binary, load_options=&#123; </span><br><span class="line">    <span class="string">&#x27;main_opts&#x27;</span> : &#123; </span><br><span class="line">      <span class="string">&#x27;custom_base_addr&#x27;</span> : base </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Initialize any symbolic values here; you will need at least one to pass to</span></span><br><span class="line">  <span class="comment"># the validate function.</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Begin the state at the beginning of the validate function, as if it was</span></span><br><span class="line">  <span class="comment"># called by the program. Determine the parameters needed to call validate and</span></span><br><span class="line">  <span class="comment"># replace &#x27;parameters...&#x27; with bitvectors holding the values you wish to pass.</span></span><br><span class="line">  <span class="comment"># Recall that &#x27;claripy.BVV(value, size_in_bits)&#x27; constructs a bitvector </span></span><br><span class="line">  <span class="comment"># initialized to a single value.</span></span><br><span class="line">  <span class="comment"># Remember to add the base value you specified at the beginning to the</span></span><br><span class="line">  <span class="comment"># function address!</span></span><br><span class="line">  <span class="comment"># Hint: int validate(char* buffer, int length) &#123; ...</span></span><br><span class="line">  <span class="comment"># Another hint: the password is 8 bytes long.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  validate_function_address = <span class="number">0x6d7</span></span><br><span class="line">  buffer_pointer = claripy.BVV(<span class="number">0x3000000</span>, <span class="number">32</span>)</span><br><span class="line">  initial_state = project.factory.call_state(validate_function_address, buffer_pointer, claripy.BVV(<span class="number">8</span>, <span class="number">32</span>))</span><br><span class="line">  password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">  initial_state.memory.store(buffer_pointer, password)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># You will need to add code to inject a symbolic value into the program at the</span></span><br><span class="line">  <span class="comment"># end of the function that constrains eax to equal true (value of 1) just</span></span><br><span class="line">  <span class="comment"># before the function returns. There are multiple ways to do this:</span></span><br><span class="line">  <span class="comment"># 1. Use a hook.</span></span><br><span class="line">  <span class="comment"># 2. Search for the address just before the function returns and then</span></span><br><span class="line">  <span class="comment">#    constrain eax (this may require putting code elsewhere)</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  success_address =  base + <span class="number">0x783</span></span><br><span class="line">  simulation.explore(find=success_address)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Determine where the program places the return value, and constrain it so</span></span><br><span class="line">    <span class="comment"># that it is true. Then, solve for the solution and print it.</span></span><br><span class="line">    <span class="comment"># (!)</span></span><br><span class="line">    pirnt(solution_state.solver.<span class="built_in">eval</span>(password, cast_to=<span class="built_in">bytes</span>))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>
<h2 id="15-angr-arbitrary-read"><a href="#15-angr-arbitrary-read" class="headerlink" title="15_angr_arbitrary_read"></a>15_angr_arbitrary_read</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># You can either use a blank state or an entry state; just make sure to start</span></span><br><span class="line">  <span class="comment"># at the beginning of the program.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Again, scanf needs to be replaced.</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">    <span class="comment"># Hint: scanf(&quot;%u %20s&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, param0, param1</span>):</span></span><br><span class="line">      <span class="comment"># %u</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># %20s</span></span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">20</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># The bitvector.chop(bits=n) function splits the bitvector into a Python</span></span><br><span class="line">      <span class="comment"># list containing the bitvector in segments of n bits each. In this case,</span></span><br><span class="line">      <span class="comment"># we are splitting them into segments of 8 bits (one byte.)</span></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">        <span class="comment"># Ensure that each character in the string is printable. An interesting</span></span><br><span class="line">        <span class="comment"># experiment, once you have a working solution, would be to run the code</span></span><br><span class="line">        <span class="comment"># without constraining the characters to the printable range of ASCII.</span></span><br><span class="line">        <span class="comment"># Even though the solution will technically work without this, it&#x27;s more</span></span><br><span class="line">        <span class="comment"># difficult to enter in a solution that contains character you can&#x27;t</span></span><br><span class="line">        <span class="comment"># copy, paste, or type into your terminal or the web form that checks </span></span><br><span class="line">        <span class="comment"># your solution.</span></span><br><span class="line">        <span class="comment"># (!)</span></span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;A&#x27;</span>, char &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Warning: Endianness only applies to integers. If you store a string in</span></span><br><span class="line">      <span class="comment"># memory and treat it as a little-endian integer, it will be backwards.</span></span><br><span class="line">      scanf0_address = param0</span><br><span class="line">      self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      scanf1_address = param1</span><br><span class="line">      self.state.memory.store(scanf1_address, scanf1)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solutions&#x27;</span>] = (scanf0, scanf1)</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span>  <span class="comment"># :string</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">  <span class="comment"># We will call this whenever puts is called. The goal of this function is to</span></span><br><span class="line">  <span class="comment"># determine if the pointer passed to puts is controllable by the user, such</span></span><br><span class="line">  <span class="comment"># that we can rewrite it to point to the string &quot;Good Job.&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_puts</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="comment"># Treat the implementation of this function as if puts was just called.</span></span><br><span class="line">    <span class="comment"># The stack, registers, memory, etc should be set up as if the x86 call</span></span><br><span class="line">    <span class="comment"># instruction was just invoked (but, of course, the function hasn&#x27;t copied</span></span><br><span class="line">    <span class="comment"># the buffers yet.)</span></span><br><span class="line">    <span class="comment"># The stack will look as follows:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># esp + 7 -&gt; /----------------\</span></span><br><span class="line">    <span class="comment"># esp + 6 -&gt; |      puts      |</span></span><br><span class="line">    <span class="comment"># esp + 5 -&gt; |    parameter   |</span></span><br><span class="line">    <span class="comment"># esp + 4 -&gt; \----------------/</span></span><br><span class="line">    <span class="comment"># esp + 3 -&gt; /----------------\</span></span><br><span class="line">    <span class="comment"># esp + 2 -&gt; |     return     |</span></span><br><span class="line">    <span class="comment"># esp + 1 -&gt; |     address    |</span></span><br><span class="line">    <span class="comment">#     esp -&gt; \----------------/</span></span><br><span class="line">    <span class="comment"># (!)</span></span><br><span class="line">    puts_parameter = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The following function takes a bitvector as a parameter and checks if it</span></span><br><span class="line">    <span class="comment"># can take on more than one value. While this does not necessary tell us we</span></span><br><span class="line">    <span class="comment"># have found an exploitable path, it is a strong indication that the </span></span><br><span class="line">    <span class="comment"># bitvector we checked may be controllable by the user.</span></span><br><span class="line">    <span class="comment"># Use it to determine if the pointer passed to puts is symbolic.</span></span><br><span class="line">    <span class="comment"># (!)</span></span><br><span class="line">    <span class="keyword">if</span> state.se.symbolic(puts_parameter):</span><br><span class="line">      <span class="comment"># Determine the location of the &quot;Good Job.\n&quot; string. We want to print it</span></span><br><span class="line">      <span class="comment"># out, and we will do so by attempting to constrain the puts parameter to</span></span><br><span class="line">      <span class="comment"># equal it. (Hint: look at .rodata).</span></span><br><span class="line">      <span class="comment"># (!)</span></span><br><span class="line">      good_job_string_address = <span class="number">0x594e4257</span> <span class="comment"># :integer, probably hexadecimal</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Create an expression that will test if puts_parameter equals</span></span><br><span class="line">      <span class="comment"># good_job_string_address. If we add this as a constraint to our solver,</span></span><br><span class="line">      <span class="comment"># it will try and find an input to make this expression true.</span></span><br><span class="line">      <span class="comment"># (!)</span></span><br><span class="line">      is_vulnerable_expression = puts_parameter == good_job_string_address <span class="comment"># :boolean bitvector expression</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Have Angr evaluate the state to determine if all the constraints can</span></span><br><span class="line">      <span class="comment"># be met, including the one we specified above. If it can be satisfied,</span></span><br><span class="line">      <span class="comment"># we have found our exploit!</span></span><br><span class="line">      </span><br><span class="line">      copied_state = state.copy()</span><br><span class="line"></span><br><span class="line">      copied_state.add_constraints(is_vulnerable_expression)</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">if</span> copied_state.satisfiable():</span><br><span class="line">        <span class="comment"># Before we return, let&#x27;s add the constraint to the solver for real,</span></span><br><span class="line">        <span class="comment"># instead of just querying whether the constraint _could_ be added.</span></span><br><span class="line">        state.add_constraints(is_vulnerable_expression)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># not path.state.se.symbolic(???)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="comment"># We are looking for puts. Check that the address is at the (very) beginning</span></span><br><span class="line">    <span class="comment"># of the puts function. Warning: while, in theory, you could look for</span></span><br><span class="line">    <span class="comment"># any address in puts, if you execute any instruction that adjusts the stack</span></span><br><span class="line">    <span class="comment"># pointer, the stack diagram above will be incorrect. Therefore, it is</span></span><br><span class="line">    <span class="comment"># recommended that you check for the very beginning of puts.</span></span><br><span class="line">    <span class="comment"># (!)</span></span><br><span class="line">    puts_address = <span class="number">0x8048370</span></span><br><span class="line">    <span class="keyword">if</span> state.addr == puts_address:</span><br><span class="line">      <span class="comment"># Return True if we determine this call to puts is exploitable.</span></span><br><span class="line">      <span class="keyword">return</span> check_puts(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># We have not yet found a call to puts; we should continue!</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Determine the situation in which you should avoid. Optionally, you can</span></span><br><span class="line">  <span class="comment"># remove the avoid parameter, although it may cause the program to run more</span></span><br><span class="line">  <span class="comment"># slowly.</span></span><br><span class="line">  <span class="comment"># (!)</span></span><br><span class="line">  simulation.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    (scanf0, scanf1) = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solutions&#x27;</span>]</span><br><span class="line">    solution = <span class="built_in">str</span>(solution_state.se.<span class="built_in">eval</span>(scanf0)) + <span class="string">&#x27; &#x27;</span> + solution_state.se.<span class="built_in">eval</span>(scanf1,cast_to=<span class="built_in">str</span>)</span><br><span class="line">    <span class="built_in">print</span> solution</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>
<p>(Not end…)</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/10/angr-ctf/">http://example.com/2021/09/10/angr-ctf/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">Alex's blog~</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/reverse/">reverse</a><a class="post-meta__tags" href="/tags/angr/">angr</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/"><i class="fa fa-chevron-left">  </i><span>长城杯wp</span></a></div><div class="next-post pull-right"><a href="/2021/08/31/Real-World-Cisco-RV110W/"><span>强网杯2020决赛 Cisco RV110W路由器复现</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021.03.05 - 2023 By Alex</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>