<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="算法练习"><meta name="keywords" content="算法"><meta name="author" content="Alex"><meta name="copyright" content="Alex"><title>算法练习 | Alex's blog~</title><meta name="robots" content="noindex"><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Alex's blog~" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode-1%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.</span> <span class="toc-text">Leetcode-1：两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.</span> <span class="toc-text">方法一：暴力循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.</span> <span class="toc-text">方法二：哈希表存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode-21%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">Leetcode-21：合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.1.</span> <span class="toc-text">方法一：工作节点连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%92%E5%BD%92"><span class="toc-number">2.2.</span> <span class="toc-text">方法二：递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode-70%EF%BC%9A%E7%88%AC%E6%A5%BC%E6%A2%AF-%E9%80%92%E5%BD%92"><span class="toc-number">3.</span> <span class="toc-text">Leetcode-70：爬楼梯-递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92"><span class="toc-number">3.1.</span> <span class="toc-text">方法一：记忆化递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">方法二：双指针解法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode-83%EF%BC%9A%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">4.</span> <span class="toc-text">Leetcode-83：删除排序链表中的重复元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A%E5%89%8D%E5%90%8E%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">4.1.</span> <span class="toc-text">方法：前后双指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode-88%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">Leetcode-88：合并两个有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84%E5%86%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.</span> <span class="toc-text">方法一：合并数组再排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">5.2.</span> <span class="toc-text">方法二：双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E9%80%86%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">5.3.</span> <span class="toc-text">方法三：逆向双指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode-141%EF%BC%9A%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">6.</span> <span class="toc-text">Leetcode-141：环形链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">6.1.</span> <span class="toc-text">方法一：哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9AFloyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">方法二：Floyd判圈算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode-283%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">7.</span> <span class="toc-text">Leetcode-283：移动零</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%E4%BA%A4%E6%8D%A2"><span class="toc-number">7.1.</span> <span class="toc-text">方法：双指针交换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode-448%EF%BC%9A%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">8.</span> <span class="toc-text">Leetcode-448：找到所有数组中消失的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C"><span class="toc-number">8.1.</span> <span class="toc-text">方法：原地哈希</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://pic4.zhimg.com/80/v2-5cb1e2bdc0644f9828029a94181f4542_1440w.jpg"></div><div class="author-info__name text-center">Alex</div><div class="author-info__description text-center">pwn</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">49</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://n0vice.top/">N0vice</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://snowywar.top/">魔法少女雪殇</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://l0ne1y.xyz/">L0ne1y</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://eeeeeeeeeeeeeeeea.cn/">eeeeeeeeeeeeeeeea</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://giles-one.github.io/">cat03</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://ulrica66666.github.io/">ulrica66666</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Alex's blog~</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">算法练习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-02</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Leetcode-1：两数之和"><a href="#Leetcode-1：两数之和" class="headerlink" title="Leetcode-1：两数之和"></a>Leetcode-1：两数之和</h2><p><img src="https://s2.loli.net/2023/03/02/EZ5yW3laes1MhOu.png" alt="image.png"></p>
<h3 id="方法一：暴力循环"><a href="#方法一：暴力循环" class="headerlink" title="方法一：暴力循环"></a>方法一：暴力循环</h3><p>思路就是两层循环，遍历数组元素，求和比较是否和target相等，比较无脑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">if</span> (tmp == target)</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>显然效率不是很高</p>
<p><img src="https://s2.loli.net/2023/03/02/xgLfkwj2SFce6OI.png" alt="image.png"></p>
<h3 id="方法二：哈希表存储"><a href="#方法二：哈希表存储" class="headerlink" title="方法二：哈希表存储"></a>方法二：哈希表存储</h3><p>假设nums数组为[1,2,3,4,5]，target为5，那么返回结果应该为[1,2]。</p>
<p>此思路是，遍历nums数组，然后利用target减去每个数组中的元素，如果这个元素在哈希表中出现，那么就返回哈希表中对应数字的index和当前index，得到答案；若没找到，则将当前元素存入哈希表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = target - nums[i];</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.find(ret);</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> pre = it-&gt;second - <span class="number">1</span>; <span class="comment">// 第一个数字的序号</span></span><br><span class="line">                <span class="keyword">return</span> &#123;pre, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m[nums[i]] = i + <span class="number">1</span>; <span class="comment">// 存储数组中值的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2, 0</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此方法执行效率较高</p>
<p><img src="https://s2.loli.net/2023/03/02/leV5iZ38zcIDkEU.png" alt=""></p>
<h2 id="Leetcode-21：合并两个有序链表"><a href="#Leetcode-21：合并两个有序链表" class="headerlink" title="Leetcode-21：合并两个有序链表"></a>Leetcode-21：合并两个有序链表</h2><p><img src="https://s2.loli.net/2023/03/04/zdwm6y32HIWlMcq.png" alt=""></p>
<h3 id="方法一：工作节点连接"><a href="#方法一：工作节点连接" class="headerlink" title="方法一：工作节点连接"></a>方法一：工作节点连接</h3><p>思路是建立两个指针，一个作为返回用的指针，一个作为工作节点，list1和list2比较，谁小，就让工作节点连上去，然后将对应的list后移，逐个比较即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* result = <span class="keyword">new</span> ListNode();  <span class="comment">// 作为返回值返回</span></span><br><span class="line">        ListNode* tmp = result;               <span class="comment">// 工作节点</span></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">NULL</span> &amp;&amp; list2 != <span class="literal">NULL</span>) </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>)</span><br><span class="line">            tmp-&gt;next = list2;      <span class="comment">// list1为空，合并list2即可    </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>)</span><br><span class="line">            tmp-&gt;next = list1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result-&gt;next;        <span class="comment">// result的第一个元素为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/03/04/Cvfz9uQmKhqZ8on.png" alt=""></p>
<h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p>借助官网上的递归思路，如下（一看就会，一写就废QAQ）：</p>
<p><img src="https://s2.loli.net/2023/03/04/FwCPL6ASvJrh9bi.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;</span><br><span class="line">            list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/03/04/DlCF81LryOYWZbM.png" alt=""></p>
<h2 id="Leetcode-70：爬楼梯-递归"><a href="#Leetcode-70：爬楼梯-递归" class="headerlink" title="Leetcode-70：爬楼梯-递归"></a>Leetcode-70：爬楼梯-递归</h2><p>难度：简单</p>
<p><img src="https://s2.loli.net/2023/03/02/Gb4s8IyrnkLRC3Z.png" alt=""></p>
<h3 id="方法一：记忆化递归"><a href="#方法一：记忆化递归" class="headerlink" title="方法一：记忆化递归"></a>方法一：记忆化递归</h3><p>一开始用普通递归，会超时，所以用记忆化递归，核心思想是用一个数组存储中间递归计算的结果，这样递归到某个值时，先查询是否在数组中，如果在，则直接返回，不在的话就进行递归，并将递归后的值存入到数组中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">46</span>, <span class="number">0</span>);    <span class="comment">// 初始元素为0</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (result[n])  <span class="keyword">return</span> result[n];</span><br><span class="line">            <span class="keyword">int</span> ret = climbStairs(n<span class="number">-1</span>) + climbStairs(n<span class="number">-2</span>);</span><br><span class="line">            result[n] = ret;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：双指针解法"><a href="#方法二：双指针解法" class="headerlink" title="方法二：双指针解法"></a>方法二：双指针解法</h3><p>核心思想如下：假设第一个指针n1指向1，第二个指针n2指向2，那么如果要求n=4的情况，就从底部向顶部循环，先求n=3，再求n=4。n=3时，结果为n1+n2 = 3，此时将两个指针分别向后移动，n1指向2，n2指向3，当n=4时再重复以上步骤。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> prePre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result = pre + prePre;</span><br><span class="line">            prePre = pre;</span><br><span class="line">            pre = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此解法性能更为优越</p>
<p><img src="https://s2.loli.net/2023/03/02/4pSCZ93DrRhx7dY.png" alt=""></p>
<h2 id="Leetcode-83：删除排序链表中的重复元素"><a href="#Leetcode-83：删除排序链表中的重复元素" class="headerlink" title="Leetcode-83：删除排序链表中的重复元素"></a>Leetcode-83：删除排序链表中的重复元素</h2><p><img src="https://s2.loli.net/2023/03/05/Iw9lOJWqdnHyNQt.png" alt=""></p>
<h3 id="方法：前后双指针"><a href="#方法：前后双指针" class="headerlink" title="方法：前后双指针"></a>方法：前后双指针</h3><p>思路是一前一后两个指针，若对应的值相等，则将前面的current指针指向的结点删除，即current后移，pre指向新的current；若对应的值不等，则二者同时后移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> ListNode(<span class="number">-101</span>);</span><br><span class="line">        ListNode* current = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ( current != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre-&gt;val != current-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果相等，则删除current节点</span></span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                pre-&gt;next = current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/03/05/5SLITapiDFmxel6.png" alt=""></p>
<h2 id="Leetcode-88：合并两个有序数组"><a href="#Leetcode-88：合并两个有序数组" class="headerlink" title="Leetcode-88：合并两个有序数组"></a>Leetcode-88：合并两个有序数组</h2><p><img src="https://s2.loli.net/2023/03/03/2zBCIkXhTroQ69a.png" alt=""></p>
<h3 id="方法一：合并数组再排序"><a href="#方法一：合并数组再排序" class="headerlink" title="方法一：合并数组再排序"></a>方法一：合并数组再排序</h3><p>核心思路就是将nums1和nums2进行合并，然后用sort方法将二者排序，比较无脑，不赘述了。</p>
<h3 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><p>核心思路是申请一个额外的数组，长度为m+n，然后在两个数组头部各自设立一个指针，比较对应值的大小，小的放进那个额外的数组里，并将指针后移，再进行比较。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + n, <span class="number">0</span>); <span class="comment">// 申请一个额外的vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; k &lt; m + n; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == m) </span><br><span class="line">                tmp[k++] = nums2[j++];      <span class="comment">// nums1已经取完，只取nums2即可</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == n)</span><br><span class="line">                tmp[k++] = nums1[i++];      <span class="comment">// nums2已经取完，只取nums1即可</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt;= nums2[j])</span><br><span class="line">                tmp[k++] = nums1[i++];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[k++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; i++)</span><br><span class="line">            nums1[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/03/03/DsOpzM2xLdqBtmQ.png" alt=""></p>
<h3 id="方法三：逆向双指针"><a href="#方法三：逆向双指针" class="headerlink" title="方法三：逆向双指针"></a>方法三：逆向双指针</h3><p>核心思路是，nums1在尾部设立一个指针，nums2在尾部设立一个指针，比较大小，大的插进最后面，依次向前。有此思路的核心在于nums1和nums2都为有序数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;                  <span class="comment">// 当nums2取完时直接退出循环即可，因为nums1本身就是有序的</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[i + j + <span class="number">1</span>] = nums2[j];  <span class="comment">// 当nums1取完后，把nums2取到nums1即可</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums2[j] &gt;= nums1[i]) &#123;</span><br><span class="line">                nums1[i + j + <span class="number">1</span>] = nums2[j];    <span class="comment">// 在nums1的尾部放入最大的元素</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                nums1[i + j + <span class="number">1</span>] = nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/03/03/XN1xey9Wlnt2dcM.png" alt=""></p>
<h2 id="Leetcode-141：环形链表"><a href="#Leetcode-141：环形链表" class="headerlink" title="Leetcode-141：环形链表"></a>Leetcode-141：环形链表</h2><p><img src="https://s2.loli.net/2023/03/06/RidMsCoWD3m4JFV.png" alt=""></p>
<h3 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h3><p>方法是建立一个哈希表，将出现过的节点存入哈希表，如果在哈希表中发现了当前节点，就证明该节点之前遍历过，即存在环路。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;ListNode*, <span class="keyword">int</span>&gt; data;</span><br><span class="line">        ListNode* tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;ListNode*, <span class="keyword">int</span>&gt;::iterator it = data.find(tmp);</span><br><span class="line">            <span class="keyword">if</span> (it != data.end())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                data.insert(<span class="built_in">pair</span>&lt;ListNode*, <span class="keyword">int</span>&gt;(tmp, <span class="number">1</span>));</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/03/06/7cRzieQq9GSyOba.png" alt=""></p>
<h3 id="方法二：Floyd判圈算法"><a href="#方法二：Floyd判圈算法" class="headerlink" title="方法二：Floyd判圈算法"></a>方法二：Floyd判圈算法</h3><p>思路是快慢指针，如果存在环路，则快慢指针必相遇</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/03/06/cuv3nyUj7KlMVWZ.png" alt=""></p>
<h2 id="Leetcode-283：移动零"><a href="#Leetcode-283：移动零" class="headerlink" title="Leetcode-283：移动零"></a>Leetcode-283：移动零</h2><p><img src="https://s2.loli.net/2023/03/04/C54gxOm1TAFcDPE.png" alt=""></p>
<h3 id="方法：双指针交换"><a href="#方法：双指针交换" class="headerlink" title="方法：双指针交换"></a>方法：双指针交换</h3><p>设立一个双指针，p1永远指向0元素，p2永远指向大于p1位置的非0元素，然后交换二者的值，即可逐渐把0元素移动到末尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;                 <span class="comment">// p1永远指向0元素，p2永远指向非零元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p2] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[p1] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[p2];</span><br><span class="line">                    nums[p2] = nums[p1];</span><br><span class="line">                    nums[p1] = tmp;         <span class="comment">// 交换两个值</span></span><br><span class="line">                    p1++;</span><br><span class="line">                    p2++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    p1++;</span><br><span class="line">                    p2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/03/04/jqHaRPZU4TJB396.png" alt=""></p>
<h2 id="Leetcode-448：找到所有数组中消失的数字"><a href="#Leetcode-448：找到所有数组中消失的数字" class="headerlink" title="Leetcode-448：找到所有数组中消失的数字"></a>Leetcode-448：找到所有数组中消失的数字</h2><p><img src="https://s2.loli.net/2023/03/04/emKUt6DQ9Za1dPH.png" alt=""></p>
<h3 id="方法：原地哈希"><a href="#方法：原地哈希" class="headerlink" title="方法：原地哈希"></a>方法：原地哈希</h3><p>思路是，将题目所给的数组作为一个哈希表，利用鸽笼原理来标记哪个空间被占用，在本题中“被占用”的标志是加上数组的长度，那么其元素的值就不在1-n的范围内了，最后遍历整个数组，看哪些元素还在1-n范围内，这些元素对应的下标（加一）就是1-n中缺失的数字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (nums[i] - <span class="number">1</span>) % n; <span class="comment">// 获得下一个元素的下标，模n的原因是要对数组本身的元素进行修改</span></span><br><span class="line">            nums[index] += n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= n)</span><br><span class="line">                result.push_back(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>没找到更好的办法，不知道为什么执行用时那么久QAQ</p>
<p><img src="https://s2.loli.net/2023/03/04/CpqMeFzihgGWjT3.png" alt=""></p>
<!-- flag of hidden posts --></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Alex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/02/算法练习/">http://example.com/2023/03/02/算法练习/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">Alex's blog~</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><nav id="pagination"></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/03/05/xqReclzVihJKGUu.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021.03.05 - 2023 By Alex</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>